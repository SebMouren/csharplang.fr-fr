# <a name="conversions"></a><span data-ttu-id="b4690-101">Conversions</span><span class="sxs-lookup"><span data-stu-id="b4690-101">Conversions</span></span>

<span data-ttu-id="b4690-102">Un ***conversion*** permet à une expression à être traitée comme étant d’un type particulier.</span><span class="sxs-lookup"><span data-stu-id="b4690-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="b4690-103">Une conversion peut provoquer une expression d’un type donné pour être considérée comme ayant un type différent, ou elle peut provoquer une expression sans un type pour lequel obtenir un type.</span><span class="sxs-lookup"><span data-stu-id="b4690-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="b4690-104">Les conversions peuvent être ***implicite*** ou ***explicite***, ce qui détermine si un cast explicite est requis.</span><span class="sxs-lookup"><span data-stu-id="b4690-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="b4690-105">Par exemple, la conversion de type `int` à taper `long` est implicite, c’est le cas expressions de type `int` peuvent être traitées en tant que type `long`.</span><span class="sxs-lookup"><span data-stu-id="b4690-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="b4690-106">La conversion opposée, à partir du type `long` à taper `int`, est explicite et un cast explicite est donc requis.</span><span class="sxs-lookup"><span data-stu-id="b4690-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="b4690-107">Certaines conversions sont définies par le langage.</span><span class="sxs-lookup"><span data-stu-id="b4690-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="b4690-108">Programmes peuvent également définir leurs propres conversions ([conversions définies par l’utilisateur](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="b4690-109">Conversions implicites</span><span class="sxs-lookup"><span data-stu-id="b4690-109">Implicit conversions</span></span>

<span data-ttu-id="b4690-110">Les conversions suivantes sont classées comme les conversions implicites :</span><span class="sxs-lookup"><span data-stu-id="b4690-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="b4690-111">Conversions d’identité</span><span class="sxs-lookup"><span data-stu-id="b4690-111">Identity conversions</span></span>
*  <span data-ttu-id="b4690-112">Conversions numériques implicites</span><span class="sxs-lookup"><span data-stu-id="b4690-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="b4690-113">Conversions d’énumération implicites.</span><span class="sxs-lookup"><span data-stu-id="b4690-113">Implicit enumeration conversions.</span></span>
*  <span data-ttu-id="b4690-114">Conversions implicites nullables</span><span class="sxs-lookup"><span data-stu-id="b4690-114">Implicit nullable conversions</span></span>
*  <span data-ttu-id="b4690-115">Conversions de littéral NULL</span><span class="sxs-lookup"><span data-stu-id="b4690-115">Null literal conversions</span></span>
*  <span data-ttu-id="b4690-116">Conversions de référence implicite</span><span class="sxs-lookup"><span data-stu-id="b4690-116">Implicit reference conversions</span></span>
*  <span data-ttu-id="b4690-117">Conversions boxing</span><span class="sxs-lookup"><span data-stu-id="b4690-117">Boxing conversions</span></span>
*  <span data-ttu-id="b4690-118">Conversions implicites dynamiques</span><span class="sxs-lookup"><span data-stu-id="b4690-118">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="b4690-119">Conversions d’expression constante implicites</span><span class="sxs-lookup"><span data-stu-id="b4690-119">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="b4690-120">Conversions implicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="b4690-120">User-defined implicit conversions</span></span>
*  <span data-ttu-id="b4690-121">Conversions de fonctions anonymes</span><span class="sxs-lookup"><span data-stu-id="b4690-121">Anonymous function conversions</span></span>
*  <span data-ttu-id="b4690-122">Conversions de groupe (méthode)</span><span class="sxs-lookup"><span data-stu-id="b4690-122">Method group conversions</span></span>

<span data-ttu-id="b4690-123">Les conversions implicites peuvent se produire dans diverses situations, y compris les appels de fonctions membres ([la vérification de la résolution de surcharge dynamique lors de la compilation](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), les expressions de cast ([les expressions de Cast](expressions.md#cast-expressions)), et les affectations ([opérateurs d’assignation](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="b4690-123">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="b4690-124">Les conversions implicites prédéfinies réussissent toujours et ne provoquent jamais levée d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="b4690-124">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="b4690-125">Correctement conçu les conversions implicites définies par l’utilisateur doivent présenter ces caractéristiques ainsi.</span><span class="sxs-lookup"><span data-stu-id="b4690-125">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="b4690-126">Dans le cadre de la conversion, les types `object` et `dynamic` sont considérées comme équivalentes.</span><span class="sxs-lookup"><span data-stu-id="b4690-126">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="b4690-127">Toutefois, les conversions dynamiques ([les conversions implicites dynamiques](conversions.md#implicit-dynamic-conversions) et [les conversions explicites dynamiques](conversions.md#explicit-dynamic-conversions)) s’appliquent uniquement aux expressions de type `dynamic` ([du type dynamic](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="b4690-127">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="b4690-128">Conversion d’identité</span><span class="sxs-lookup"><span data-stu-id="b4690-128">Identity conversion</span></span>

<span data-ttu-id="b4690-129">Une conversion d’identité convertit à partir de n’importe quel type vers le même type.</span><span class="sxs-lookup"><span data-stu-id="b4690-129">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="b4690-130">Cette conversion existe telles qu’une entité qui possède déjà un type requis peut être désignée pour être convertible vers ce type.</span><span class="sxs-lookup"><span data-stu-id="b4690-130">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="b4690-131">Objet et dynamique sont considérées comme équivalentes étant une conversion d’identité entre `object` et `dynamic`et entre les types construits sont les mêmes lors du remplacement de toutes les occurrences de `dynamic` avec `object`.</span><span class="sxs-lookup"><span data-stu-id="b4690-131">Because object and dynamic are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="b4690-132">Conversions numériques implicites</span><span class="sxs-lookup"><span data-stu-id="b4690-132">Implicit numeric conversions</span></span>

<span data-ttu-id="b4690-133">Les conversions numériques implicites sont :</span><span class="sxs-lookup"><span data-stu-id="b4690-133">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="b4690-134">À partir de `sbyte` à `short`, `int`, `long`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-134">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-135">À partir de `byte` à `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-135">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-136">À partir de `short` à `int`, `long`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-136">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-137">À partir de `ushort` à `int`, `uint`, `long`, `ulong`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-137">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-138">À partir de `int` à `long`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-138">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-139">À partir de `uint` à `long`, `ulong`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-139">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-140">À partir de `long` à `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-140">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-141">À partir de `ulong` à `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-141">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-142">À partir de `char` à `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-142">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-143">À partir de `float` à `double`.</span><span class="sxs-lookup"><span data-stu-id="b4690-143">From `float` to `double`.</span></span>

<span data-ttu-id="b4690-144">Les conversions de `int`, `uint`, `long`, ou `ulong` à `float` et à partir de `long` ou `ulong` à `double` peut entraîner une perte de précision, mais ne provoqueront jamais une perte d’amplitude.</span><span class="sxs-lookup"><span data-stu-id="b4690-144">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="b4690-145">Les autres conversions numériques implicites perdent jamais toutes les informations.</span><span class="sxs-lookup"><span data-stu-id="b4690-145">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="b4690-146">Aucune conversion implicite vers le `char` tapez, donc les valeurs des autres types intégraux ne convertissez pas automatiquement le `char` type.</span><span class="sxs-lookup"><span data-stu-id="b4690-146">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="b4690-147">Conversions d’énumération implicites</span><span class="sxs-lookup"><span data-stu-id="b4690-147">Implicit enumeration conversions</span></span>

<span data-ttu-id="b4690-148">Une conversion implicite d’énumération permet la *decimal_integer_literal* `0` à convertir en un *type_de_liste* et tous les *nullable_type* dont le type sous-jacent est un *type_de_liste*.</span><span class="sxs-lookup"><span data-stu-id="b4690-148">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="b4690-149">Dans ce cas, la conversion est évaluée en convertissant sous-jacentes *type_de_liste* et le résultat d’habillage ([types Nullable](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="b4690-149">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="b4690-150">Conversions implicites de chaîne interpolée</span><span class="sxs-lookup"><span data-stu-id="b4690-150">Implicit interpolated string conversions</span></span>

<span data-ttu-id="b4690-151">Implicite interpolées permis de conversion de chaîne une *interpolated_string_expression* ([chaînes interpolées](expressions.md#interpolated-strings)) à convertir en `System.IFormattable` ou `System.FormattableString` (qui met en œuvre `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="b4690-151">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="b4690-152">Lorsque cette conversion est appliquée une valeur de chaîne n’est pas composée à partir de la chaîne interpolée.</span><span class="sxs-lookup"><span data-stu-id="b4690-152">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="b4690-153">À la place une instance de `System.FormattableString` est créée, comme indiqué dans [chaînes interpolées](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="b4690-153">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="b4690-154">Conversions implicites nullables</span><span class="sxs-lookup"><span data-stu-id="b4690-154">Implicit nullable conversions</span></span>

<span data-ttu-id="b4690-155">Les conversions implicites prédéfinies qui opèrent sur des types valeur non nullable peuvent également servir avec forms nullables de ces types.</span><span class="sxs-lookup"><span data-stu-id="b4690-155">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="b4690-156">Pour chaque identité implicites prédéfinie et des conversions numériques convertir à partir d’un type valeur non nullable `S` à un type valeur non nullable `T`, les conversions implicites de nullables suivantes existent :</span><span class="sxs-lookup"><span data-stu-id="b4690-156">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="b4690-157">Une conversion implicite de `S?` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-157">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="b4690-158">Une conversion implicite de `S` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-158">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="b4690-159">Évaluation d’une conversion implicite nullable basée sur une conversion sous-jacent de `S` à `T` procède comme suit :</span><span class="sxs-lookup"><span data-stu-id="b4690-159">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="b4690-160">Si la conversion nullable à partir de `S?` à `T?`:</span><span class="sxs-lookup"><span data-stu-id="b4690-160">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="b4690-161">Si la valeur source est null (`HasValue` propriété a la valeur false), le résultat est la valeur null de type `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-161">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="b4690-162">Sinon, la conversion est évaluée comme un dévoilement de `S?` à `S`, suivie de la conversion sous-jacent de `S` à `T`, suivie d’un retour à la ligne ([types Nullable](types.md#nullable-types)) à partir de `T` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-162">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="b4690-163">Si la conversion nullable à partir de `S` à `T?`, la conversion est évaluée comme la conversion sous-jacent de `S` à `T` suivie d’un retour à la ligne à partir de `T` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-163">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="b4690-164">Conversions de littéral NULL</span><span class="sxs-lookup"><span data-stu-id="b4690-164">Null literal conversions</span></span>

<span data-ttu-id="b4690-165">Il existe une conversion implicite à partir de la `null` littéral à n’importe quel type nullable.</span><span class="sxs-lookup"><span data-stu-id="b4690-165">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="b4690-166">Cette conversion génère la valeur null ([types Nullable](types.md#nullable-types)) du type nullable donné.</span><span class="sxs-lookup"><span data-stu-id="b4690-166">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="b4690-167">Conversions de référence implicite</span><span class="sxs-lookup"><span data-stu-id="b4690-167">Implicit reference conversions</span></span>

<span data-ttu-id="b4690-168">Les conversions implicites de référence sont :</span><span class="sxs-lookup"><span data-stu-id="b4690-168">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="b4690-169">À partir d’un *reference_type* à `object` et `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="b4690-169">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="b4690-170">À partir d’un *class_type* `S` aux *class_type* `T`, fourni `S` est dérivée de `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-170">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="b4690-171">À partir d’un *class_type* `S` aux *interface_type* `T`, fourni `S` implémente `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-171">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="b4690-172">À partir d’un *interface_type* `S` aux *interface_type* `T`, fourni `S` est dérivée de `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-172">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="b4690-173">À partir d’un *array_type* `S` avec un type d’élément `SE` à un *array_type* `T` avec un type d’élément `TE`, à condition que toutes les conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="b4690-173">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="b4690-174">`S` et `T` diffèrent uniquement par le type d’élément.</span><span class="sxs-lookup"><span data-stu-id="b4690-174">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="b4690-175">En d’autres termes, `S` et `T` ont le même nombre de dimensions.</span><span class="sxs-lookup"><span data-stu-id="b4690-175">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="b4690-176">Les deux `SE` et `TE` sont *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="b4690-176">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="b4690-177">Il existe une conversion de référence implicite à partir de `SE` à `TE`.</span><span class="sxs-lookup"><span data-stu-id="b4690-177">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="b4690-178">À partir d’un *array_type* à `System.Array` et les interfaces qu’il implémente.</span><span class="sxs-lookup"><span data-stu-id="b4690-178">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="b4690-179">À partir d’un type de tableau unidimensionnel `S[]` à `System.Collections.Generic.IList<T>` et ses interfaces de base, autant que qu’il existe une conversion implicite de référence ou d’identité à partir de `S` à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-179">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="b4690-180">À partir d’un *delegate_type* à `System.Delegate` et les interfaces qu’il implémente.</span><span class="sxs-lookup"><span data-stu-id="b4690-180">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="b4690-181">À partir du littéral null en un *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-181">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="b4690-182">À partir d’un *reference_type* à un *reference_type* `T` si elle a une conversion implicite de référence ou d’identité pour un *reference_type* `T0` et `T0` a une conversion d’identité à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-182">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="b4690-183">À partir d’un *reference_type* à un type d’interface ou un délégué `T` si elle a une conversion implicite de référence ou d’identité à un type d’interface ou un délégué `T0` et `T0` est convertible en variance ([ Conversion de variance](interfaces.md#variance-conversion)) à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-183">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="b4690-184">Conversions implicites impliquant des paramètres de type qui sont connus pour être des types référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-184">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="b4690-185">Consultez [conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters) pour plus d’informations sur les conversions implicites impliquant des paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="b4690-185">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="b4690-186">Les conversions de référence implicites sont les conversions entre *reference_type*s qui peut être prouvé aboutissent toujours et ne nécessitent donc aucune vérification au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="b4690-186">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="b4690-187">Conversions de référence, implicites ou explicites, jamais changent l’identité référentielle de l’objet en cours de conversion.</span><span class="sxs-lookup"><span data-stu-id="b4690-187">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="b4690-188">En d’autres termes, si une conversion de référence peut modifier le type de la référence, il ne change jamais le type ou la valeur de l’objet fait référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-188">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="b4690-189">Conversions boxing</span><span class="sxs-lookup"><span data-stu-id="b4690-189">Boxing conversions</span></span>

<span data-ttu-id="b4690-190">Une conversion boxing permet un *value_type* être converti implicitement en un type référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-190">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="b4690-191">Il existe une conversion boxing de n’importe quel *non_nullable_value_type* à `object` et `dynamic`, à `System.ValueType` et tous les *interface_type* implémentée par le *non_ nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-191">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="b4690-192">En outre un *type_de_liste* peut être converti au type `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="b4690-192">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="b4690-193">Une conversion boxing existe à partir d’un *nullable_type* à un type référence, si et seulement si une conversion boxing existe sous-jacent *non_nullable_value_type* pour le type de référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-193">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="b4690-194">Un type valeur a une conversion boxing en un type interface `I` si elle a une conversion boxing en un type interface `I0` et `I0` a une conversion d’identité à `I`.</span><span class="sxs-lookup"><span data-stu-id="b4690-194">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="b4690-195">Un type valeur a une conversion boxing en un type interface `I` si elle a une conversion boxing à un type d’interface ou un délégué `I0` et `I0` est convertible en variance ([la conversion de Variance](interfaces.md#variance-conversion)) à `I`.</span><span class="sxs-lookup"><span data-stu-id="b4690-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="b4690-196">Conversion boxing d’une valeur un *non_nullable_value_type* se compose d’allouer une instance d’objet et à copier le *value_type* valeur dans cette instance.</span><span class="sxs-lookup"><span data-stu-id="b4690-196">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="b4690-197">Un struct peut être converti au type `System.ValueType`, puisque c’est une classe de base pour tous les structs ([héritage](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="b4690-197">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="b4690-198">Conversion boxing d’une valeur un *nullable_type* procède comme suit :</span><span class="sxs-lookup"><span data-stu-id="b4690-198">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="b4690-199">Si la valeur source est null (`HasValue` propriété a la valeur false), le résultat est une référence null du type cible.</span><span class="sxs-lookup"><span data-stu-id="b4690-199">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="b4690-200">Sinon, le résultat est une référence à un boxed `T` produites par le désencapsulage et le boxing de la valeur source.</span><span class="sxs-lookup"><span data-stu-id="b4690-200">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="b4690-201">Les conversions boxing sont décrites dans [conversions Boxing](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="b4690-201">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="b4690-202">Conversions implicites dynamiques</span><span class="sxs-lookup"><span data-stu-id="b4690-202">Implicit dynamic conversions</span></span>

<span data-ttu-id="b4690-203">Il existe une conversion implicite de dynamique à partir d’une expression de type `dynamic` à n’importe quel type `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-203">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="b4690-204">La conversion est dynamiquement liée ([liaison dynamique](expressions.md#dynamic-binding)), ce qui signifie qu’une conversion implicite vous est demandée au moment de l’exécution à partir du type d’exécution de l’expression à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-204">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="b4690-205">Si aucune conversion n’est trouvée, une exception au moment de l’exécution est levée.</span><span class="sxs-lookup"><span data-stu-id="b4690-205">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="b4690-206">Notez que cette conversion implicite a apparemment enfreint le Conseil au début de [conversions implicites](conversions.md#implicit-conversions) qu’une conversion implicite ne doit jamais lever une exception.</span><span class="sxs-lookup"><span data-stu-id="b4690-206">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="b4690-207">Il n’est toutefois pas la conversion elle-même, mais le *recherche* de la conversion qui provoque l’exception.</span><span class="sxs-lookup"><span data-stu-id="b4690-207">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="b4690-208">Le risque d’exceptions d’exécution est inhérent à l’utilisation de la liaison dynamique.</span><span class="sxs-lookup"><span data-stu-id="b4690-208">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="b4690-209">Si la liaison dynamique de la conversion n’est pas souhaitée, l’expression peut être convertie tout d’abord à `object`et ensuite vers le type souhaité.</span><span class="sxs-lookup"><span data-stu-id="b4690-209">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="b4690-210">L’exemple suivant illustre les conversions implicites dynamiques :</span><span class="sxs-lookup"><span data-stu-id="b4690-210">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="b4690-211">Les affectations à `s2` et `i` les deux utilisent des conversions implicites dynamiques, dans laquelle la liaison des opérations est interrompue avant l’exécution.</span><span class="sxs-lookup"><span data-stu-id="b4690-211">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="b4690-212">Au moment de l’exécution, les conversions implicites sont recherchées à partir du type d’exécution de `d`  --  `string` --vers le type cible.</span><span class="sxs-lookup"><span data-stu-id="b4690-212">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="b4690-213">Une conversion a été `string` , mais pas au `int`.</span><span class="sxs-lookup"><span data-stu-id="b4690-213">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="b4690-214">Conversions d’expression constante implicites</span><span class="sxs-lookup"><span data-stu-id="b4690-214">Implicit constant expression conversions</span></span>

<span data-ttu-id="b4690-215">Une conversion d’expression constante implicite permet les conversions suivantes :</span><span class="sxs-lookup"><span data-stu-id="b4690-215">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="b4690-216">Un *constant_expression* ([expressions constantes](expressions.md#constant-expressions)) de type `int` peut être converti en type `sbyte`, `byte`, `short`, `ushort`, `uint`, ou `ulong`, fourni la valeur de la *constant_expression* se trouve dans la plage du type de destination.</span><span class="sxs-lookup"><span data-stu-id="b4690-216">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="b4690-217">Un *constant_expression* de type `long` peut être converti en type `ulong`, fourni la valeur de la *constant_expression* ne soit pas négative.</span><span class="sxs-lookup"><span data-stu-id="b4690-217">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="b4690-218">Conversions implicites impliquant des paramètres de type</span><span class="sxs-lookup"><span data-stu-id="b4690-218">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="b4690-219">Les conversions implicites suivantes existent pour un paramètre de type donné `T`:</span><span class="sxs-lookup"><span data-stu-id="b4690-219">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="b4690-220">À partir de `T` à sa classe de base efficace `C`, à partir de `T` à n’importe quelle classe de base de `C`et à partir de `T` à n’importe quelle interface implémentée par `C`.</span><span class="sxs-lookup"><span data-stu-id="b4690-220">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="b4690-221">Au moment de l’exécution, if `T` est un type valeur, la conversion est exécutée comme une conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="b4690-221">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="b4690-222">Sinon, la conversion est exécutée en tant qu’une conversion de référence implicite ou la conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="b4690-222">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="b4690-223">À partir de `T` en un type interface `I` dans `T`ensemble interface efficace et à partir de `T` à n’importe quelle interface de base de `I`.</span><span class="sxs-lookup"><span data-stu-id="b4690-223">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="b4690-224">Au moment de l’exécution, if `T` est un type valeur, la conversion est exécutée comme une conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="b4690-224">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="b4690-225">Sinon, la conversion est exécutée en tant qu’une conversion de référence implicite ou la conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="b4690-225">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="b4690-226">À partir de `T` à un paramètre de type `U`, fourni `T` dépend `U` ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b4690-226">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="b4690-227">Au moment de l’exécution, if `U` est un type valeur, puis `T` et `U` sont nécessairement du même type et aucune conversion n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="b4690-227">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="b4690-228">Sinon, si `T` est un type valeur, la conversion est exécutée comme une conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="b4690-228">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="b4690-229">Sinon, la conversion est exécutée en tant qu’une conversion de référence implicite ou la conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="b4690-229">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="b4690-230">À partir du littéral null en `T`, fourni `T` est connu pour être un type référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-230">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="b4690-231">À partir de `T` à un type référence `I` si elle a une conversion implicite en un type référence `S0` et `S0` a une conversion d’identité à `S`.</span><span class="sxs-lookup"><span data-stu-id="b4690-231">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="b4690-232">Au moment de l’exécution, la conversion est exécutée la même façon que la conversion en `S0`.</span><span class="sxs-lookup"><span data-stu-id="b4690-232">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="b4690-233">À partir de `T` en un type interface `I` si elle a une conversion implicite en une interface ou un type délégué `I0` et `I0` est convertible en variance à `I` ([la conversion de Variance](interfaces.md#variance-conversion) ).</span><span class="sxs-lookup"><span data-stu-id="b4690-233">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="b4690-234">Au moment de l’exécution, if `T` est un type valeur, la conversion est exécutée comme une conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="b4690-234">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="b4690-235">Sinon, la conversion est exécutée en tant qu’une conversion de référence implicite ou la conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="b4690-235">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="b4690-236">Si `T` est connu pour être un type référence ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)), les conversions ci-dessus sont classées comme des conversions de référence implicite ([conversions de référence implicite](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-236">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="b4690-237">Si `T` est ne pas connu pour être un type référence, les conversions ci-dessus sont classées comme des conversions boxing ([conversions Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-237">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="b4690-238">Conversions implicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="b4690-238">User-defined implicit conversions</span></span>

<span data-ttu-id="b4690-239">Une conversion implicite défini par l’utilisateur se compose d’une conversion implicite standard facultative, suivie de l’exécution d’un opérateur de conversion implicite définie par l’utilisateur, suivie d’une autre conversion implicite standard facultative.</span><span class="sxs-lookup"><span data-stu-id="b4690-239">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="b4690-240">Les règles exactes d’évaluation des conversions implicites définies par l’utilisateur sont décrites dans [le traitement de conversions implicites définies par l’utilisateur](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="b4690-240">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="b4690-241">Conversions de fonctions anonymes et les conversions de groupe (méthode)</span><span class="sxs-lookup"><span data-stu-id="b4690-241">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="b4690-242">Fonctions anonymes et les groupes de méthode et ne sont pas types dans leur propre, mais peuvent être implicitement convertis pour déléguer des types ou des types arborescence d’expression.</span><span class="sxs-lookup"><span data-stu-id="b4690-242">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="b4690-243">Conversions de fonctions anonymes sont décrits plus en détail dans [conversions de fonctions anonymes](conversions.md#anonymous-function-conversions) méthode conversions et groupe dans [conversions de groupes de méthode](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="b4690-243">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="b4690-244">Conversions explicites</span><span class="sxs-lookup"><span data-stu-id="b4690-244">Explicit conversions</span></span>

<span data-ttu-id="b4690-245">Les conversions suivantes sont classées comme des conversions explicites :</span><span class="sxs-lookup"><span data-stu-id="b4690-245">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="b4690-246">Toutes les conversions implicites.</span><span class="sxs-lookup"><span data-stu-id="b4690-246">All implicit conversions.</span></span>
*  <span data-ttu-id="b4690-247">Conversions numériques explicites.</span><span class="sxs-lookup"><span data-stu-id="b4690-247">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="b4690-248">Conversions d’énumération explicites.</span><span class="sxs-lookup"><span data-stu-id="b4690-248">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="b4690-249">Conversions explicites nullables.</span><span class="sxs-lookup"><span data-stu-id="b4690-249">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="b4690-250">Conversions de référence explicite.</span><span class="sxs-lookup"><span data-stu-id="b4690-250">Explicit reference conversions.</span></span>
*  <span data-ttu-id="b4690-251">Conversions d’interface explicite.</span><span class="sxs-lookup"><span data-stu-id="b4690-251">Explicit interface conversions.</span></span>
*  <span data-ttu-id="b4690-252">Conversions unboxing.</span><span class="sxs-lookup"><span data-stu-id="b4690-252">Unboxing conversions.</span></span>
*  <span data-ttu-id="b4690-253">Conversions explicites dynamiques</span><span class="sxs-lookup"><span data-stu-id="b4690-253">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="b4690-254">Conversions explicites définies par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b4690-254">User-defined explicit conversions.</span></span>

<span data-ttu-id="b4690-255">Les conversions explicites peuvent se produire dans les expressions de cast ([les expressions de Cast](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-255">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="b4690-256">Le jeu de conversions explicites inclut toutes les conversions implicites.</span><span class="sxs-lookup"><span data-stu-id="b4690-256">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="b4690-257">Cela signifie que les expressions cast redondantes sont autorisées.</span><span class="sxs-lookup"><span data-stu-id="b4690-257">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="b4690-258">Les conversions explicites qui ne sont pas les conversions implicites sont les conversions qui ne peut pas être prouvées aboutissent toujours, les conversions qui sont connues peuvent entraîner une perte d’informations et les conversions entre des domaines de types suffisamment différents pour mériter explicite notation.</span><span class="sxs-lookup"><span data-stu-id="b4690-258">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="b4690-259">Conversions numériques explicites</span><span class="sxs-lookup"><span data-stu-id="b4690-259">Explicit numeric conversions</span></span>

<span data-ttu-id="b4690-260">Conversions numériques explicites sont les conversions à partir d’un *numeric_type* vers un autre *numeric_type* pour lequel une conversion numérique implicite ([lesconversionsnumériquesimplicites](conversions.md#implicit-numeric-conversions)) n’existe pas déjà :</span><span class="sxs-lookup"><span data-stu-id="b4690-260">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="b4690-261">À partir de `sbyte` à `byte`, `ushort`, `uint`, `ulong`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="b4690-261">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="b4690-262">À partir de `byte` à `sbyte` et `char`.</span><span class="sxs-lookup"><span data-stu-id="b4690-262">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="b4690-263">À partir de `short` à `sbyte`, `byte`, `ushort`, `uint`, `ulong`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="b4690-263">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="b4690-264">À partir de `ushort` à `sbyte`, `byte`, `short`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="b4690-264">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="b4690-265">À partir de `int` à `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="b4690-265">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="b4690-266">À partir de `uint` à `sbyte`, `byte`, `short`, `ushort`, `int`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="b4690-266">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="b4690-267">À partir de `long` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="b4690-267">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="b4690-268">À partir de `ulong` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, ou `char`.</span><span class="sxs-lookup"><span data-stu-id="b4690-268">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="b4690-269">À partir de `char` à `sbyte`, `byte`, ou `short`.</span><span class="sxs-lookup"><span data-stu-id="b4690-269">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="b4690-270">À partir de `float` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-270">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-271">À partir de `double` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-271">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-272">À partir de `decimal` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, ou `double`.</span><span class="sxs-lookup"><span data-stu-id="b4690-272">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="b4690-273">Étant donné que les conversions explicites incluent toutes les conversions numériques implicites et explicites, il est toujours possible de convertir à partir d’un *numeric_type* n’importe quel autre *numeric_type* à l’aide d’une expression de cast () [Les expressions de cast](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-273">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="b4690-274">Conversions numériques explicites peuvent entraîner une perte d’informations ou éventuellement causer la levée d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="b4690-274">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="b4690-275">Une conversion numérique explicite est traitée comme suit :</span><span class="sxs-lookup"><span data-stu-id="b4690-275">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="b4690-276">Pour une conversion à partir d’un type intégral en un autre type intégral, le traitement varie selon le contexte de vérification de dépassement de capacité ([les opérateurs checked et unchecked](expressions.md#the-checked-and-unchecked-operators)) dans ce qui amène la conversion placer :</span><span class="sxs-lookup"><span data-stu-id="b4690-276">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="b4690-277">Dans un `checked` contexte, la conversion réussit si la valeur de l’opérande source se trouve dans la plage du type de destination, mais lève une `System.OverflowException` si la valeur de l’opérande source est en dehors de la plage du type de destination.</span><span class="sxs-lookup"><span data-stu-id="b4690-277">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="b4690-278">Dans un `unchecked` contexte, la conversion réussit toujours et procède comme suit.</span><span class="sxs-lookup"><span data-stu-id="b4690-278">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="b4690-279">Si le type source est plus grand que le type de destination, la valeur source est tronquée via l’abandon de ses bits « supplémentaires » les plus significatifs.</span><span class="sxs-lookup"><span data-stu-id="b4690-279">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="b4690-280">Le résultat est ensuite traité en tant que valeur du type de destination.</span><span class="sxs-lookup"><span data-stu-id="b4690-280">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="b4690-281">Si le type source est plus petit que le type de destination, la valeur source fait l’objet d’une extension de signe ou d’une extension de zéros, pour avoir la même taille que le type de destination.</span><span class="sxs-lookup"><span data-stu-id="b4690-281">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="b4690-282">L’extension de signe est utilisée si le type source est signé. L’extension de zéro est utilisée si le type source est non signé.</span><span class="sxs-lookup"><span data-stu-id="b4690-282">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="b4690-283">Le résultat est ensuite traité en tant que valeur du type de destination.</span><span class="sxs-lookup"><span data-stu-id="b4690-283">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="b4690-284">Si le type source a la même taille que le type de destination, la valeur source est traitée comme une valeur du type de destination.</span><span class="sxs-lookup"><span data-stu-id="b4690-284">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="b4690-285">Pour une conversion de `decimal` vers un type intégral, la valeur source est arrondie vers zéro à la valeur intégrale la plus proche, et cette valeur intégrale devient le résultat de la conversion.</span><span class="sxs-lookup"><span data-stu-id="b4690-285">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="b4690-286">Si la valeur intégrale obtenue est en dehors de la plage du type de destination, un `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="b4690-286">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="b4690-287">Pour une conversion à partir de `float` ou `double` vers un type intégral, le traitement varie selon le contexte de vérification de dépassement de capacité ([les opérateurs checked et unchecked](expressions.md#the-checked-and-unchecked-operators)) dans ce qui amène la conversion placer :</span><span class="sxs-lookup"><span data-stu-id="b4690-287">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="b4690-288">Dans un `checked` contexte, la conversion se déroule comme suit :</span><span class="sxs-lookup"><span data-stu-id="b4690-288">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="b4690-289">Si la valeur de l’opérande est NaN ou infinie, une `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="b4690-289">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="b4690-290">Sinon, l’opérande source est arrondie vers zéro à la valeur intégrale la plus proche.</span><span class="sxs-lookup"><span data-stu-id="b4690-290">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="b4690-291">Si cette valeur intégrale est dans la plage du type de destination de cette valeur est le résultat de la conversion.</span><span class="sxs-lookup"><span data-stu-id="b4690-291">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="b4690-292">Sinon, une exception `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="b4690-292">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="b4690-293">Dans un `unchecked` contexte, la conversion réussit toujours et procède comme suit.</span><span class="sxs-lookup"><span data-stu-id="b4690-293">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="b4690-294">Si la valeur de l’opérande est NaN ou infinie, le résultat de la conversion est une valeur non spécifiée du type de destination.</span><span class="sxs-lookup"><span data-stu-id="b4690-294">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="b4690-295">Sinon, l’opérande source est arrondie vers zéro à la valeur intégrale la plus proche.</span><span class="sxs-lookup"><span data-stu-id="b4690-295">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="b4690-296">Si cette valeur intégrale est dans la plage du type de destination de cette valeur est le résultat de la conversion.</span><span class="sxs-lookup"><span data-stu-id="b4690-296">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="b4690-297">Sinon, le résultat de la conversion est une valeur non spécifiée du type de destination.</span><span class="sxs-lookup"><span data-stu-id="b4690-297">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="b4690-298">Pour une conversion à partir de `double` à `float`, le `double` valeur est arrondie à la plus proche `float` valeur.</span><span class="sxs-lookup"><span data-stu-id="b4690-298">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="b4690-299">Si le `double` valeur est trop petite pour représenter un `float`, le résultat devient le zéro positif ou zéro négatif.</span><span class="sxs-lookup"><span data-stu-id="b4690-299">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="b4690-300">Si le `double` valeur est trop grand pour être représenté comme un `float`, le résultat devient l’infini positif ou l’infini négatif.</span><span class="sxs-lookup"><span data-stu-id="b4690-300">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="b4690-301">Si le `double` valeur est NaN, le résultat est également NaN.</span><span class="sxs-lookup"><span data-stu-id="b4690-301">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="b4690-302">Pour une conversion à partir de `float` ou `double` à `decimal`, la valeur source est convertie en `decimal` représentation et arrondie au nombre le plus proche après la 28ème décimale, si nécessaire ([type décimal](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="b4690-302">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="b4690-303">Si la valeur source est trop petite pour représenter un `decimal`, le résultat est zéro.</span><span class="sxs-lookup"><span data-stu-id="b4690-303">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="b4690-304">Si la valeur source est NaN, infini, ou il est trop grand pour être représenté comme un `decimal`, un `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="b4690-304">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="b4690-305">Pour une conversion à partir de `decimal` à `float` ou `double`, le `decimal` valeur est arrondie à la plus proche `double` ou `float` valeur.</span><span class="sxs-lookup"><span data-stu-id="b4690-305">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="b4690-306">Bien que cette conversion peut-être manquer de précision, elle ne génère jamais une exception levée.</span><span class="sxs-lookup"><span data-stu-id="b4690-306">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="b4690-307">Conversions d’énumération explicites</span><span class="sxs-lookup"><span data-stu-id="b4690-307">Explicit enumeration conversions</span></span>

<span data-ttu-id="b4690-308">Les conversions d’énumération explicite sont :</span><span class="sxs-lookup"><span data-stu-id="b4690-308">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="b4690-309">À partir de `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, ou `decimal` à n’importe quel *type_de_liste*.</span><span class="sxs-lookup"><span data-stu-id="b4690-309">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="b4690-310">À partir d’un *type_de_liste* à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="b4690-310">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="b4690-311">À partir d’un *type_de_liste* n’importe quel autre *type_de_liste*.</span><span class="sxs-lookup"><span data-stu-id="b4690-311">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="b4690-312">Une conversion d’énumération explicite entre deux types est traitée en considérant tout participant *type_de_liste* en tant que le type sous-jacent de qui *type_de_liste*, puis en effectuant une implicite ou explicite conversion numérique entre les types résultants.</span><span class="sxs-lookup"><span data-stu-id="b4690-312">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="b4690-313">Par exemple, étant donné un *type_de_liste* `E` avec et le type sous-jacent de `int`, une conversion de `E` à `byte` est traité comme une conversion numérique explicite ([explicite conversions numériques](conversions.md#explicit-numeric-conversions)) à partir de `int` à `byte`et une conversion à partir de `byte` à `E` est traité comme une conversion numérique implicite ([lesconversionsnumériquesimplicites](conversions.md#implicit-numeric-conversions)) à partir de `byte` à `int`.</span><span class="sxs-lookup"><span data-stu-id="b4690-313">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="b4690-314">Conversions explicites nullables</span><span class="sxs-lookup"><span data-stu-id="b4690-314">Explicit nullable conversions</span></span>

<span data-ttu-id="b4690-315">***Les conversions explicites nullables*** permis prédéfinis des conversions explicites qui fonctionnent sur des types valeur non nullable à utiliser avec les formulaires nullables de ces types.</span><span class="sxs-lookup"><span data-stu-id="b4690-315">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="b4690-316">Pour chacun des conversions explicites prédéfinies convertir à partir d’un type valeur non nullable `S` à un type valeur non nullable `T` ([conversion d’identité](conversions.md#identity-conversion), [lesconversionsnumériquesimplicites](conversions.md#implicit-numeric-conversions), [Conversions d’énumération implicites](conversions.md#implicit-enumeration-conversions), [conversions numériques explicites](conversions.md#explicit-numeric-conversions), et [conversions d’énumération explicites](conversions.md#explicit-enumeration-conversions)), ce qui suit Il existe des conversions nullables :</span><span class="sxs-lookup"><span data-stu-id="b4690-316">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="b4690-317">Une conversion explicite de `S?` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-317">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="b4690-318">Une conversion explicite de `S` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-318">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="b4690-319">Une conversion explicite de `S?` à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-319">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="b4690-320">Évaluation d’une conversion nullable basée sur une conversion sous-jacent de `S` à `T` procède comme suit :</span><span class="sxs-lookup"><span data-stu-id="b4690-320">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="b4690-321">Si la conversion nullable à partir de `S?` à `T?`:</span><span class="sxs-lookup"><span data-stu-id="b4690-321">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="b4690-322">Si la valeur source est null (`HasValue` propriété a la valeur false), le résultat est la valeur null de type `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-322">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="b4690-323">Sinon, la conversion est évaluée comme un dévoilement de `S?` à `S`, suivie de la conversion sous-jacent de `S` à `T`, suivie d’un retour à la ligne à partir de `T` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-323">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="b4690-324">Si la conversion nullable à partir de `S` à `T?`, la conversion est évaluée comme la conversion sous-jacent de `S` à `T` suivie d’un retour à la ligne à partir de `T` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-324">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="b4690-325">Si la conversion nullable à partir de `S?` à `T`, la conversion est évaluée comme un dévoilement de `S?` à `S` suivie de la conversion sous-jacent de `S` à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-325">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="b4690-326">Notez que toute tentative pour désencapsuler une valeur nullable lève une exception si la valeur est `null`.</span><span class="sxs-lookup"><span data-stu-id="b4690-326">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="b4690-327">Conversions de référence explicite</span><span class="sxs-lookup"><span data-stu-id="b4690-327">Explicit reference conversions</span></span>

<span data-ttu-id="b4690-328">Les conversions de référence explicite sont :</span><span class="sxs-lookup"><span data-stu-id="b4690-328">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="b4690-329">À partir de `object` et `dynamic` n’importe quel autre *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-329">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="b4690-330">À partir d’un *class_type* `S` aux *class_type* `T`, fourni `S` est une classe de base `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-330">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="b4690-331">À partir d’un *class_type* `S` aux *interface_type* `T`, fourni `S` n’est pas scellé et fourni `S` n’implémente pas `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-331">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="b4690-332">À partir d’un *interface_type* `S` aux *class_type* `T`, fourni `T` n’est pas scellé ou fourni `T` implémente `S`.</span><span class="sxs-lookup"><span data-stu-id="b4690-332">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="b4690-333">À partir d’un *interface_type* `S` aux *interface_type* `T`, fourni `S` n’est pas dérivé `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-333">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="b4690-334">À partir d’un *array_type* `S` avec un type d’élément `SE` à un *array_type* `T` avec un type d’élément `TE`, à condition que toutes les conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="b4690-334">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="b4690-335">`S` et `T` diffèrent uniquement par le type d’élément.</span><span class="sxs-lookup"><span data-stu-id="b4690-335">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="b4690-336">En d’autres termes, `S` et `T` ont le même nombre de dimensions.</span><span class="sxs-lookup"><span data-stu-id="b4690-336">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="b4690-337">Les deux `SE` et `TE` sont *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="b4690-337">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="b4690-338">Il existe une conversion de référence explicite à partir de `SE` à `TE`.</span><span class="sxs-lookup"><span data-stu-id="b4690-338">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="b4690-339">À partir de `System.Array` et les interfaces qu’il implémente à aucun *array_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-339">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="b4690-340">À partir d’un type de tableau unidimensionnel `S[]` à `System.Collections.Generic.IList<T>` et ses interfaces de base fournis qu’il existe une conversion de référence explicite à partir de `S` à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-340">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="b4690-341">À partir de `System.Collections.Generic.IList<S>` et sa base d’interfaces pour un type de tableau unidimensionnel `T[]`, à condition que qu’il existe une conversion de référence ou d’identité explicite à partir de `S` à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-341">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="b4690-342">À partir de `System.Delegate` et les interfaces qu’il implémente à aucun *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-342">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="b4690-343">À partir d’un type référence à un type référence `T` si elle a une conversion de référence explicite à un type référence `T0` et `T0` a une conversion d’identité `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-343">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="b4690-344">À partir d’un type référence à un type d’interface ou un délégué `T` si elle a une conversion de référence explicite à un type d’interface ou un délégué `T0` et `T0` est convertible en variance à `T` ou `T` est variance-convertible en `T0` ([la conversion de Variance](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="b4690-344">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="b4690-345">À partir de `D<S1...Sn>` à `D<T1...Tn>` où `D<X1...Xn>` est un type délégué générique, `D<S1...Sn>` n’est pas compatible avec ou identique à `D<T1...Tn>`et pour chaque paramètre de type `Xi` de `D` les blocages suivantes :</span><span class="sxs-lookup"><span data-stu-id="b4690-345">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="b4690-346">Si `Xi` est invariant, puis `Si` est identique à `Ti`.</span><span class="sxs-lookup"><span data-stu-id="b4690-346">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="b4690-347">Si `Xi` est covariant, il existe une conversion de référence ou d’identité implicite ou explicite de `Si` à `Ti`.</span><span class="sxs-lookup"><span data-stu-id="b4690-347">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="b4690-348">Si `Xi` est contravariant, puis `Si` et `Ti` sont identiques ou les deux types de référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-348">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="b4690-349">Conversions explicites impliquant des paramètres de type qui sont connus pour être des types référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-349">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="b4690-350">Pour plus d’informations sur les conversions explicites impliquant des paramètres de type, consultez [conversions explicites impliquant des paramètres de type](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="b4690-350">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="b4690-351">Les conversions de référence explicites sont les conversions entre des types référence qui nécessitent des vérifications à l’exécution pour vous assurer qu’ils sont corrects.</span><span class="sxs-lookup"><span data-stu-id="b4690-351">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="b4690-352">Pour une conversion de référence explicite réussisse au moment de l’exécution, la valeur de l’opérande source doit être `null`, ou le type réel de l’objet référencé par l’opérande source doit être un type qui peut être converti vers le type de destination par une référence implicite conversion ([conversions de référence implicite](conversions.md#implicit-reference-conversions)) ou une conversion boxing ([conversions Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-352">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="b4690-353">Si une conversion de référence explicite échoue, un `System.InvalidCastException` est levée.</span><span class="sxs-lookup"><span data-stu-id="b4690-353">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="b4690-354">Conversions de référence, implicites ou explicites, jamais changent l’identité référentielle de l’objet en cours de conversion.</span><span class="sxs-lookup"><span data-stu-id="b4690-354">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="b4690-355">En d’autres termes, si une conversion de référence peut modifier le type de la référence, il ne change jamais le type ou la valeur de l’objet fait référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-355">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="b4690-356">Conversions unboxing</span><span class="sxs-lookup"><span data-stu-id="b4690-356">Unboxing conversions</span></span>

<span data-ttu-id="b4690-357">Une conversion unboxing permet à un type référence pour être converti explicitement en un *value_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-357">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="b4690-358">Il existe une conversion unboxing à partir des types `object`, `dynamic` et `System.ValueType` aux *non_nullable_value_type*et à partir d’un *interface_type* aux *non_ nullable_value_type* qui implémente le *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-358">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="b4690-359">En outre tapez `System.Enum` peuvent être unboxed aux *type_de_liste*.</span><span class="sxs-lookup"><span data-stu-id="b4690-359">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="b4690-360">Il existe une conversion unboxing d’un type référence en un *nullable_type* s’il existe une conversion unboxing du type de référence en sous-jacent *non_nullable_value_type* de la  *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-360">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="b4690-361">Un type valeur `S` a une conversion unboxing d’un type interface `I` si elle a une conversion unboxing d’un type interface `I0` et `I0` a une conversion d’identité à `I`.</span><span class="sxs-lookup"><span data-stu-id="b4690-361">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="b4690-362">Un type valeur `S` a une conversion unboxing d’un type interface `I` si elle a une conversion unboxing à partir d’une interface ou un type délégué `I0` et `I0` est convertible en variance à `I` ou `I`est convertible en variance à `I0` ([la conversion de Variance](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="b4690-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="b4690-363">Une opération d’unboxing se compose de vérifier au préalable que l’instance d’objet est une valeur boxed de la donnée *value_type*, puis copiez la valeur en dehors de l’instance.</span><span class="sxs-lookup"><span data-stu-id="b4690-363">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="b4690-364">Unboxing d’une référence null à un *nullable_type* produit la valeur null de la *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-364">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="b4690-365">Un struct peut être unboxed à partir du type `System.ValueType`, puisque c’est une classe de base pour tous les structs ([héritage](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="b4690-365">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="b4690-366">Les conversions unboxing sont décrites dans [les conversions Unboxing](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="b4690-366">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="b4690-367">Conversions explicites dynamiques</span><span class="sxs-lookup"><span data-stu-id="b4690-367">Explicit dynamic conversions</span></span>

<span data-ttu-id="b4690-368">Il existe une conversion explicite de dynamique à partir d’une expression de type `dynamic` à n’importe quel type `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-368">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="b4690-369">La conversion est dynamiquement liée ([liaison dynamique](expressions.md#dynamic-binding)), ce qui signifie qu’une conversion explicite vous est demandée au moment de l’exécution à partir du type d’exécution de l’expression à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-369">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="b4690-370">Si aucune conversion n’est trouvée, une exception au moment de l’exécution est levée.</span><span class="sxs-lookup"><span data-stu-id="b4690-370">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="b4690-371">Si la liaison dynamique de la conversion n’est pas souhaitée, l’expression peut être convertie tout d’abord à `object`et ensuite vers le type souhaité.</span><span class="sxs-lookup"><span data-stu-id="b4690-371">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="b4690-372">Supposons que la classe suivante est définie :</span><span class="sxs-lookup"><span data-stu-id="b4690-372">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="b4690-373">L’exemple suivant illustre les conversions explicites dynamiques :</span><span class="sxs-lookup"><span data-stu-id="b4690-373">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="b4690-374">La meilleure conversion de `o` à `C` est trouvé à la compilation pour permettre une conversion de référence explicite.</span><span class="sxs-lookup"><span data-stu-id="b4690-374">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="b4690-375">Cette opération échoue au moment de l’exécution, car `"1"` n’est pas en fait un `C`.</span><span class="sxs-lookup"><span data-stu-id="b4690-375">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="b4690-376">La conversion de `d` à `C` Toutefois, comme une conversion explicite dynamique, est suspendue au moment de l’exécution, où un utilisateur défini la conversion du type d’exécution de `d`  --  `string` --à `C` est trouvée, et réussit.</span><span class="sxs-lookup"><span data-stu-id="b4690-376">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="b4690-377">Conversions explicites impliquant des paramètres de type</span><span class="sxs-lookup"><span data-stu-id="b4690-377">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="b4690-378">Les conversions explicites suivantes existent pour un paramètre de type donné `T`:</span><span class="sxs-lookup"><span data-stu-id="b4690-378">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="b4690-379">À partir de la classe de base efficace `C` de `T` à `T` et à partir de n’importe quelle classe de base de `C` à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-379">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="b4690-380">Au moment de l’exécution, if `T` est un type valeur, la conversion est exécutée comme une conversion unboxing.</span><span class="sxs-lookup"><span data-stu-id="b4690-380">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="b4690-381">Sinon, la conversion est exécutée en tant que conversion de référence explicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="b4690-381">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="b4690-382">À partir de n’importe quel type d’interface pour `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-382">From any interface type to `T`.</span></span> <span data-ttu-id="b4690-383">Au moment de l’exécution, if `T` est un type valeur, la conversion est exécutée comme une conversion unboxing.</span><span class="sxs-lookup"><span data-stu-id="b4690-383">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="b4690-384">Sinon, la conversion est exécutée en tant que conversion de référence explicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="b4690-384">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="b4690-385">À partir de `T` aux *interface_type* `I` fournie il n’est pas déjà une conversion implicite de `T` à `I`.</span><span class="sxs-lookup"><span data-stu-id="b4690-385">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="b4690-386">Au moment de l’exécution, if `T` est un type valeur, la conversion est exécutée comme une conversion boxing suivie d’une conversion de référence explicite.</span><span class="sxs-lookup"><span data-stu-id="b4690-386">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="b4690-387">Sinon, la conversion est exécutée en tant que conversion de référence explicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="b4690-387">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="b4690-388">À partir d’un paramètre de type `U` à `T`, fourni `T` dépend `U` ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="b4690-388">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="b4690-389">Au moment de l’exécution, if `U` est un type valeur, puis `T` et `U` sont nécessairement du même type et aucune conversion n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="b4690-389">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="b4690-390">Sinon, si `T` est un type valeur, la conversion est exécutée comme une conversion unboxing.</span><span class="sxs-lookup"><span data-stu-id="b4690-390">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="b4690-391">Sinon, la conversion est exécutée en tant que conversion de référence explicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="b4690-391">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="b4690-392">Si `T` est connu pour être un type référence, les conversions ci-dessus sont toutes classées comme des conversions de référence explicite ([conversions de référence explicite](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-392">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="b4690-393">Si `T` est ne pas connu pour être un type référence, les conversions ci-dessus sont classées comme des conversions unboxing ([les conversions Unboxing](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-393">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="b4690-394">Les règles ci-dessus ne permettent pas d’une conversion explicite directe à partir d’un paramètre de type sans contrainte à un type sans interface, ce qui peut être surprenant.</span><span class="sxs-lookup"><span data-stu-id="b4690-394">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="b4690-395">La raison de cette règle consiste à éviter toute confusion et rendre la sémantique de ces conversions clair.</span><span class="sxs-lookup"><span data-stu-id="b4690-395">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="b4690-396">Observez par exemple la déclaration suivante :</span><span class="sxs-lookup"><span data-stu-id="b4690-396">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="b4690-397">Si la conversion explicite directe de `t` à `int` étaient autorisées, on peut facilement s’attendre à qui `X<int>.F(7)` retournerait `7L`.</span><span class="sxs-lookup"><span data-stu-id="b4690-397">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="b4690-398">Toutefois, il le ferait pas, car les conversions numériques standard sont considérées comme uniquement lorsque les types sont connus comme étant numériques au moment de la liaison.</span><span class="sxs-lookup"><span data-stu-id="b4690-398">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="b4690-399">Afin de rendre la sémantique clair, l’exemple ci-dessus doit plutôt être écrit :</span><span class="sxs-lookup"><span data-stu-id="b4690-399">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="b4690-400">Ce code compilera maintenant en cours d’exécution mais `X<int>.F(7)` puis lève une exception au moment de l’exécution, depuis un boxed `int` ne peut pas être converti directement un `long`.</span><span class="sxs-lookup"><span data-stu-id="b4690-400">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="b4690-401">Conversions explicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="b4690-401">User-defined explicit conversions</span></span>

<span data-ttu-id="b4690-402">Une conversion explicite définie par l’utilisateur se compose d’une conversion explicite standard facultative, suivie de l’exécution d’un opérateur de conversion implicite ou explicite défini par l’utilisateur, suivie d’une autre conversion explicite standard facultative.</span><span class="sxs-lookup"><span data-stu-id="b4690-402">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="b4690-403">Les règles exactes d’évaluation des conversions explicites définies par l’utilisateur sont décrites dans [le traitement de conversions explicites définies par l’utilisateur](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="b4690-403">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="b4690-404">Conversions standard</span><span class="sxs-lookup"><span data-stu-id="b4690-404">Standard conversions</span></span>

<span data-ttu-id="b4690-405">Les conversions standard sont les conversions prédéfinies qui peuvent se produire dans le cadre d’une conversion définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b4690-405">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="b4690-406">Conversions implicites standards</span><span class="sxs-lookup"><span data-stu-id="b4690-406">Standard implicit conversions</span></span>

<span data-ttu-id="b4690-407">Les conversions implicites suivantes sont classées comme des conversions implicites standards :</span><span class="sxs-lookup"><span data-stu-id="b4690-407">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="b4690-408">Conversions d’identité ([conversion d’identité](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="b4690-408">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="b4690-409">Conversions numériques implicites ([conversions numériques implicites](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="b4690-409">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="b4690-410">Les conversions implicites nullables ([les conversions implicites nullables](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="b4690-410">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="b4690-411">Conversions de référence implicite ([conversions de référence implicite](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="b4690-411">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="b4690-412">Les conversions boxing ([conversions Boxing](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="b4690-412">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="b4690-413">Conversions d’expression constante implicites ([les conversions implicites dynamiques](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="b4690-413">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="b4690-414">Les conversions implicites impliquant des paramètres de type ([conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="b4690-414">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="b4690-415">Les conversions implicites standards exclure spécifiquement les conversions implicites définies par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b4690-415">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="b4690-416">Conversions explicites standards</span><span class="sxs-lookup"><span data-stu-id="b4690-416">Standard explicit conversions</span></span>

<span data-ttu-id="b4690-417">Les conversions explicites standard sont toutes les conversions implicites standards ainsi que le sous-ensemble des conversions explicites pour lequel il existe une conversion implicite standard opposée.</span><span class="sxs-lookup"><span data-stu-id="b4690-417">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="b4690-418">En d’autres termes, si une norme implicite conversion existe à partir d’un type `A` à un type `B`, puis il existe une conversion explicite standard du type `A` en type `B` et du type `B` au type `A`.</span><span class="sxs-lookup"><span data-stu-id="b4690-418">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="b4690-419">Conversions définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="b4690-419">User-defined conversions</span></span>

<span data-ttu-id="b4690-420">C# permet les conversions implicites et explicites prédéfinies être complété par ***conversions définies par l’utilisateur***.</span><span class="sxs-lookup"><span data-stu-id="b4690-420">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="b4690-421">Conversions définies par l’utilisateur sont introduites en déclarant des opérateurs de conversion ([les opérateurs de Conversion](classes.md#conversion-operators)) dans la classe et les types struct.</span><span class="sxs-lookup"><span data-stu-id="b4690-421">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="b4690-422">Autorisé des conversions définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="b4690-422">Permitted user-defined conversions</span></span>

<span data-ttu-id="b4690-423">C# autorise uniquement certaines conversions définies par l’utilisateur à être déclarés.</span><span class="sxs-lookup"><span data-stu-id="b4690-423">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="b4690-424">En particulier, il n’est pas possible de redéfinir une conversion implicite ou explicite déjà existante.</span><span class="sxs-lookup"><span data-stu-id="b4690-424">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="b4690-425">Pour un type de source donné `S` et type de cible `T`si `S` ou `T` sont des types nullables, permettent de `S0` et `T0` font référence à leurs types sous-jacents, sinon `S0` et `T0` sont égal à `S` et `T` respectivement.</span><span class="sxs-lookup"><span data-stu-id="b4690-425">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="b4690-426">Une classe ou un struct est autorisé à déclarer une conversion à partir d’un type de source `S` à un type de cible `T` uniquement si toutes les conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="b4690-426">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="b4690-427">`S0` et `T0` sont les différents types.</span><span class="sxs-lookup"><span data-stu-id="b4690-427">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="b4690-428">Soit `S0` ou `T0` est le type de classe ou struct dans lequel la déclaration d’opérateur a lieu.</span><span class="sxs-lookup"><span data-stu-id="b4690-428">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="b4690-429">Ni `S0` ni `T0` est un *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="b4690-429">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="b4690-430">À l’exception des conversions définies par l’utilisateur, une conversion n’existe pas de `S` à `T` ou à partir de `T` à `S`.</span><span class="sxs-lookup"><span data-stu-id="b4690-430">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="b4690-431">Les restrictions qui s’appliquent aux conversions définies par l’utilisateur sont décrites plus en détail dans [les opérateurs de Conversion](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="b4690-431">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="b4690-432">Opérateurs de conversion levé</span><span class="sxs-lookup"><span data-stu-id="b4690-432">Lifted conversion operators</span></span>

<span data-ttu-id="b4690-433">Étant donné un opérateur de conversion définie par l’utilisateur qui convertit un type valeur non nullable `S` à un type valeur non nullable `T`, un ***levé d’opérateur de conversion*** existe qui convertit à partir de `S?` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-433">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="b4690-434">Cet opérateur de conversion levé effectue un Désencapsulation à partir de `S?` à `S` suivie de la conversion définie par l’utilisateur à partir de `S` à `T` suivie d’un retour à la ligne à partir de `T` à `T?`, sauf qu’une valeur null valeurs `S?` convertit directement à une valeur null à valeur `T?`.</span><span class="sxs-lookup"><span data-stu-id="b4690-434">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="b4690-435">Un opérateur de conversion levé a le même classement implicite ou explicit en tant que son opérateur de conversion définie par l’utilisateur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="b4690-435">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="b4690-436">Le terme « conversion définie par l’utilisateur » s’applique à l’utilisation des deux défini par l’utilisateur et levée des opérateurs de conversion.</span><span class="sxs-lookup"><span data-stu-id="b4690-436">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="b4690-437">Évaluation des conversions définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="b4690-437">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="b4690-438">Une conversion définie par l’utilisateur convertit une valeur de son type, appelé le ***type de source***, à un autre type, appelé le ***type cible***.</span><span class="sxs-lookup"><span data-stu-id="b4690-438">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="b4690-439">Évaluation d’une conversion définie par l’utilisateur se concentre sur la recherche le ***plus spécifique*** opérateur de conversion définie par l’utilisateur pour les types source et cible particuliers.</span><span class="sxs-lookup"><span data-stu-id="b4690-439">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="b4690-440">Cette détermination est divisée en plusieurs étapes :</span><span class="sxs-lookup"><span data-stu-id="b4690-440">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="b4690-441">Recherche de l’ensemble des classes et des structs qui seront considérée comme des opérateurs de conversion définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="b4690-441">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="b4690-442">Cet ensemble comprend le type de source et de ses classes de base et le type de cible et ses classes de base (avec les hypothèses implicites que seules les classes et structs peuvent déclarer des opérateurs définis par l’utilisateur, et ne qu’aucune classe de base sur les types sans classe).</span><span class="sxs-lookup"><span data-stu-id="b4690-442">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="b4690-443">Dans le cadre de cette étape, si le type de source ou cible est un *nullable_type*, leur type sous-jacent est utilisé à la place.</span><span class="sxs-lookup"><span data-stu-id="b4690-443">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="b4690-444">À partir de cet ensemble de types, la détermination de qui défini par l’utilisateur et levée des opérateurs de conversion sont applicables.</span><span class="sxs-lookup"><span data-stu-id="b4690-444">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="b4690-445">Pour un opérateur de conversion soit applicable, il doit être possible d’effectuer une conversion standard ([conversions Standard](conversions.md#standard-conversions)) à partir du type de source à l’opérande de type de l’opérateur et il doit être possible d’effectuer une conversion standard à partir du type de résultat de l’opérateur vers le type cible.</span><span class="sxs-lookup"><span data-stu-id="b4690-445">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="b4690-446">À partir de l’ensemble des opérateurs définis par l’utilisateur applicables, déterminer quel opérateur est sans ambiguïté le plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="b4690-446">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="b4690-447">En règle générale, l’opérateur plus spécifique est l’opérateur dont le type d’opérande est « plus proche » pour le type de source et dont le type de résultat est « plus proche » en type cible.</span><span class="sxs-lookup"><span data-stu-id="b4690-447">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="b4690-448">Opérateurs de conversion définie par l’utilisateur sont préférés aux opérateurs de conversion levé.</span><span class="sxs-lookup"><span data-stu-id="b4690-448">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="b4690-449">Les règles exactes pour l’établissement de l’opérateur de conversion définie par l’utilisateur plus spécifique sont définies dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="b4690-449">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="b4690-450">Une fois qu’un opérateur de conversion définie par l’utilisateur plus spécifique a été identifié, l’exécution réelle de la conversion définie par l’utilisateur implique trois étapes :</span><span class="sxs-lookup"><span data-stu-id="b4690-450">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="b4690-451">Tout d’abord, si nécessaire, effectuer une conversion standard du type source vers le type d’opérande de l’opérateur de conversion défini par l’utilisateur ou levé.</span><span class="sxs-lookup"><span data-stu-id="b4690-451">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="b4690-452">Ensuite, l’appel de l’opérateur de conversion défini par l’utilisateur ou levé pour effectuer la conversion.</span><span class="sxs-lookup"><span data-stu-id="b4690-452">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="b4690-453">Enfin, si nécessaire, effectuer une conversion standard du type de résultat de l’opérateur de conversion défini par l’utilisateur ou levé vers le type cible.</span><span class="sxs-lookup"><span data-stu-id="b4690-453">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="b4690-454">Évaluation d’une conversion définie par l’utilisateur jamais implique plusieurs opérateurs de conversion définie par l’utilisateur ou levé.</span><span class="sxs-lookup"><span data-stu-id="b4690-454">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="b4690-455">En d’autres termes, une conversion de type `S` à taper `T` jamais commence par exécuter une conversion définie par l’utilisateur à partir de `S` à `X` , puis exécutez une conversion définie par l’utilisateur à partir de `X` à `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-455">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="b4690-456">Les définitions exactes d’évaluation des conversions implicites ou explicites définies par l’utilisateur sont données dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="b4690-456">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="b4690-457">Les définitions utilisent les termes suivants :</span><span class="sxs-lookup"><span data-stu-id="b4690-457">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="b4690-458">Si une conversion implicite standard ([conversions implicites Standard](conversions.md#standard-implicit-conversions)) existe à partir d’un type `A` à un type `B`et si ni `A` ni `B` sont *interface_type*s, puis `A` est dite ***englobé par*** `B`, et `B` est dite ***englober*** `A`.</span><span class="sxs-lookup"><span data-stu-id="b4690-458">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="b4690-459">Le ***type le plus englobant*** dans un ensemble de types est celui qui englobe tous les autres types dans le jeu.</span><span class="sxs-lookup"><span data-stu-id="b4690-459">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="b4690-460">Si aucun type individuel n’englobe tous les autres types, le jeu n’a aucun type le plus englobant.</span><span class="sxs-lookup"><span data-stu-id="b4690-460">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="b4690-461">En termes plus intuitives, le type le plus englobant est le « plus grand » type dans le jeu, le type auquel chacun des autres types peut être converti implicitement.</span><span class="sxs-lookup"><span data-stu-id="b4690-461">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="b4690-462">Le ***type le plus englobé*** dans un ensemble de types est celui qui est englobé par tous les autres types dans le jeu.</span><span class="sxs-lookup"><span data-stu-id="b4690-462">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="b4690-463">Si aucun type unique n’est englobé par tous les autres types, puis le jeu a ne type le plus englobé.</span><span class="sxs-lookup"><span data-stu-id="b4690-463">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="b4690-464">En termes plus intuitives, le type le plus englobé est le « plus petit » type dans le jeu, le type qui peut être converti implicitement à chacun des autres types.</span><span class="sxs-lookup"><span data-stu-id="b4690-464">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="b4690-465">Traitement des conversions implicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="b4690-465">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="b4690-466">Une conversion implicite défini par l’utilisateur à partir du type `S` à taper `T` est traité comme suit :</span><span class="sxs-lookup"><span data-stu-id="b4690-466">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="b4690-467">Déterminer les types `S0` et `T0`.</span><span class="sxs-lookup"><span data-stu-id="b4690-467">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="b4690-468">Si `S` ou `T` sont des types nullables, `S0` et `T0` sont leurs types sous-jacents, sinon `S0` et `T0` sont égaux à `S` et `T` respectivement.</span><span class="sxs-lookup"><span data-stu-id="b4690-468">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="b4690-469">Trouver l’ensemble de types, `D`, à partir de la conversion définie par l’utilisateur sont considérés comme opérateurs.</span><span class="sxs-lookup"><span data-stu-id="b4690-469">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="b4690-470">Ce groupe se compose de `S0` (si `S0` est une classe ou struct), les classes de base de `S0` (si `S0` est une classe), et `T0` (si `T0` est une classe ou struct).</span><span class="sxs-lookup"><span data-stu-id="b4690-470">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="b4690-471">Rechercher l’ensemble des opérateurs de conversion définie par l’utilisateur et levé applicable, `U`.</span><span class="sxs-lookup"><span data-stu-id="b4690-471">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="b4690-472">Ce groupe se compose des opérateurs de conversion implicite défini par l’utilisateur et levé déclarés par les classes ou les structs dans `D` qui convertir à partir d’un type englobant `S` à un type englobé par `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-472">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="b4690-473">Si `U` est vide, la conversion n’est pas définie et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-473">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-474">Rechercher le type de source plus spécifique, `SX`, des opérateurs dans `U`:</span><span class="sxs-lookup"><span data-stu-id="b4690-474">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="b4690-475">Si un des opérateurs dans `U` convertir à partir de `S`, puis `SX` est `S`.</span><span class="sxs-lookup"><span data-stu-id="b4690-475">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="b4690-476">Sinon, `SX` est le type le plus englobé dans l’ensemble combiné des types source des opérateurs dans `U`.</span><span class="sxs-lookup"><span data-stu-id="b4690-476">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="b4690-477">Si seul le plus englobé type ne peut pas être trouvé, puis la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-477">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-478">Rechercher le type de cible plus spécifique, `TX`, des opérateurs dans `U`:</span><span class="sxs-lookup"><span data-stu-id="b4690-478">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="b4690-479">Si un des opérateurs dans `U` convertir `T`, puis `TX` est `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-479">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="b4690-480">Sinon, `TX` est le type le plus englobant dans l’ensemble combiné des types cible des opérateurs dans `U`.</span><span class="sxs-lookup"><span data-stu-id="b4690-480">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="b4690-481">Si exactement un type plus englobant ne peut pas être trouvé, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-481">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-482">Rechercher l’opérateur de conversion plus spécifique :</span><span class="sxs-lookup"><span data-stu-id="b4690-482">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="b4690-483">Si `U` contient exactement un opérateur de conversion définie par l’utilisateur qui effectue la conversion à partir de `SX` à `TX`, il s’agit de l’opérateur de conversion plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="b4690-483">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="b4690-484">Sinon, si `U` contient exactement un opérateur de conversion levé convertit à partir de `SX` à `TX`, il s’agit de l’opérateur de conversion plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="b4690-484">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="b4690-485">Sinon, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-485">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-486">Enfin, appliquez la conversion :</span><span class="sxs-lookup"><span data-stu-id="b4690-486">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="b4690-487">Si `S` n’est pas `SX`, puis une conversion implicite standard de `S` à `SX` est effectuée.</span><span class="sxs-lookup"><span data-stu-id="b4690-487">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="b4690-488">L’opérateur de conversion plus spécifique est appelée pour convertir à partir de `SX` à `TX`.</span><span class="sxs-lookup"><span data-stu-id="b4690-488">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="b4690-489">Si `TX` n’est pas `T`, puis une conversion implicite standard de `TX` à `T` est effectuée.</span><span class="sxs-lookup"><span data-stu-id="b4690-489">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="b4690-490">Traitement des conversions explicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="b4690-490">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="b4690-491">Une conversion explicite définie par l’utilisateur à partir du type `S` à taper `T` est traité comme suit :</span><span class="sxs-lookup"><span data-stu-id="b4690-491">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="b4690-492">Déterminer les types `S0` et `T0`.</span><span class="sxs-lookup"><span data-stu-id="b4690-492">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="b4690-493">Si `S` ou `T` sont des types nullables, `S0` et `T0` sont leurs types sous-jacents, sinon `S0` et `T0` sont égaux à `S` et `T` respectivement.</span><span class="sxs-lookup"><span data-stu-id="b4690-493">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="b4690-494">Trouver l’ensemble de types, `D`, à partir de la conversion définie par l’utilisateur sont considérés comme opérateurs.</span><span class="sxs-lookup"><span data-stu-id="b4690-494">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="b4690-495">Ce groupe se compose de `S0` (si `S0` est une classe ou struct), les classes de base de `S0` (si `S0` est une classe), `T0` (si `T0` est une classe ou struct) et les classes de base de `T0` (si `T0`est une classe).</span><span class="sxs-lookup"><span data-stu-id="b4690-495">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="b4690-496">Rechercher l’ensemble des opérateurs de conversion définie par l’utilisateur et levé applicable, `U`.</span><span class="sxs-lookup"><span data-stu-id="b4690-496">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="b4690-497">Cet ensemble comprend les défini par l’utilisateur et levé implicite ou opérateurs de conversion explicite déclarés par les classes ou les structs dans `D` qui convertir à partir d’un type englobant ou englobé par `S` à un type englobant ou englobé par `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-497">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="b4690-498">Si `U` est vide, la conversion n’est pas définie et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-498">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-499">Rechercher le type de source plus spécifique, `SX`, des opérateurs dans `U`:</span><span class="sxs-lookup"><span data-stu-id="b4690-499">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="b4690-500">Si un des opérateurs dans `U` convertir à partir de `S`, puis `SX` est `S`.</span><span class="sxs-lookup"><span data-stu-id="b4690-500">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="b4690-501">Sinon, si un des opérateurs dans `U` convertir à partir de types qui englobent `S`, puis `SX` est le type le plus englobé dans l’ensemble combiné des types de source de ces opérateurs.</span><span class="sxs-lookup"><span data-stu-id="b4690-501">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="b4690-502">Si aucun la plupart n’englobé type peut être trouvé, puis la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-502">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="b4690-503">Sinon, `SX` est le type le plus englobant dans l’ensemble combiné des types source des opérateurs dans `U`.</span><span class="sxs-lookup"><span data-stu-id="b4690-503">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="b4690-504">Si exactement un type plus englobant ne peut pas être trouvé, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-504">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-505">Rechercher le type de cible plus spécifique, `TX`, des opérateurs dans `U`:</span><span class="sxs-lookup"><span data-stu-id="b4690-505">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="b4690-506">Si un des opérateurs dans `U` convertir `T`, puis `TX` est `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-506">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="b4690-507">Sinon, si un des opérateurs dans `U` convertir des types qui sont comprises dans la bibliothèque `T`, puis `TX` est le type le plus englobant dans l’ensemble combiné des types de cible de ces opérateurs.</span><span class="sxs-lookup"><span data-stu-id="b4690-507">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="b4690-508">Si exactement un type plus englobant ne peut pas être trouvé, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-508">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="b4690-509">Sinon, `TX` est le type le plus englobé dans l’ensemble combiné des types cible des opérateurs dans `U`.</span><span class="sxs-lookup"><span data-stu-id="b4690-509">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="b4690-510">Si aucun la plupart n’englobé type peut être trouvé, puis la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-510">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-511">Rechercher l’opérateur de conversion plus spécifique :</span><span class="sxs-lookup"><span data-stu-id="b4690-511">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="b4690-512">Si `U` contient exactement un opérateur de conversion définie par l’utilisateur qui effectue la conversion à partir de `SX` à `TX`, il s’agit de l’opérateur de conversion plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="b4690-512">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="b4690-513">Sinon, si `U` contient exactement un opérateur de conversion levé convertit à partir de `SX` à `TX`, il s’agit de l’opérateur de conversion plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="b4690-513">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="b4690-514">Sinon, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-514">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-515">Enfin, appliquez la conversion :</span><span class="sxs-lookup"><span data-stu-id="b4690-515">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="b4690-516">Si `S` n’est pas `SX`, puis une conversion explicite standard de `S` à `SX` est effectuée.</span><span class="sxs-lookup"><span data-stu-id="b4690-516">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="b4690-517">Opérateur de conversion définie par l’utilisateur le plus spécifique est appelée pour convertir à partir de `SX` à `TX`.</span><span class="sxs-lookup"><span data-stu-id="b4690-517">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="b4690-518">Si `TX` n’est pas `T`, puis une conversion explicite standard de `TX` à `T` est effectuée.</span><span class="sxs-lookup"><span data-stu-id="b4690-518">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="b4690-519">Conversions de fonctions anonymes</span><span class="sxs-lookup"><span data-stu-id="b4690-519">Anonymous function conversions</span></span>

<span data-ttu-id="b4690-520">Un *anonymous_method_expression* ou *lambda_expression* est classé comme une fonction anonyme ([expressions de fonction anonyme](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-520">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="b4690-521">L’expression n’a pas un type, mais peut être implicitement convertie en type de délégué compatible ou type arborescence d’expression.</span><span class="sxs-lookup"><span data-stu-id="b4690-521">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="b4690-522">Plus précisément, une fonction anonyme `F` est compatible avec un type délégué `D` fourni :</span><span class="sxs-lookup"><span data-stu-id="b4690-522">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="b4690-523">Si `F` contient un *anonymous_function_signature*, puis `D` et `F` ont le même nombre de paramètres.</span><span class="sxs-lookup"><span data-stu-id="b4690-523">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="b4690-524">Si `F` ne contient pas une *anonymous_function_signature*, puis `D` peut avoir zéro ou plusieurs paramètres de type quelconque, à condition qu’aucun paramètre de `D` a le `out` modificateur de paramètre.</span><span class="sxs-lookup"><span data-stu-id="b4690-524">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="b4690-525">Si `F` possède une liste de paramètres explicitement typée, chaque paramètre dans `D` a le même type et modificateurs que le paramètre correspondant dans `F`.</span><span class="sxs-lookup"><span data-stu-id="b4690-525">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="b4690-526">Si `F` possède une liste de paramètres implicitement typé, `D` n’a aucun `ref` ou `out` paramètres.</span><span class="sxs-lookup"><span data-stu-id="b4690-526">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="b4690-527">Si le corps de `F` est une expression et soit `D` a un `void` type de retour ou `F` est asynchrone et `D` a le type de retour `Task`, lorsque chaque paramètre de `F` est fonction du type de la paramètre correspondant dans `D`, le corps de `F` est une expression valide (wrt [Expressions](expressions.md)) qui serait autorisée en tant qu’un *statement_expression* ([Instructions d’expression](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="b4690-527">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="b4690-528">Si le corps de `F` est un bloc d’instructions et soit `D` a un `void` type de retour ou `F` est asynchrone et `D` a le type de retour `Task`, lorsque chaque paramètre de `F` est fonction du type de le paramètre correspondant dans `D`, le corps de `F` est un bloc d’instructions valides (wrt [blocs](statements.md#blocks)) dans lesquels aucun `return` instruction spécifie une expression.</span><span class="sxs-lookup"><span data-stu-id="b4690-528">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="b4690-529">Si le corps de `F` est une expression, et *soit* `F` est non asynchrone et `D` a un type de retour non void `T`, *ou* `F` est asynchrone et `D` a un type de retour `Task<T>`, lorsque chaque paramètre de `F` reçoit le type du paramètre correspondant dans `D`, le corps de `F` est une expression valide (wrt [ Expressions](expressions.md)) qui est implicitement convertible en `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-529">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="b4690-530">Si le corps de `F` est un bloc d’instructions, et *soit* `F` est non asynchrone et `D` a un type de retour non void `T`, *ou* `F` est asynchrone et `D` a un type de retour `Task<T>`, lorsque chaque paramètre de `F` reçoit le type du paramètre correspondant dans `D`, le corps de `F` est un bloc d’instructions valides (wrt [blocs ](statements.md#blocks)) avec un point de terminaison non accessible dans lequel chaque `return` instruction spécifie une expression qui est implicitement convertible en `T`.</span><span class="sxs-lookup"><span data-stu-id="b4690-530">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="b4690-531">À des fins de concision, cette section utilise la forme abrégée pour les types de tâches `Task` et `Task<T>` ([fonctions Async](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="b4690-531">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="b4690-532">Une expression lambda `F` est compatible avec un type d’arborescence expression `Expression<D>` si `F` est compatible avec le type de délégué `D`.</span><span class="sxs-lookup"><span data-stu-id="b4690-532">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="b4690-533">Notez que cela ne s’applique pas aux méthodes anonymes, seules les expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="b4690-533">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="b4690-534">Certaines expressions lambda ne peut pas être convertis en types d’arborescence d’expression : même si la conversion *existe*, elle échoue au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="b4690-534">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="b4690-535">Cela est le cas si l’expression lambda :</span><span class="sxs-lookup"><span data-stu-id="b4690-535">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="b4690-536">A un *bloc* corps</span><span class="sxs-lookup"><span data-stu-id="b4690-536">Has a *block* body</span></span>
*  <span data-ttu-id="b4690-537">Contient les opérateurs d’assignation simple ou composite</span><span class="sxs-lookup"><span data-stu-id="b4690-537">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="b4690-538">Contient une expression liée dynamiquement</span><span class="sxs-lookup"><span data-stu-id="b4690-538">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="b4690-539">Est asynchrone</span><span class="sxs-lookup"><span data-stu-id="b4690-539">Is async</span></span>

<span data-ttu-id="b4690-540">Les exemples qui suivent utilisent un type délégué générique `Func<A,R>` qui représente une fonction qui accepte un argument de type `A` et retourne une valeur de type `R`:</span><span class="sxs-lookup"><span data-stu-id="b4690-540">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="b4690-541">Dans les affectations</span><span class="sxs-lookup"><span data-stu-id="b4690-541">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="b4690-542">les types de paramètre et de retour de chaque fonction anonyme sont déterminés à partir du type de la variable à laquelle la fonction anonyme est affectée.</span><span class="sxs-lookup"><span data-stu-id="b4690-542">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="b4690-543">La première assignation convertit correctement la fonction anonyme pour le type de délégué `Func<int,int>` car, lorsque `x` est de type donné `int`, `x+1` est une expression valide qui est implicitement convertible en type `int`.</span><span class="sxs-lookup"><span data-stu-id="b4690-543">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="b4690-544">De même, la deuxième assignation convertit correctement la fonction anonyme pour le type de délégué `Func<int,double>` , car le résultat de `x+1` (de type `int`) est implicitement convertible en type `double`.</span><span class="sxs-lookup"><span data-stu-id="b4690-544">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="b4690-545">Toutefois, l’attribution de tiers est une erreur de compilation car, lorsque `x` est de type donné `double`, le résultat de `x+1` (de type `double`) n’est pas implicitement convertible en type `int`.</span><span class="sxs-lookup"><span data-stu-id="b4690-545">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="b4690-546">L’attribution de quatrième convertit correctement la fonction anonyme async pour le type de délégué `Func<int, Task<int>>` , car le résultat de `x+1` (de type `int`) est implicitement convertible en type de résultat `int` du type de tâche `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="b4690-546">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="b4690-547">Fonctions anonymes peuvent influencer la résolution de surcharge et participer à l’inférence de type.</span><span class="sxs-lookup"><span data-stu-id="b4690-547">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="b4690-548">Consultez [membres de fonction](expressions.md#function-members) pour plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="b4690-548">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="b4690-549">Évaluation des conversions de fonction anonyme pour les types délégués</span><span class="sxs-lookup"><span data-stu-id="b4690-549">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="b4690-550">Conversion d’une fonction anonyme en un type délégué génère une instance de délégué qui fait référence à la fonction anonyme et l’ensemble (éventuellement vide) de variables capturées externes qui sont actives au moment de l’évaluation.</span><span class="sxs-lookup"><span data-stu-id="b4690-550">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="b4690-551">Lorsque le délégué est appelé, le corps de la fonction anonyme est exécuté.</span><span class="sxs-lookup"><span data-stu-id="b4690-551">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="b4690-552">Le code dans le corps est exécuté à l’aide de l’ensemble de variables capturées d’externes référencée par le délégué.</span><span class="sxs-lookup"><span data-stu-id="b4690-552">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="b4690-553">La liste d’appel d’un délégué généré à partir d’une fonction anonyme contient une seule entrée.</span><span class="sxs-lookup"><span data-stu-id="b4690-553">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="b4690-554">L’objet cible exacte et la méthode cible du délégué ne sont pas spécifiés.</span><span class="sxs-lookup"><span data-stu-id="b4690-554">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="b4690-555">En particulier, il n’est pas spécifié si l’objet cible du délégué est `null`, le `this` valeur de la fonction membre englobante, ou un autre objet.</span><span class="sxs-lookup"><span data-stu-id="b4690-555">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="b4690-556">Les conversions de fonctions anonymes sémantiquement identiques avec un même ensemble d’instances de variable externes capturées (éventuellement vide) pour les mêmes types de délégué sont autorisées (mais pas obligatoires) pour retourner la même instance de délégué.</span><span class="sxs-lookup"><span data-stu-id="b4690-556">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="b4690-557">Le terme sémantiquement identique est utilisé ici pour signifier que l’exécution des fonctions anonymes, dans tous les cas, génère les mêmes effets étant données les mêmes arguments.</span><span class="sxs-lookup"><span data-stu-id="b4690-557">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="b4690-558">Cette règle autorise le code suivant à optimiser.</span><span class="sxs-lookup"><span data-stu-id="b4690-558">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="b4690-559">Étant donné que les deux délégués de fonction anonyme ont les mêmes (vide) de variables externes capturées, étant donné que les fonctions anonymes sont sémantiquement identiques, le compilateur peut avoir les délégués font référence à la même méthode cible.</span><span class="sxs-lookup"><span data-stu-id="b4690-559">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="b4690-560">En effet, le compilateur est autorisé à renvoyer la même instance de délégué à partir de deux expressions de fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="b4690-560">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="b4690-561">Évaluation des conversions de fonction anonyme pour les types arborescence d’expression</span><span class="sxs-lookup"><span data-stu-id="b4690-561">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="b4690-562">Conversion d’une fonction anonyme en un type d’arborescence expression génère une arborescence d’expressions ([types arborescence d’Expression](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="b4690-562">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="b4690-563">Plus précisément, la version d’évaluation de la conversion d’une fonction anonyme entraîne la construction d’une structure d’objet qui représente la structure de la fonction anonyme elle-même.</span><span class="sxs-lookup"><span data-stu-id="b4690-563">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="b4690-564">La structure précise de l’arborescence d’expression, ainsi que le processus exact pour sa création, sont définie par l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="b4690-564">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="b4690-565">Exemple d’implémentation</span><span class="sxs-lookup"><span data-stu-id="b4690-565">Implementation example</span></span>

<span data-ttu-id="b4690-566">Cette section décrit une implémentation possible de conversions de fonction anonyme en termes d’autres constructions c#.</span><span class="sxs-lookup"><span data-stu-id="b4690-566">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="b4690-567">L’implémentation décrite ici est basée sur les mêmes principes que celui utilisés par le compilateur Microsoft c#, mais il n’est pas une implémentation autorisée, ni de la possible qu’une seule.</span><span class="sxs-lookup"><span data-stu-id="b4690-567">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="b4690-568">Elle mentionne brièvement les conversions en arborescences d’expression, comme leur sémantique exacte est en dehors de l’étendue de cette spécification.</span><span class="sxs-lookup"><span data-stu-id="b4690-568">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="b4690-569">Le reste de cette section fournit plusieurs exemples de code qui contient les fonctions anonymes présentant des caractéristiques différentes.</span><span class="sxs-lookup"><span data-stu-id="b4690-569">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="b4690-570">Pour chaque exemple, une traduction correspondante au code qui utilise uniquement autres constructions c# est fournie.</span><span class="sxs-lookup"><span data-stu-id="b4690-570">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="b4690-571">Dans les exemples, l’identificateur `D` est supposé par représentent le type délégué suivant :</span><span class="sxs-lookup"><span data-stu-id="b4690-571">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="b4690-572">La forme la plus simple d’une fonction anonyme est celle qui ne capture aucune variable externe :</span><span class="sxs-lookup"><span data-stu-id="b4690-572">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="b4690-573">Cela peut être traduit en une instanciation de délégué qui fait référence à une méthode statique générée par le compilateur dans lequel est placé le code de la fonction anonyme :</span><span class="sxs-lookup"><span data-stu-id="b4690-573">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="b4690-574">Dans l’exemple suivant, la fonction anonyme fait référence à des membres d’instance `this`:</span><span class="sxs-lookup"><span data-stu-id="b4690-574">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="b4690-575">Cela peut être traduit en une méthode d’instance généré par le compilateur qui contient le code de la fonction anonyme :</span><span class="sxs-lookup"><span data-stu-id="b4690-575">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="b4690-576">Dans cet exemple, la fonction anonyme capture une variable locale :</span><span class="sxs-lookup"><span data-stu-id="b4690-576">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="b4690-577">La durée de vie de la variable locale doit maintenant être étendue au moins la durée de vie du délégué de fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="b4690-577">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="b4690-578">Cela est possible en « levée » de la variable locale dans un champ d’une classe générée par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="b4690-578">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="b4690-579">Instanciation de la variable locale ([instanciation des variables locales](expressions.md#instantiation-of-local-variables)) qui correspond à la création d’une instance de la classe générée par le compilateur et l’accès à la variable locale correspond à l’accès à un champ dans l’instance de la classe générée par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="b4690-579">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="b4690-580">En outre, la fonction anonyme devient une méthode d’instance de la classe générée par le compilateur :</span><span class="sxs-lookup"><span data-stu-id="b4690-580">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="b4690-581">Enfin, les anonymes de fonctions suivants captures `this` , ainsi que deux variables locales avec différentes durées de vie :</span><span class="sxs-lookup"><span data-stu-id="b4690-581">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="b4690-582">Ici, une classe générée par le compilateur est créée pour chaque instruction bloquer dans les variables locales sont capturées telles que les variables locales dans les blocs différents peuvent avoir des durées de vie indépendantes.</span><span class="sxs-lookup"><span data-stu-id="b4690-582">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="b4690-583">Une instance de `__Locals2`, la classe générée par le compilateur pour le bloc d’instruction interne, contient la variable locale `z` et un champ qui fait référence à une instance de `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="b4690-583">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="b4690-584">Une instance de `__Locals1`, la classe générée par le compilateur pour le bloc d’instruction externe, contient la variable locale `y` et un champ qui fait référence à `this` du membre de fonction englobante.</span><span class="sxs-lookup"><span data-stu-id="b4690-584">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="b4690-585">Ces structures de données qu’il est possible d’atteindre tous les capturés variables externes via une instance de `__Local2`, et le code de la fonction anonyme peut par conséquent être implémenté comme une méthode d’instance de cette classe.</span><span class="sxs-lookup"><span data-stu-id="b4690-585">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="b4690-586">La même technique appliquée ici pour capturer les variables locales permettre également servir lors de la conversion des fonctions anonymes arborescences d’expression : références aux objets générés par le compilateur peuvent être stockés dans l’arborescence d’expression, et l’accès aux variables locales peut être représentée comme champ accède à ces objets.</span><span class="sxs-lookup"><span data-stu-id="b4690-586">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="b4690-587">L’avantage de cette approche est qu’elle autorise les variables locales « levés » être partagés entre les délégués et les arborescences d’expression.</span><span class="sxs-lookup"><span data-stu-id="b4690-587">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="b4690-588">Conversions de groupe (méthode)</span><span class="sxs-lookup"><span data-stu-id="b4690-588">Method group conversions</span></span>

<span data-ttu-id="b4690-589">Une conversion implicite ([conversions implicites](conversions.md#implicit-conversions)) existe à partir d’un groupe de méthodes ([classifications des expressions](expressions.md#expression-classifications)) à un type délégué compatible.</span><span class="sxs-lookup"><span data-stu-id="b4690-589">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="b4690-590">Étant donné un type délégué `D` et une expression `E` qui est classé comme un groupe de méthodes, il existe une conversion implicite à partir de `E` à `D` si `E` contient au moins une méthode qui n’est applicable dans sa forme normale () [Membre de fonction applicable](expressions.md#applicable-function-member)) à une liste d’arguments construit en utilisant des types de paramètres et des modificateurs de `D`, comme décrit dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="b4690-590">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="b4690-591">L’application de la compilation d’une conversion à partir d’un groupe de méthodes `E` à un type délégué `D` est décrite dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="b4690-591">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="b4690-592">Notez que l’existence d’une conversion implicite de `E` à `D` ne garantit pas que l’application lors de la compilation de la conversion réussit sans erreur.</span><span class="sxs-lookup"><span data-stu-id="b4690-592">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="b4690-593">Une seule méthode `M` est sélectionnée correspondant à un appel de méthode ([appels de méthode](expressions.md#method-invocations)) sous la forme `E(A)`, avec les modifications suivantes :</span><span class="sxs-lookup"><span data-stu-id="b4690-593">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="b4690-594">La liste d’arguments `A` est une liste d’expressions, chaque classifiées en tant que variable et avec le type et le modificateur (`ref` ou `out`) du paramètre correspondant dans le *formal_parameter_list* de `D`.</span><span class="sxs-lookup"><span data-stu-id="b4690-594">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="b4690-595">Les méthodes de candidat considéré comme sont uniquement les méthodes qui sont applicables dans leur forme normale ([membre de fonction Applicable](expressions.md#applicable-function-member)), pas celles applicables uniquement dans leur forme étendue.</span><span class="sxs-lookup"><span data-stu-id="b4690-595">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="b4690-596">Si l’algorithme de [appels de méthode](expressions.md#method-invocations) génère une erreur, une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-596">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="b4690-597">Sinon, l’algorithme produit une meilleure méthode unique `M` ayant le même nombre de paramètres en tant que `D` et la conversion est considéré comme existant.</span><span class="sxs-lookup"><span data-stu-id="b4690-597">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="b4690-598">La méthode sélectionnée `M` doivent être compatibles ([compatibilité des délégués](delegates.md#delegate-compatibility)) avec le type de délégué `D`, ou dans le cas contraire, une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="b4690-598">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="b4690-599">Si la méthode sélectionnée `M` est une méthode d’instance, l’expression d’instance associée `E` détermine l’objet cible du délégué.</span><span class="sxs-lookup"><span data-stu-id="b4690-599">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="b4690-600">Si la méthode sélectionnée M est une méthode d’extension qui est indiquée au moyen d’un accès aux membres sur une expression d’instance, cette expression d’instance détermine l’objet cible du délégué.</span><span class="sxs-lookup"><span data-stu-id="b4690-600">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="b4690-601">Le résultat de la conversion est une valeur de type `D`, à savoir un délégué nouvellement créé qui fait référence à l’objet de méthode et la cible sélectionnée.</span><span class="sxs-lookup"><span data-stu-id="b4690-601">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="b4690-602">Notez que ce processus peut entraîner la création d’un délégué à une méthode d’extension, si l’algorithme de [appels de méthode](expressions.md#method-invocations) ne parvient pas à trouver une méthode d’instance mais réussit lors du traitement de l’appel de `E(A)` en tant qu’extension appel de méthode ([appels de méthode d’Extension](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="b4690-602">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="b4690-603">Un délégué créé par conséquent capture la méthode d’extension, ainsi que son premier argument.</span><span class="sxs-lookup"><span data-stu-id="b4690-603">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="b4690-604">L’exemple suivant montre les conversions de groupes de méthode :</span><span class="sxs-lookup"><span data-stu-id="b4690-604">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="b4690-605">L’assignation à `d1` convertit implicitement le groupe de méthodes `F` à une valeur de type `D1`.</span><span class="sxs-lookup"><span data-stu-id="b4690-605">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="b4690-606">L’assignation à `d2` montre comment il est possible de créer un délégué à une méthode qui a moins dérivés des types de paramètres de (contra-variants) et une plus dérivés (covariant) type de retour.</span><span class="sxs-lookup"><span data-stu-id="b4690-606">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contra-variant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="b4690-607">L’assignation à `d3` montre comment n’existe aucune conversion si la méthode n’est pas applicable.</span><span class="sxs-lookup"><span data-stu-id="b4690-607">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="b4690-608">L’assignation à `d4` montre comment la méthode doit être applicable dans sa forme normale.</span><span class="sxs-lookup"><span data-stu-id="b4690-608">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="b4690-609">L’assignation à `d5` montre comment les types de paramètre et de retour du délégué et la méthode sont autorisés à différer uniquement pour les types référence.</span><span class="sxs-lookup"><span data-stu-id="b4690-609">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="b4690-610">Comme avec toutes les autres conversions implicites et explicites, l’opérateur de conversion peut être utilisé pour effectuer explicitement une conversion de groupe de méthode.</span><span class="sxs-lookup"><span data-stu-id="b4690-610">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="b4690-611">Par conséquent, l’exemple</span><span class="sxs-lookup"><span data-stu-id="b4690-611">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="b4690-612">au lieu de cela peut être écrit</span><span class="sxs-lookup"><span data-stu-id="b4690-612">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="b4690-613">Les groupes de méthode peuvent influencer la résolution de surcharge et participer à l’inférence de type.</span><span class="sxs-lookup"><span data-stu-id="b4690-613">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="b4690-614">Consultez [membres de fonction](expressions.md#function-members) pour plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="b4690-614">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="b4690-615">La version d’évaluation de l’exécution d’une conversion de groupe de méthode procède comme suit :</span><span class="sxs-lookup"><span data-stu-id="b4690-615">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="b4690-616">Si la méthode sélectionnée au moment de la compilation est une méthode d’instance, ou il est une méthode d’extension qui est accessible en tant qu’une méthode d’instance, l’objet cible du délégué est déterminé à partir de l’expression d’instance associée `E`:</span><span class="sxs-lookup"><span data-stu-id="b4690-616">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="b4690-617">L’expression d’instance est évaluée.</span><span class="sxs-lookup"><span data-stu-id="b4690-617">The instance expression is evaluated.</span></span> <span data-ttu-id="b4690-618">Si cette version d’évaluation provoque une exception, aucune étape supplémentaire n’est exécutées.</span><span class="sxs-lookup"><span data-stu-id="b4690-618">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="b4690-619">Si l’expression d’instance est d’un *reference_type*, la valeur calculée par l’expression d’instance devient l’objet cible.</span><span class="sxs-lookup"><span data-stu-id="b4690-619">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="b4690-620">Si la méthode sélectionnée est une méthode d’instance et l’objet cible est `null`, un `System.NullReferenceException` est levée et aucune autre étape n’est exécutée.</span><span class="sxs-lookup"><span data-stu-id="b4690-620">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="b4690-621">Si l’expression d’instance est d’un *value_type*, une opération de boxing ([conversions Boxing](types.md#boxing-conversions)) est effectuée pour convertir la valeur d’un objet, et cet objet devienne l’objet cible.</span><span class="sxs-lookup"><span data-stu-id="b4690-621">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="b4690-622">Sinon, la méthode sélectionnée fait partie d’un appel de méthode statique, et l’objet cible du délégué est `null`.</span><span class="sxs-lookup"><span data-stu-id="b4690-622">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="b4690-623">Une nouvelle instance du type délégué `D` est allouée.</span><span class="sxs-lookup"><span data-stu-id="b4690-623">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="b4690-624">Si vous ne comporte pas assez de mémoire disponible pour allouer la nouvelle instance, un `System.OutOfMemoryException` est levée et aucune autre étape n’est exécutée.</span><span class="sxs-lookup"><span data-stu-id="b4690-624">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="b4690-625">La nouvelle instance de délégué est initialisée avec une référence à la méthode qui a été déterminée au moment de la compilation et une référence à l’objet cible calculé ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="b4690-625">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
