---
ms.openlocfilehash: 4d6d28a3127bc701867afe157aa5496377a06f69
ms.sourcegitcommit: 63d276488c9770a565fd787020783ffc1d2af9d6
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/05/2019
ms.locfileid: "74868002"
---
# <a name="conversions"></a><span data-ttu-id="36a0b-101">Conversions</span><span class="sxs-lookup"><span data-stu-id="36a0b-101">Conversions</span></span>

<span data-ttu-id="36a0b-102">Une ***conversion*** permet à une expression d’être traitée comme étant d’un type particulier.</span><span class="sxs-lookup"><span data-stu-id="36a0b-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="36a0b-103">Une conversion peut entraîner le traitement d’une expression d’un type donné comme ayant un type différent, ou elle peut provoquer l’utilisation d’une expression sans type pour obtenir un type.</span><span class="sxs-lookup"><span data-stu-id="36a0b-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="36a0b-104">Les conversions peuvent être ***implicites*** ou ***explicites***, et cela détermine si un cast explicite est requis.</span><span class="sxs-lookup"><span data-stu-id="36a0b-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="36a0b-105">Par exemple, la conversion du type `int` en type `long` est implicite, de sorte que les expressions de type `int` peuvent implicitement être traitées comme des `long`de type.</span><span class="sxs-lookup"><span data-stu-id="36a0b-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="36a0b-106">La conversion inverse, du type `long` en type `int`, est explicite et un cast explicite est donc nécessaire.</span><span class="sxs-lookup"><span data-stu-id="36a0b-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="36a0b-107">Certaines conversions sont définies par le langage.</span><span class="sxs-lookup"><span data-stu-id="36a0b-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="36a0b-108">Les programmes peuvent également définir leurs propres conversions ([conversions définies par l’utilisateur](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="36a0b-109">Conversions implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-109">Implicit conversions</span></span>

<span data-ttu-id="36a0b-110">Les conversions suivantes sont classées comme conversions implicites :</span><span class="sxs-lookup"><span data-stu-id="36a0b-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="36a0b-111">Conversions d’identité</span><span class="sxs-lookup"><span data-stu-id="36a0b-111">Identity conversions</span></span>
*  <span data-ttu-id="36a0b-112">Conversions numériques implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="36a0b-113">Conversions d’énumération implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-113">Implicit enumeration conversions</span></span>
*  <span data-ttu-id="36a0b-114">Conversions de chaînes interpolées implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-114">Implicit interpolated string conversions</span></span>
*  <span data-ttu-id="36a0b-115">Conversions Nullable implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-115">Implicit nullable conversions</span></span>
*  <span data-ttu-id="36a0b-116">Conversions de littéral null</span><span class="sxs-lookup"><span data-stu-id="36a0b-116">Null literal conversions</span></span>
*  <span data-ttu-id="36a0b-117">Conversions de références implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-117">Implicit reference conversions</span></span>
*  <span data-ttu-id="36a0b-118">Conversions boxing</span><span class="sxs-lookup"><span data-stu-id="36a0b-118">Boxing conversions</span></span>
*  <span data-ttu-id="36a0b-119">Conversions dynamiques implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-119">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="36a0b-120">Conversions d’expressions constantes implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-120">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="36a0b-121">Conversions implicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="36a0b-121">User-defined implicit conversions</span></span>
*  <span data-ttu-id="36a0b-122">Conversions de fonctions anonymes</span><span class="sxs-lookup"><span data-stu-id="36a0b-122">Anonymous function conversions</span></span>
*  <span data-ttu-id="36a0b-123">Conversions de groupe de méthodes</span><span class="sxs-lookup"><span data-stu-id="36a0b-123">Method group conversions</span></span>

<span data-ttu-id="36a0b-124">Les conversions implicites peuvent se produire dans diverses situations, y compris les appels de membres[de fonctions (vérification au moment de la compilation de la résolution de surcharge dynamique](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), les expressions de cast ([expressions de cast](expressions.md#cast-expressions)) et les assignations ([opérateurs d’assignation](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-124">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="36a0b-125">Les conversions implicites prédéfinies aboutissent toujours et n’entraînent jamais la levée d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="36a0b-125">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="36a0b-126">Les conversions implicites définies par l’utilisateur doivent également présenter ces caractéristiques.</span><span class="sxs-lookup"><span data-stu-id="36a0b-126">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="36a0b-127">Dans le cadre de la conversion, les types `object` et `dynamic` sont considérés comme équivalents.</span><span class="sxs-lookup"><span data-stu-id="36a0b-127">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="36a0b-128">Toutefois, les conversions dynamiques (conversions[dynamiques implicites](conversions.md#implicit-dynamic-conversions) et [conversions dynamiques explicites](conversions.md#explicit-dynamic-conversions)) s’appliquent uniquement aux expressions de type `dynamic` ([type dynamique](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-128">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="36a0b-129">Conversion d’identité</span><span class="sxs-lookup"><span data-stu-id="36a0b-129">Identity conversion</span></span>

<span data-ttu-id="36a0b-130">Une conversion d’identité est convertie de n’importe quel type vers le même type.</span><span class="sxs-lookup"><span data-stu-id="36a0b-130">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="36a0b-131">Cette conversion existe de telle sorte qu’une entité qui a déjà un type requis peut être considérée comme convertible en ce type.</span><span class="sxs-lookup"><span data-stu-id="36a0b-131">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="36a0b-132">Étant donné que les `object` et les `dynamic` sont considérés comme équivalents, il existe une conversion d’identité entre `object` et `dynamic`, et entre les types construits qui sont identiques lors du remplacement de toutes les occurrences de `dynamic` par `object`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-132">Because `object` and `dynamic` are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="36a0b-133">Conversions numériques implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-133">Implicit numeric conversions</span></span>

<span data-ttu-id="36a0b-134">Les conversions numériques implicites sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-134">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="36a0b-135">De `sbyte` à `short`, `int`, `long`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-135">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-136">De `byte` à `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-136">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-137">De `short` à `int`, `long`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-137">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-138">De `ushort` à `int`, `uint`, `long`, `ulong`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-138">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-139">De `int` à `long`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-139">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-140">De `uint` à `long`, `ulong`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-140">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-141">De `long` à `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-141">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-142">De `ulong` à `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-142">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-143">De `char` à `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-143">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-144">De `float` à `double`</span><span class="sxs-lookup"><span data-stu-id="36a0b-144">From `float` to `double`.</span></span>

<span data-ttu-id="36a0b-145">Les conversions de `int`, `uint`, `long`ou `ulong` en `float` et de `long` ou `ulong` à `double` peuvent entraîner une perte de précision, mais n’entraînent jamais de perte de magnitude.</span><span class="sxs-lookup"><span data-stu-id="36a0b-145">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="36a0b-146">Les autres conversions numériques implicites ne perdent jamais d’informations.</span><span class="sxs-lookup"><span data-stu-id="36a0b-146">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="36a0b-147">Il n’existe pas de conversion implicite vers le type `char`, donc les valeurs des autres types intégraux ne sont pas automatiquement converties en type `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-147">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="36a0b-148">Conversions d’énumération implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-148">Implicit enumeration conversions</span></span>

<span data-ttu-id="36a0b-149">Une conversion d’énumération implicite permet à l' *decimal_integer_literal* `0` être convertie en n’importe quel *enum_type* et en n’importe quel *nullable_type* dont le type sous-jacent est un *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-149">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="36a0b-150">Dans ce dernier cas, la conversion est évaluée en convertissant les *enum_type* sous-jacentes et en encapsulant le résultat ([types Nullable](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-150">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="36a0b-151">Conversions de chaînes interpolées implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-151">Implicit interpolated string conversions</span></span>

<span data-ttu-id="36a0b-152">Une conversion de chaîne interpolée implicite permet à une *interpolated_string_expression* ([chaînes interpolées](expressions.md#interpolated-strings)) d’être converties en `System.IFormattable` ou `System.FormattableString` (qui implémente `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="36a0b-152">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="36a0b-153">Lorsque cette conversion est appliquée, une valeur de chaîne n’est pas composée de la chaîne interpolée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-153">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="36a0b-154">Au lieu de cela, une instance de `System.FormattableString` est créée, comme décrit plus loin dans [chaînes interpolées](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="36a0b-154">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="36a0b-155">Conversions Nullable implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-155">Implicit nullable conversions</span></span>

<span data-ttu-id="36a0b-156">Les conversions implicites prédéfinies qui fonctionnent sur des types valeur non Nullable peuvent également être utilisées avec des formes Nullable de ces types.</span><span class="sxs-lookup"><span data-stu-id="36a0b-156">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="36a0b-157">Pour chaque identité implicite prédéfinie et conversion numérique qui convertissent un type valeur n’acceptant pas les valeurs NULL `S` en un type valeur non Nullable `T`, les conversions Nullable implicites suivantes existent :</span><span class="sxs-lookup"><span data-stu-id="36a0b-157">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="36a0b-158">Conversion implicite de `S?` en `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-158">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="36a0b-159">Conversion implicite de `S` en `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-159">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="36a0b-160">L’évaluation d’une conversion Nullable implicite basée sur une conversion sous-jacente de `S` à `T` se déroule comme suit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-160">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="36a0b-161">Si la conversion Nullable est comprise entre `S?` et `T?`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-161">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="36a0b-162">Si la valeur source est null (`HasValue` propriété a la valeur false), le résultat est la valeur null de type `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-162">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="36a0b-163">Dans le cas contraire, la conversion est évaluée en tant que désencapsulation de `S?` à `S`, suivi de la conversion sous-jacente de `S` en `T`, suivie d’un encapsulation ([types Nullable](types.md#nullable-types)) de `T` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-163">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="36a0b-164">Si la conversion Nullable est comprise entre `S` et `T?`, la conversion est évaluée comme la conversion sous-jacente de `S` en `T` suivie d’une encapsulation de `T` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-164">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="36a0b-165">Conversions de littéral null</span><span class="sxs-lookup"><span data-stu-id="36a0b-165">Null literal conversions</span></span>

<span data-ttu-id="36a0b-166">Une conversion implicite existe à partir du littéral `null` en n’importe quel type Nullable.</span><span class="sxs-lookup"><span data-stu-id="36a0b-166">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="36a0b-167">Cette conversion produit la valeur null ([types Nullable](types.md#nullable-types)) du type Nullable donné.</span><span class="sxs-lookup"><span data-stu-id="36a0b-167">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="36a0b-168">Conversions de références implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-168">Implicit reference conversions</span></span>

<span data-ttu-id="36a0b-169">Les conversions de référence implicites sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-169">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="36a0b-170">Depuis n’importe quel *reference_type* vers `object` et `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-170">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="36a0b-171">À partir de tout *class_type* `S` à n’importe quel `T`*class_type* , fourni `S` est dérivé de `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-171">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="36a0b-172">À partir de tout *class_type* `S` à n’importe quel `T`*interface_type* , fourni `S` implémente `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-172">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="36a0b-173">À partir de tout *interface_type* `S` à n’importe quel `T`*interface_type* , fourni `S` est dérivé de `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-173">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="36a0b-174">D’un *array_type* `S` avec un type d’élément `SE` à un *array_type* `T` avec un type d’élément `TE`, à condition que les conditions suivantes soient remplies :</span><span class="sxs-lookup"><span data-stu-id="36a0b-174">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="36a0b-175">`S` et `T` diffèrent uniquement par le type d’élément.</span><span class="sxs-lookup"><span data-stu-id="36a0b-175">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="36a0b-176">En d’autres termes, `S` et `T` ont le même nombre de dimensions.</span><span class="sxs-lookup"><span data-stu-id="36a0b-176">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="36a0b-177">Les `SE` et les `TE` sont *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="36a0b-177">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="36a0b-178">Une conversion de référence implicite existe de `SE` à `TE`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-178">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="36a0b-179">De tout *array_type* vers `System.Array` et les interfaces qu’il implémente.</span><span class="sxs-lookup"><span data-stu-id="36a0b-179">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="36a0b-180">À partir d’un type tableau unidimensionnel `S[]` à `System.Collections.Generic.IList<T>` et à ses interfaces de base, à condition qu’il existe une conversion implicite d’identité ou de référence de `S` en `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-180">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="36a0b-181">De tout *delegate_type* vers `System.Delegate` et les interfaces qu’il implémente.</span><span class="sxs-lookup"><span data-stu-id="36a0b-181">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="36a0b-182">Du littéral null à n’importe quel *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-182">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="36a0b-183">De tout *reference_type* à un *reference_type* `T` s’il possède une conversion d’identité ou de référence implicite en une *reference_type* `T0` et `T0` a une conversion d’identité en `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-183">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="36a0b-184">De tout *reference_type* à un type d’interface ou de délégué `T` s’il a une conversion d’identité ou de référence implicite en une interface ou un type délégué `T0` et `T0` est convertible en variance ([conversion d’écart](interfaces.md#variance-conversion)) en `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-184">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="36a0b-185">Conversions implicites impliquant des paramètres de type connus comme des types référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-185">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="36a0b-186">Pour plus d’informations sur les conversions implicites impliquant des paramètres de type, consultez [conversions implicites impliquant des paramètres](conversions.md#implicit-conversions-involving-type-parameters) de type.</span><span class="sxs-lookup"><span data-stu-id="36a0b-186">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="36a0b-187">Les conversions de référence implicites sont les conversions entre *reference_type*s qui peuvent être prouvées de toujours s’exécuter correctement, et ne nécessitent donc pas de vérification au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="36a0b-187">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="36a0b-188">Les conversions de référence, implicites ou explicites, ne modifient jamais l’identité référentielle de l’objet en cours de conversion.</span><span class="sxs-lookup"><span data-stu-id="36a0b-188">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="36a0b-189">En d’autres termes, si une conversion de référence peut modifier le type de la référence, elle ne modifie jamais le type ou la valeur de l’objet auquel il est fait référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-189">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="36a0b-190">Conversions boxing</span><span class="sxs-lookup"><span data-stu-id="36a0b-190">Boxing conversions</span></span>

<span data-ttu-id="36a0b-191">Une conversion boxing permet à un *Value_type* d’être implicitement converti en un type référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-191">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="36a0b-192">Une conversion boxing existe de tout *non_nullable_value_type* à `object` et `dynamic`, à `System.ValueType` et à tout *INTERFACE_TYPE* implémenté par le *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-192">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="36a0b-193">En outre, une *enum_type* peut être convertie en type `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-193">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="36a0b-194">Une conversion boxing existe d’un *nullable_type* à un type référence, si et seulement s’il existe une conversion boxing du *non_nullable_value_type* sous-jacent au type référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-194">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="36a0b-195">Un type valeur a une conversion boxing en type interface `I` s’il a une conversion boxing en type interface `I0` et `I0` a une conversion d’identité en `I`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="36a0b-196">Un type valeur a une conversion boxing en type interface `I` s’il a une conversion boxing en une interface ou un type délégué `I0` et `I0` est convertible en variance ([conversion d’écart](interfaces.md#variance-conversion)) en `I`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-196">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="36a0b-197">Le boxing d’une valeur d’une *non_nullable_value_type* consiste à allouer une instance d’objet et à copier la valeur *Value_type* dans cette instance.</span><span class="sxs-lookup"><span data-stu-id="36a0b-197">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="36a0b-198">Une structure peut être convertie dans le type `System.ValueType`, car il s’agit d’une classe de base pour tous les structs ([héritage](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-198">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="36a0b-199">Le boxing d’une valeur d’un *nullable_type* se déroule comme suit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-199">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="36a0b-200">Si la valeur source est null (`HasValue` propriété a la valeur false), le résultat est une référence null du type cible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-200">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="36a0b-201">Dans le cas contraire, le résultat est une référence à un boxed `T` produit en désencapsulant et en Boxing la valeur source.</span><span class="sxs-lookup"><span data-stu-id="36a0b-201">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="36a0b-202">Les conversions boxing sont décrites plus en détail dans [conversions boxing](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="36a0b-202">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="36a0b-203">Conversions dynamiques implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-203">Implicit dynamic conversions</span></span>

<span data-ttu-id="36a0b-204">Une conversion dynamique implicite existe à partir d’une expression de type `dynamic` à n’importe quel type `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-204">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="36a0b-205">La conversion est liée dynamiquement ([liaison dynamique](expressions.md#dynamic-binding)), ce qui signifie qu’une conversion implicite est recherchée au moment de l’exécution à partir du type au moment de l’exécution de l’expression à `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-205">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="36a0b-206">Si aucune conversion n’est trouvée, une exception Runtime est levée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-206">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="36a0b-207">Notez que cette conversion implicite n’enfreint apparemment pas les conseils au début des [conversions implicites](conversions.md#implicit-conversions) qu’une conversion implicite ne doit jamais provoquer une exception.</span><span class="sxs-lookup"><span data-stu-id="36a0b-207">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="36a0b-208">Toutefois, il ne s’agit pas de la conversion elle-même, mais de la *détection* de la conversion à l’origine de l’exception.</span><span class="sxs-lookup"><span data-stu-id="36a0b-208">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="36a0b-209">Le risque d’exceptions au moment de l’exécution est inhérent à l’utilisation de la liaison dynamique.</span><span class="sxs-lookup"><span data-stu-id="36a0b-209">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="36a0b-210">Si la liaison dynamique de la conversion n’est pas souhaitée, l’expression peut être d’abord convertie en `object`, puis vers le type souhaité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-210">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="36a0b-211">L’exemple suivant illustre des conversions dynamiques implicites :</span><span class="sxs-lookup"><span data-stu-id="36a0b-211">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="36a0b-212">Les assignations à `s2` et `i` utilisent des conversions dynamiques implicites, où la liaison des opérations est suspendue jusqu’au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="36a0b-212">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="36a0b-213">Au moment de l’exécution, les conversions implicites sont recherchées à partir du type au moment de l’exécution de `d` -- `string` vers le type cible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-213">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="36a0b-214">Une conversion a été détectée pour `string` mais pas pour `int`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-214">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="36a0b-215">Conversions d’expressions constantes implicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-215">Implicit constant expression conversions</span></span>

<span data-ttu-id="36a0b-216">Une conversion d’expression constante implicite autorise les conversions suivantes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-216">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="36a0b-217">Une *constant_expression* ([expressions constantes](expressions.md#constant-expressions)) de type `int` peut être convertie en type `sbyte`, `byte`, `short`, `ushort`, `uint`ou `ulong`, à condition que la valeur de la *constant_expression* soit comprise dans la plage du type de destination.</span><span class="sxs-lookup"><span data-stu-id="36a0b-217">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="36a0b-218">Une *constant_expression* de type `long` peut être convertie en type `ulong`, à condition que la valeur de la *constant_expression* ne soit pas négative.</span><span class="sxs-lookup"><span data-stu-id="36a0b-218">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="36a0b-219">Conversions implicites impliquant des paramètres de type</span><span class="sxs-lookup"><span data-stu-id="36a0b-219">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="36a0b-220">Les conversions implicites suivantes existent pour un paramètre de type donné `T`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-220">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="36a0b-221">De `T` à sa classe de base effective `C`, de `T` à toute classe de base de `C`, et de `T` à toute interface implémentée par `C`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-221">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="36a0b-222">Au moment de l’exécution, si `T` est un type valeur, la conversion est exécutée en tant que conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="36a0b-222">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="36a0b-223">Dans le cas contraire, la conversion est exécutée en tant que conversion de référence implicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-223">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="36a0b-224">De `T` à un type d’interface `I` dans le jeu d’interfaces effectifs de `T`et de `T` à toute interface de base de `I`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-224">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="36a0b-225">Au moment de l’exécution, si `T` est un type valeur, la conversion est exécutée en tant que conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="36a0b-225">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="36a0b-226">Dans le cas contraire, la conversion est exécutée en tant que conversion de référence implicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-226">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="36a0b-227">De `T` à un paramètre de type `U`, fourni `T` dépend de `U` ([contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-227">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="36a0b-228">Au moment de l’exécution, si `U` est un type valeur, `T` et `U` sont nécessairement du même type et aucune conversion n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-228">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="36a0b-229">Sinon, si `T` est un type valeur, la conversion est exécutée en tant que conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="36a0b-229">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="36a0b-230">Dans le cas contraire, la conversion est exécutée en tant que conversion de référence implicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-230">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="36a0b-231">Du littéral null à `T`, fourni `T` est considéré comme un type référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-231">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="36a0b-232">De `T` à un type référence `I` s’il a une conversion implicite en type référence `S0` et `S0` a une conversion d’identité en `S`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-232">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="36a0b-233">Au moment de l’exécution, la conversion est exécutée de la même façon que la conversion en `S0`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-233">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="36a0b-234">De `T` à un type d’interface `I` s’il a une conversion implicite en une interface ou un type délégué `I0` et `I0` est convertible en `I` ([conversion d’écart](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-234">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="36a0b-235">Au moment de l’exécution, si `T` est un type valeur, la conversion est exécutée en tant que conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="36a0b-235">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="36a0b-236">Dans le cas contraire, la conversion est exécutée en tant que conversion de référence implicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-236">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="36a0b-237">Si `T` est connu comme un type référence ([contraintes de paramètre de type](classes.md#type-parameter-constraints)), les conversions ci-dessus sont toutes classées comme conversions de référence implicites (conversions de[référence implicites](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-237">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="36a0b-238">Si `T` n’est pas connu comme étant un type référence, les conversions ci-dessus sont classées comme conversions boxing (conversions[boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-238">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="36a0b-239">Conversions implicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="36a0b-239">User-defined implicit conversions</span></span>

<span data-ttu-id="36a0b-240">Une conversion implicite définie par l’utilisateur se compose d’une conversion implicite standard facultative, suivie de l’exécution d’un opérateur de conversion implicite défini par l’utilisateur, suivie d’une autre conversion implicite standard facultative.</span><span class="sxs-lookup"><span data-stu-id="36a0b-240">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="36a0b-241">Les règles exactes d’évaluation des conversions implicites définies par l’utilisateur sont décrites dans [traitement des conversions implicites définies par l’utilisateur](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="36a0b-241">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="36a0b-242">Conversions de fonctions anonymes et conversions de groupes de méthodes</span><span class="sxs-lookup"><span data-stu-id="36a0b-242">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="36a0b-243">Les fonctions anonymes et les groupes de méthodes n’ont pas de types dans et à eux-mêmes, mais peuvent être implicitement convertis en types délégués ou en types d’arborescences d’expressions.</span><span class="sxs-lookup"><span data-stu-id="36a0b-243">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="36a0b-244">Les conversions de fonctions anonymes sont décrites plus en détail dans conversions de [fonctions anonymes](conversions.md#anonymous-function-conversions) et conversions de groupes de méthodes dans les conversions de [groupe de méthodes](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="36a0b-244">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="36a0b-245">Conversions explicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-245">Explicit conversions</span></span>

<span data-ttu-id="36a0b-246">Les conversions suivantes sont classées comme des conversions explicites :</span><span class="sxs-lookup"><span data-stu-id="36a0b-246">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="36a0b-247">Toutes les conversions implicites.</span><span class="sxs-lookup"><span data-stu-id="36a0b-247">All implicit conversions.</span></span>
*  <span data-ttu-id="36a0b-248">Conversions numériques explicites.</span><span class="sxs-lookup"><span data-stu-id="36a0b-248">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="36a0b-249">Conversions d’énumération explicites.</span><span class="sxs-lookup"><span data-stu-id="36a0b-249">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="36a0b-250">Conversions Nullable explicites.</span><span class="sxs-lookup"><span data-stu-id="36a0b-250">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="36a0b-251">Conversions de référence explicites.</span><span class="sxs-lookup"><span data-stu-id="36a0b-251">Explicit reference conversions.</span></span>
*  <span data-ttu-id="36a0b-252">Conversions d’interface explicites.</span><span class="sxs-lookup"><span data-stu-id="36a0b-252">Explicit interface conversions.</span></span>
*  <span data-ttu-id="36a0b-253">Conversions unboxing.</span><span class="sxs-lookup"><span data-stu-id="36a0b-253">Unboxing conversions.</span></span>
*  <span data-ttu-id="36a0b-254">Conversions dynamiques explicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-254">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="36a0b-255">Conversions explicites définies par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-255">User-defined explicit conversions.</span></span>

<span data-ttu-id="36a0b-256">Les conversions explicites peuvent se produire dans les expressions de cast ([expressions de cast](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-256">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="36a0b-257">L’ensemble de conversions explicites comprend toutes les conversions implicites.</span><span class="sxs-lookup"><span data-stu-id="36a0b-257">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="36a0b-258">Cela signifie que les expressions de cast redondantes sont autorisées.</span><span class="sxs-lookup"><span data-stu-id="36a0b-258">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="36a0b-259">Les conversions explicites qui ne sont pas des conversions implicites sont des conversions qui ne peuvent pas être prouvées comme ayant échoué, des conversions qui sont susceptibles de perdre des informations et des conversions entre des domaines de types suffisamment différentes pour mériter une valeur explicite conventions.</span><span class="sxs-lookup"><span data-stu-id="36a0b-259">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="36a0b-260">Conversions numériques explicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-260">Explicit numeric conversions</span></span>

<span data-ttu-id="36a0b-261">Les conversions numériques explicites sont les conversions d’un *numeric_type* à un autre *numeric_type* pour lequel une conversion numérique implicite ([conversions numériques implicites](conversions.md#implicit-numeric-conversions)) n’existe pas encore :</span><span class="sxs-lookup"><span data-stu-id="36a0b-261">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="36a0b-262">De `sbyte` à `byte`, `ushort`, `uint`, `ulong`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-262">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="36a0b-263">De `byte` à `sbyte` et `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-263">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="36a0b-264">De `short` à `sbyte`, `byte`, `ushort`, `uint`, `ulong`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-264">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="36a0b-265">De `ushort` à `sbyte`, `byte`, `short`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-265">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="36a0b-266">De `int` à `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-266">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="36a0b-267">De `uint` à `sbyte`, `byte`, `short`, `ushort`, `int`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-267">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="36a0b-268">De `long` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-268">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="36a0b-269">De `ulong` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`ou `char`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-269">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="36a0b-270">De `char` à `sbyte`, `byte`ou `short`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-270">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="36a0b-271">De `float` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-271">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-272">De `double` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-272">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-273">De `decimal` à `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`ou `double`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-273">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="36a0b-274">Étant donné que les conversions explicites incluent toutes les conversions numériques implicites et explicites, il est toujours possible de convertir des *numeric_type* en tout autre *numeric_type* à l’aide d’une expression de cast ([expressions de cast](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-274">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="36a0b-275">Les conversions numériques explicites peuvent éventuellement perdre des informations ou provoquer des exceptions.</span><span class="sxs-lookup"><span data-stu-id="36a0b-275">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="36a0b-276">Une conversion numérique explicite est traitée comme suit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-276">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="36a0b-277">Pour une conversion d’un type intégral vers un autre type intégral, le traitement dépend du contexte de vérification de dépassement de capacité ([opérateurs activés et désactivés](expressions.md#the-checked-and-unchecked-operators)) dans lequel la conversion a lieu :</span><span class="sxs-lookup"><span data-stu-id="36a0b-277">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="36a0b-278">Dans un contexte de `checked`, la conversion s’effectue correctement si la valeur de l’opérande source est comprise dans la plage du type de destination, mais lève une `System.OverflowException` si la valeur de l’opérande source est en dehors de la plage du type de destination.</span><span class="sxs-lookup"><span data-stu-id="36a0b-278">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="36a0b-279">Dans un contexte de `unchecked`, la conversion est toujours réussie et se poursuit comme suit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-279">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="36a0b-280">Si le type source est plus grand que le type de destination, la valeur source est tronquée via l’abandon de ses bits « supplémentaires » les plus significatifs.</span><span class="sxs-lookup"><span data-stu-id="36a0b-280">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="36a0b-281">Le résultat est ensuite traité en tant que valeur du type de destination.</span><span class="sxs-lookup"><span data-stu-id="36a0b-281">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="36a0b-282">Si le type source est plus petit que le type de destination, la valeur source fait l’objet d’une extension de signe ou d’une extension de zéros, pour avoir la même taille que le type de destination.</span><span class="sxs-lookup"><span data-stu-id="36a0b-282">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="36a0b-283">L’extension de signe est utilisée si le type source est signé. L’extension de zéro est utilisée si le type source est non signé.</span><span class="sxs-lookup"><span data-stu-id="36a0b-283">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="36a0b-284">Le résultat est ensuite traité en tant que valeur du type de destination.</span><span class="sxs-lookup"><span data-stu-id="36a0b-284">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="36a0b-285">Si le type source a la même taille que le type de destination, la valeur source est traitée comme une valeur du type de destination.</span><span class="sxs-lookup"><span data-stu-id="36a0b-285">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="36a0b-286">Pour une conversion de `decimal` en type intégral, la valeur source est arrondie vers zéro à la valeur intégrale la plus proche, et cette valeur intégrale devient le résultat de la conversion.</span><span class="sxs-lookup"><span data-stu-id="36a0b-286">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="36a0b-287">Si la valeur intégrale obtenue est en dehors de la plage du type de destination, une `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-287">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="36a0b-288">Pour une conversion à partir de `float` ou `double` en type intégral, le traitement dépend du contexte de vérification de dépassement de capacité ([opérateurs activés et désactivés](expressions.md#the-checked-and-unchecked-operators)) dans lequel la conversion a lieu :</span><span class="sxs-lookup"><span data-stu-id="36a0b-288">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="36a0b-289">Dans un contexte de `checked`, la conversion se poursuit comme suit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-289">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="36a0b-290">Si la valeur de l’opérande est NaN ou infinie, une `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-290">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="36a0b-291">Dans le cas contraire, l’opérande source est arrondi vers la valeur intégrale la plus proche de zéro.</span><span class="sxs-lookup"><span data-stu-id="36a0b-291">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="36a0b-292">Si cette valeur intégrale est comprise dans la plage du type de destination, cette valeur est le résultat de la conversion.</span><span class="sxs-lookup"><span data-stu-id="36a0b-292">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="36a0b-293">Sinon, une exception `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-293">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="36a0b-294">Dans un contexte de `unchecked`, la conversion est toujours réussie et se poursuit comme suit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-294">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="36a0b-295">Si la valeur de l’opérande est NaN ou infinie, le résultat de la conversion est une valeur non spécifiée du type de destination.</span><span class="sxs-lookup"><span data-stu-id="36a0b-295">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="36a0b-296">Dans le cas contraire, l’opérande source est arrondi vers la valeur intégrale la plus proche de zéro.</span><span class="sxs-lookup"><span data-stu-id="36a0b-296">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="36a0b-297">Si cette valeur intégrale est comprise dans la plage du type de destination, cette valeur est le résultat de la conversion.</span><span class="sxs-lookup"><span data-stu-id="36a0b-297">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="36a0b-298">Dans le cas contraire, le résultat de la conversion est une valeur non spécifiée du type de destination.</span><span class="sxs-lookup"><span data-stu-id="36a0b-298">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="36a0b-299">Pour une conversion de `double` en `float`, la valeur de `double` est arrondie à la valeur de `float` la plus proche.</span><span class="sxs-lookup"><span data-stu-id="36a0b-299">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="36a0b-300">Si la valeur `double` est trop petite pour être représentée en tant que `float`, le résultat devient un zéro positif ou un zéro négatif.</span><span class="sxs-lookup"><span data-stu-id="36a0b-300">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="36a0b-301">Si la valeur `double` est trop grande pour être représentée en tant que `float`, le résultat devient une infini positif ou négatif.</span><span class="sxs-lookup"><span data-stu-id="36a0b-301">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="36a0b-302">Si la valeur `double` est NaN, le résultat est également NaN.</span><span class="sxs-lookup"><span data-stu-id="36a0b-302">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="36a0b-303">Pour une conversion de `float` ou `double` en `decimal`, la valeur source est convertie en `decimal` représentation et arrondie au nombre le plus proche après la valeur de 28 décimales, si nécessaire ([type décimal](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-303">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="36a0b-304">Si la valeur source est trop petite pour être représentée en tant que `decimal`, le résultat devient zéro.</span><span class="sxs-lookup"><span data-stu-id="36a0b-304">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="36a0b-305">Si la valeur source est NaN, Infinity ou trop grande pour être représentée comme un `decimal`, un `System.OverflowException` est levé.</span><span class="sxs-lookup"><span data-stu-id="36a0b-305">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="36a0b-306">Pour une conversion de `decimal` en `float` ou `double`, la valeur `decimal` est arrondie à la valeur `double` ou `float` la plus proche.</span><span class="sxs-lookup"><span data-stu-id="36a0b-306">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="36a0b-307">Bien que cette conversion puisse perdre la précision, elle ne provoque jamais la levée d’une exception.</span><span class="sxs-lookup"><span data-stu-id="36a0b-307">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="36a0b-308">Conversions d’énumération explicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-308">Explicit enumeration conversions</span></span>

<span data-ttu-id="36a0b-309">Les conversions d’énumération explicites sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-309">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="36a0b-310">À partir de `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`ou `decimal` à n’importe quel *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-310">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="36a0b-311">À partir de n’importe quelle *enum_type* vers `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`ou `decimal`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-311">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="36a0b-312">De tout *enum_type* à n’importe quel autre *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-312">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="36a0b-313">Une conversion d’énumération explicite entre deux types est traitée en traitant tout *enum_type* participant en tant que type sous-jacent de ce *enum_type*, puis en effectuant une conversion numérique implicite ou explicite entre les types résultants.</span><span class="sxs-lookup"><span data-stu-id="36a0b-313">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="36a0b-314">Par exemple, étant donné un *enum_type* `E` avec et le type sous-jacent de `int`, une conversion de `E` en `byte` est traitée comme une conversion numérique explicite ([conversions numériques explicites](conversions.md#explicit-numeric-conversions)) de `int` à `byte`, et une conversion de `byte` en `E` est traitée comme une conversion numérique implicite ([conversions numériques implicites](conversions.md#implicit-numeric-conversions)) de `byte` à `int`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-314">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="36a0b-315">Conversions Nullable explicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-315">Explicit nullable conversions</span></span>

<span data-ttu-id="36a0b-316">Les ***conversions Nullable explicites*** autorisent les conversions explicites prédéfinies qui fonctionnent sur les types valeur non Nullable pour être également utilisées avec les formes Nullable de ces types.</span><span class="sxs-lookup"><span data-stu-id="36a0b-316">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="36a0b-317">Pour chacune des conversions explicites prédéfinies qui convertissent un type valeur n’acceptant pas les valeurs NULL `S` en un type valeur non Nullable `T` ([conversion d’identité](conversions.md#identity-conversion), conversions [numériques implicites](conversions.md#implicit-numeric-conversions), conversions d' [énumération implicites](conversions.md#implicit-enumeration-conversions), [conversions numériques explicites](conversions.md#explicit-numeric-conversions)et [conversions d’énumération explicites](conversions.md#explicit-enumeration-conversions)), les conversions Nullable suivantes existent :</span><span class="sxs-lookup"><span data-stu-id="36a0b-317">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="36a0b-318">Conversion explicite de `S?` en `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-318">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="36a0b-319">Conversion explicite de `S` en `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-319">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="36a0b-320">Conversion explicite de `S?` en `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-320">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="36a0b-321">L’évaluation d’une conversion Nullable basée sur une conversion sous-jacente de `S` en `T` se déroule comme suit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-321">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="36a0b-322">Si la conversion Nullable est comprise entre `S?` et `T?`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-322">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="36a0b-323">Si la valeur source est null (`HasValue` propriété a la valeur false), le résultat est la valeur null de type `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-323">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="36a0b-324">Dans le cas contraire, la conversion est évaluée en tant que désencapsulation de `S?` à `S`, suivi de la conversion sous-jacente de `S` en `T`, suivie d’une encapsulation de `T` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-324">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="36a0b-325">Si la conversion Nullable est comprise entre `S` et `T?`, la conversion est évaluée comme la conversion sous-jacente de `S` en `T` suivie d’une encapsulation de `T` à `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-325">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="36a0b-326">Si la conversion Nullable s’effectue de `S?` à `T`, la conversion est évaluée comme un désencapsulation de `S?` à `S` suivi de la conversion sous-jacente de `S` à `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-326">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="36a0b-327">Notez qu’une tentative de désencapsulation d’une valeur Nullable lève une exception si la valeur est `null`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-327">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="36a0b-328">Conversions de références explicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-328">Explicit reference conversions</span></span>

<span data-ttu-id="36a0b-329">Les conversions de référence explicites sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-329">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="36a0b-330">À partir de `object` et `dynamic` à n’importe quel autre *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-330">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="36a0b-331">À partir de n’importe quelle *class_type* `S` à tout `T`*class_type* , fourni `S` est une classe de base de `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-331">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="36a0b-332">À partir de tout *class_type* `S` à tout `T`*interface_type* , fourni `S` n’est pas sealed et fourni `S` n’implémente pas `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-332">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="36a0b-333">À partir de tout *interface_type* `S` à tout `T`*class_type* , fourni `T` n’est pas scellé ou fourni `T` implémente `S`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-333">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="36a0b-334">À partir de tout *interface_type* `S` à n’importe quel `T`*interface_type* , fourni `S` n’est pas dérivé de `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-334">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="36a0b-335">D’un *array_type* `S` avec un type d’élément `SE` à un *array_type* `T` avec un type d’élément `TE`, à condition que les conditions suivantes soient remplies :</span><span class="sxs-lookup"><span data-stu-id="36a0b-335">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="36a0b-336">`S` et `T` diffèrent uniquement par le type d’élément.</span><span class="sxs-lookup"><span data-stu-id="36a0b-336">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="36a0b-337">En d’autres termes, `S` et `T` ont le même nombre de dimensions.</span><span class="sxs-lookup"><span data-stu-id="36a0b-337">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="36a0b-338">Les `SE` et les `TE` sont *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="36a0b-338">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="36a0b-339">Une conversion de référence explicite existe de `SE` à `TE`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-339">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="36a0b-340">À partir de `System.Array` et des interfaces qu’il implémente sur n’importe quel *array_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-340">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="36a0b-341">À partir d’un type tableau unidimensionnel `S[]` à `System.Collections.Generic.IList<T>` et à ses interfaces de base, à condition qu’il existe une conversion de référence explicite de `S` en `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-341">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="36a0b-342">De `System.Collections.Generic.IList<S>` et ses interfaces de base à un type de tableau unidimensionnel `T[]`, à condition qu’il existe une conversion d’identité ou de référence explicite de `S` à `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-342">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="36a0b-343">À partir de `System.Delegate` et des interfaces qu’il implémente sur n’importe quel *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-343">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="36a0b-344">D’un type référence à un type référence `T` s’il a une conversion de référence explicite en un type référence `T0` et `T0` a une `T`de conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-344">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="36a0b-345">D’un type référence à un type d’interface ou de délégué `T` s’il a une conversion de référence explicite en une interface ou un type délégué `T0` et que `T0` est convertible en `T` ou `T` est convertible en `T0` ([conversion d’écart](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-345">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="36a0b-346">De `D<S1...Sn>` à `D<T1...Tn>` où `D<X1...Xn>` est un type délégué générique, `D<S1...Sn>` n’est pas compatible avec ou identique à `D<T1...Tn>`, et pour chaque paramètre de type `Xi` de `D` éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="36a0b-346">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="36a0b-347">Si `Xi` est invariant, `Si` est identique à `Ti`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-347">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="36a0b-348">Si `Xi` est covariant, il existe une conversion d’identité ou de référence implicite ou explicite de `Si` en `Ti`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-348">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="36a0b-349">Si `Xi` est contravariant, `Si` et `Ti` sont identiques ou les deux types de référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-349">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="36a0b-350">Les conversions explicites impliquant des paramètres de type connus comme des types référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-350">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="36a0b-351">Pour plus d’informations sur les conversions explicites impliquant des paramètres de type, consultez [conversions explicites impliquant des paramètres de type](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="36a0b-351">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="36a0b-352">Les conversions de référence explicites sont les conversions entre les types référence qui requièrent des vérifications à l’exécution pour s’assurer qu’elles sont correctes.</span><span class="sxs-lookup"><span data-stu-id="36a0b-352">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="36a0b-353">Pour qu’une conversion de référence explicite aboutisse au moment de l’exécution, la valeur de l’opérande source doit être `null`ou le type réel de l’objet référencé par l’opérande source doit être un type qui peut être converti vers le type de destination par une conversion de référence implicite ([conversions de référence implicites](conversions.md#implicit-reference-conversions)) ou une conversion boxing ([conversions boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-353">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="36a0b-354">En cas d’échec d’une conversion de référence explicite, une `System.InvalidCastException` est levée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-354">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="36a0b-355">Les conversions de référence, implicites ou explicites, ne modifient jamais l’identité référentielle de l’objet en cours de conversion.</span><span class="sxs-lookup"><span data-stu-id="36a0b-355">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="36a0b-356">En d’autres termes, si une conversion de référence peut modifier le type de la référence, elle ne modifie jamais le type ou la valeur de l’objet auquel il est fait référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-356">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="36a0b-357">Conversions unboxing</span><span class="sxs-lookup"><span data-stu-id="36a0b-357">Unboxing conversions</span></span>

<span data-ttu-id="36a0b-358">Une conversion unboxing permet à un type de référence d’être converti explicitement en *Value_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-358">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="36a0b-359">Une conversion unboxing existe à partir des types `object`, `dynamic` et `System.ValueType` à n’importe quel *non_nullable_value_type*, et de tout *INTERFACE_TYPE* à n’importe quel *non_nullable_value_type* qui implémente le *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-359">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="36a0b-360">En outre, le type `System.Enum` peut être unboxed en *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-360">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="36a0b-361">Une conversion unboxing existe d’un type référence à un *nullable_type* s’il existe une conversion unboxing du type référence au *non_nullable_value_type* sous-jacent de l' *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-361">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="36a0b-362">Un type valeur `S` a une conversion unboxing d’un type interface `I` s’il a une conversion unboxing d’un type interface `I0` et `I0` a une conversion d’identité en `I`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="36a0b-363">Un type valeur `S` a une conversion unboxing d’un type interface `I` s’il a une conversion unboxing à partir d’une interface ou d’un type délégué `I0` et `I0` est convertible en `I` ou `I` est convertible en `I0` ([conversion d’écart](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-363">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="36a0b-364">Une opération d’unboxing consiste à vérifier en premier lieu que l’instance d’objet est une valeur boxed du *Value_type*donné, puis à copier la valeur hors de l’instance.</span><span class="sxs-lookup"><span data-stu-id="36a0b-364">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="36a0b-365">La conversion unboxing d’une référence null en *nullable_type* produit la valeur null du *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-365">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="36a0b-366">Un struct peut être unboxed du type `System.ValueType`, car il s’agit d’une classe de base pour tous les structs ([héritage](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-366">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="36a0b-367">Les conversions unboxing sont décrites plus en détail dans [conversions unboxing](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="36a0b-367">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="36a0b-368">Conversions dynamiques explicites</span><span class="sxs-lookup"><span data-stu-id="36a0b-368">Explicit dynamic conversions</span></span>

<span data-ttu-id="36a0b-369">Une conversion dynamique explicite existe à partir d’une expression de type `dynamic` à n’importe quel type `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-369">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="36a0b-370">La conversion est liée dynamiquement ([liaison dynamique](expressions.md#dynamic-binding)), ce qui signifie qu’une conversion explicite sera recherchée au moment de l’exécution à partir du type d’exécution de l’expression à `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-370">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="36a0b-371">Si aucune conversion n’est trouvée, une exception Runtime est levée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-371">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="36a0b-372">Si la liaison dynamique de la conversion n’est pas souhaitée, l’expression peut être d’abord convertie en `object`, puis vers le type souhaité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-372">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="36a0b-373">Supposons que la classe suivante soit définie :</span><span class="sxs-lookup"><span data-stu-id="36a0b-373">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="36a0b-374">L’exemple suivant illustre des conversions dynamiques explicites :</span><span class="sxs-lookup"><span data-stu-id="36a0b-374">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="36a0b-375">La meilleure conversion de `o` en `C` est trouvée au moment de la compilation pour être une conversion de référence explicite.</span><span class="sxs-lookup"><span data-stu-id="36a0b-375">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="36a0b-376">Cela échoue au moment de l’exécution, car `"1"` n’est pas en fait un `C`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-376">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="36a0b-377">La conversion de `d` en `C` Toutefois, en tant que conversion dynamique explicite, est suspendue au moment de l’exécution, où une conversion définie par l’utilisateur à partir du type d’exécution de `d` -- `string`--à `C` est trouvée, et elle se déroule correctement.</span><span class="sxs-lookup"><span data-stu-id="36a0b-377">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="36a0b-378">Conversions explicites impliquant des paramètres de type</span><span class="sxs-lookup"><span data-stu-id="36a0b-378">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="36a0b-379">Les conversions explicites suivantes existent pour un paramètre de type donné `T`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-379">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="36a0b-380">À partir de la classe de base effective `C` de `T` à `T` et à partir d’une classe de base de `C` à `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-380">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="36a0b-381">Au moment de l’exécution, si `T` est un type valeur, la conversion est exécutée en tant que conversion unboxing.</span><span class="sxs-lookup"><span data-stu-id="36a0b-381">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="36a0b-382">Dans le cas contraire, la conversion est exécutée en tant que conversion de référence explicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-382">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="36a0b-383">De n’importe quel type d’interface à `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-383">From any interface type to `T`.</span></span> <span data-ttu-id="36a0b-384">Au moment de l’exécution, si `T` est un type valeur, la conversion est exécutée en tant que conversion unboxing.</span><span class="sxs-lookup"><span data-stu-id="36a0b-384">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="36a0b-385">Dans le cas contraire, la conversion est exécutée en tant que conversion de référence explicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-385">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="36a0b-386">De `T` à n’importe quel *interface_type* `I` à condition qu’il n’y ait pas encore de conversion implicite de `T` en `I`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-386">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="36a0b-387">Au moment de l’exécution, si `T` est un type valeur, la conversion est exécutée comme une conversion boxing suivie d’une conversion de référence explicite.</span><span class="sxs-lookup"><span data-stu-id="36a0b-387">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="36a0b-388">Dans le cas contraire, la conversion est exécutée en tant que conversion de référence explicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-388">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="36a0b-389">À partir d’un paramètre de type `U` à `T`, fourni `T` dépend de `U` ([contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-389">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="36a0b-390">Au moment de l’exécution, si `U` est un type valeur, `T` et `U` sont nécessairement du même type et aucune conversion n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-390">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="36a0b-391">Sinon, si `T` est un type valeur, la conversion est exécutée en tant que conversion unboxing.</span><span class="sxs-lookup"><span data-stu-id="36a0b-391">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="36a0b-392">Dans le cas contraire, la conversion est exécutée en tant que conversion de référence explicite ou conversion d’identité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-392">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="36a0b-393">Si `T` est considéré comme un type référence, les conversions ci-dessus sont toutes classées comme des conversions de référence explicites (conversions de[référence explicites](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-393">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="36a0b-394">Si `T` n’est pas connu comme étant un type référence, les conversions ci-dessus sont classées comme conversions unboxing (conversions[unboxing](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-394">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="36a0b-395">Les règles ci-dessus n’autorisent pas une conversion explicite directe d’un paramètre de type sans contrainte en un type qui n’est pas une interface, ce qui peut être surprenant.</span><span class="sxs-lookup"><span data-stu-id="36a0b-395">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="36a0b-396">La raison de cette règle est d’éviter toute confusion et de rendre la sémantique de ces conversions claire.</span><span class="sxs-lookup"><span data-stu-id="36a0b-396">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="36a0b-397">Observez par exemple la déclaration suivante :</span><span class="sxs-lookup"><span data-stu-id="36a0b-397">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="36a0b-398">Si la conversion directe explicite de `t` en `int` était autorisée, il peut s’attendre à ce que `X<int>.F(7)` retourne `7L`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-398">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="36a0b-399">Toutefois, ce n’est pas le cas, car les conversions numériques standard sont uniquement prises en compte lorsque les types sont identifiés comme étant numériques au moment de la liaison.</span><span class="sxs-lookup"><span data-stu-id="36a0b-399">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="36a0b-400">Pour que la sémantique soit claire, l’exemple ci-dessus doit plutôt être écrit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-400">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="36a0b-401">Ce code va maintenant être compilé, mais l’exécution de `X<int>.F(7)` lèvera une exception au moment de l’exécution, car un `int` boxed ne peut pas être converti directement en `long`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-401">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="36a0b-402">Conversions explicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="36a0b-402">User-defined explicit conversions</span></span>

<span data-ttu-id="36a0b-403">Une conversion explicite définie par l’utilisateur se compose d’une conversion explicite standard facultative, suivie de l’exécution d’un opérateur de conversion implicite ou explicite défini par l’utilisateur, puis d’une autre conversion explicite standard facultative.</span><span class="sxs-lookup"><span data-stu-id="36a0b-403">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="36a0b-404">Les règles exactes d’évaluation des conversions explicites définies par l’utilisateur sont décrites dans [traitement des conversions explicites définies par l’utilisateur](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="36a0b-404">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="36a0b-405">Conversions standard</span><span class="sxs-lookup"><span data-stu-id="36a0b-405">Standard conversions</span></span>

<span data-ttu-id="36a0b-406">Les conversions standard sont les conversions prédéfinies qui peuvent se produire dans le cadre d’une conversion définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-406">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="36a0b-407">Conversions implicites standard</span><span class="sxs-lookup"><span data-stu-id="36a0b-407">Standard implicit conversions</span></span>

<span data-ttu-id="36a0b-408">Les conversions implicites suivantes sont classées comme conversions implicites standard :</span><span class="sxs-lookup"><span data-stu-id="36a0b-408">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="36a0b-409">Conversions d’identité ([conversion d’identité](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="36a0b-409">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="36a0b-410">Conversions numériques implicites ([conversions numériques implicites](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="36a0b-410">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="36a0b-411">Conversions Nullable implicites ([conversions Nullable implicites](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="36a0b-411">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="36a0b-412">Conversions de référence implicites ([conversions de référence implicites](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="36a0b-412">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="36a0b-413">Conversions boxing ([conversions boxing](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="36a0b-413">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="36a0b-414">Conversions d’expressions constantes implicites ([conversions dynamiques implicites](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="36a0b-414">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="36a0b-415">Conversions implicites impliquant des paramètres de type ([conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="36a0b-415">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="36a0b-416">Les conversions implicites standard excluent spécifiquement les conversions implicites définies par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-416">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="36a0b-417">Conversions explicites standard</span><span class="sxs-lookup"><span data-stu-id="36a0b-417">Standard explicit conversions</span></span>

<span data-ttu-id="36a0b-418">Les conversions explicites standard sont toutes des conversions implicites standard, ainsi que le sous-ensemble des conversions explicites pour lesquelles il existe une conversion implicite standard opposée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-418">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="36a0b-419">En d’autres termes, s’il existe une conversion implicite standard d’un type `A` à un type `B`, une conversion explicite standard existe à partir du type `A` en type `B` et du type `B` au type `A`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-419">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="36a0b-420">Conversions définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="36a0b-420">User-defined conversions</span></span>

<span data-ttu-id="36a0b-421">C#permet aux conversions implicites et explicites prédéfinies d’être complétées par les ***conversions définies***par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-421">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="36a0b-422">Les conversions définies par l’utilisateur sont introduites par la déclaration d’opérateurs de conversion ([opérateurs de conversion](classes.md#conversion-operators)) dans les types classe et struct.</span><span class="sxs-lookup"><span data-stu-id="36a0b-422">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="36a0b-423">Conversions définies par l’utilisateur autorisées</span><span class="sxs-lookup"><span data-stu-id="36a0b-423">Permitted user-defined conversions</span></span>

<span data-ttu-id="36a0b-424">C#autorise uniquement la déclaration de certaines conversions définies par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-424">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="36a0b-425">En particulier, il n’est pas possible de redéfinir une conversion implicite ou explicite existante.</span><span class="sxs-lookup"><span data-stu-id="36a0b-425">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="36a0b-426">Pour un type de source donné `S` et le type de cible `T`, si `S` ou `T` sont des types Nullable, laissez `S0` et `T0` faire référence à leurs types sous-jacents, sinon `S0` et `T0` sont égaux à `S` et `T` respectivement.</span><span class="sxs-lookup"><span data-stu-id="36a0b-426">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="36a0b-427">Une classe ou un struct est autorisé à déclarer une conversion d’un type source `S` en un type cible `T` uniquement si toutes les conditions suivantes sont vraies :</span><span class="sxs-lookup"><span data-stu-id="36a0b-427">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="36a0b-428">`S0` et `T0` sont des types différents.</span><span class="sxs-lookup"><span data-stu-id="36a0b-428">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="36a0b-429">`S0` ou `T0` est le type de classe ou de struct dans lequel la déclaration d’opérateur a lieu.</span><span class="sxs-lookup"><span data-stu-id="36a0b-429">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="36a0b-430">Ni `S0` ni `T0` n’est un *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="36a0b-430">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="36a0b-431">En excluant les conversions définies par l’utilisateur, il n’existe pas de conversion de `S` à `T` ou de `T` à `S`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-431">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="36a0b-432">Les restrictions qui s’appliquent aux conversions définies par l’utilisateur sont abordées plus en détail dans [opérateurs de conversion](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="36a0b-432">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="36a0b-433">Opérateurs de conversion levés</span><span class="sxs-lookup"><span data-stu-id="36a0b-433">Lifted conversion operators</span></span>

<span data-ttu-id="36a0b-434">Dans le cas d’un opérateur de conversion défini par l’utilisateur qui convertit un type valeur n’acceptant pas les valeurs NULL `S` en un type valeur n’acceptant pas les valeurs NULL `T`, il existe un ***opérateur de conversion levé*** qui convertit de `S?` en `T?`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-434">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="36a0b-435">Cet opérateur de conversion levé effectue un désencapsulage de `S?` à `S` suivi de la conversion définie par l’utilisateur de `S` à `T` suivi d’un renvoi de `T` à `T?`, sauf qu’une valeur null `S?` convertit directement en `T?`valeur null.</span><span class="sxs-lookup"><span data-stu-id="36a0b-435">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="36a0b-436">Un opérateur de conversion levé a la même classification implicite ou explicite que son opérateur de conversion défini par l’utilisateur sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="36a0b-436">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="36a0b-437">Le terme « conversion définie par l’utilisateur » s’applique à l’utilisation des opérateurs de conversion levés et définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-437">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="36a0b-438">Évaluation des conversions définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="36a0b-438">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="36a0b-439">Une conversion définie par l’utilisateur convertit une valeur de son type, appelée ***type source***, en un autre type, appelé le ***type cible***.</span><span class="sxs-lookup"><span data-stu-id="36a0b-439">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="36a0b-440">Évaluation d’un centre de conversion défini par l’utilisateur sur la recherche de l’opérateur de conversion défini par l’utilisateur le ***plus spécifique*** pour les types source et cible particuliers.</span><span class="sxs-lookup"><span data-stu-id="36a0b-440">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="36a0b-441">Cette détermination est divisée en plusieurs étapes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-441">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="36a0b-442">Recherche de l’ensemble de classes et de structures à partir desquelles les opérateurs de conversion définis par l’utilisateur seront pris en compte.</span><span class="sxs-lookup"><span data-stu-id="36a0b-442">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="36a0b-443">Cet ensemble se compose du type de source et de ses classes de base, ainsi que du type cible et de ses classes de base (avec les hypothèses implicites que seules les classes et les structs peuvent déclarer des opérateurs définis par l’utilisateur, et que les types non-classes n’ont pas de classes de base).</span><span class="sxs-lookup"><span data-stu-id="36a0b-443">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="36a0b-444">Dans le cadre de cette étape, si le type source ou cible est un *nullable_type*, le type sous-jacent est utilisé à la place.</span><span class="sxs-lookup"><span data-stu-id="36a0b-444">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="36a0b-445">À partir de cet ensemble de types, déterminer quels opérateurs de conversion définis par l’utilisateur et levés sont applicables.</span><span class="sxs-lookup"><span data-stu-id="36a0b-445">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="36a0b-446">Pour qu’un opérateur de conversion soit applicable, il doit être possible d’effectuer une conversion standard ([conversions standard](conversions.md#standard-conversions)) du type source en type d’opérande de l’opérateur, et il doit être possible d’effectuer une conversion standard du type de résultat de l’opérateur vers le type cible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-446">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="36a0b-447">À partir de l’ensemble des opérateurs définis par l’utilisateur applicables, en déterminant quel opérateur est sans ambiguïté le plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="36a0b-447">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="36a0b-448">En règle générale, l’opérateur le plus spécifique est l’opérateur dont le type d’opérande est « le plus proche » du type source et dont le type de résultat est « le plus proche » du type cible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-448">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="36a0b-449">Les opérateurs de conversion définis par l’utilisateur sont préférés aux opérateurs de conversion levés.</span><span class="sxs-lookup"><span data-stu-id="36a0b-449">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="36a0b-450">Les règles exactes pour l’établissement de l’opérateur de conversion défini par l’utilisateur le plus spécifique sont définies dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="36a0b-450">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="36a0b-451">Une fois qu’un opérateur de conversion défini par l’utilisateur le plus spécifique a été identifié, l’exécution réelle de la conversion définie par l’utilisateur implique jusqu’à trois étapes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-451">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="36a0b-452">Tout d’abord, si nécessaire, en effectuant une conversion standard du type source vers le type d’opérande de l’opérateur de conversion défini par l’utilisateur ou levé.</span><span class="sxs-lookup"><span data-stu-id="36a0b-452">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="36a0b-453">Ensuite, appelez l’opérateur de conversion défini par l’utilisateur ou levé pour effectuer la conversion.</span><span class="sxs-lookup"><span data-stu-id="36a0b-453">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="36a0b-454">Enfin, si nécessaire, effectuer une conversion standard du type de résultat de l’opérateur de conversion défini par l’utilisateur ou levé vers le type cible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-454">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="36a0b-455">L’évaluation d’une conversion définie par l’utilisateur n’implique jamais plus d’un opérateur de conversion défini par l’utilisateur ou levé.</span><span class="sxs-lookup"><span data-stu-id="36a0b-455">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="36a0b-456">En d’autres termes, une conversion du type `S` en type `T` n’exécute jamais d’abord une conversion définie par l’utilisateur de `S` en `X`, puis exécute une conversion définie par l’utilisateur de `X` à `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-456">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="36a0b-457">Les définitions exactes de l’évaluation des conversions implicites ou explicites définies par l’utilisateur sont indiquées dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="36a0b-457">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="36a0b-458">Les définitions utilisent les termes suivants :</span><span class="sxs-lookup"><span data-stu-id="36a0b-458">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="36a0b-459">Si une conversion implicite standard ([conversions implicites standard](conversions.md#standard-implicit-conversions)) existe à partir d’un type `A` à un type `B`, et si ni `A`, ni `B` ne sont *interface_type*s, `A` est supposé être ***englobé par*** `B`, et `B` est dit ***englober*** `A`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-459">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="36a0b-460">Le ***type le plus englobant*** dans un ensemble de types est celui qui englobe tous les autres types dans le jeu.</span><span class="sxs-lookup"><span data-stu-id="36a0b-460">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="36a0b-461">Si aucun type unique n’englobe tous les autres types, le jeu n’a pas de type englobant le plus.</span><span class="sxs-lookup"><span data-stu-id="36a0b-461">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="36a0b-462">En termes plus intuitifs, le type le plus englobant est le plus grand type dans l’ensemble, à savoir le type dans lequel chacun des autres types peut être converti implicitement.</span><span class="sxs-lookup"><span data-stu-id="36a0b-462">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="36a0b-463">Le ***type le plus englobé*** dans un ensemble de types est celui qui est englobé par tous les autres types dans le jeu.</span><span class="sxs-lookup"><span data-stu-id="36a0b-463">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="36a0b-464">Si aucun type unique n’est englobé par tous les autres types, le jeu n’a pas de type le plus englobé.</span><span class="sxs-lookup"><span data-stu-id="36a0b-464">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="36a0b-465">En termes plus intuitifs, le type le plus englobé est le type le plus petit dans le jeu, le type qui peut être converti implicitement en chacun des autres types.</span><span class="sxs-lookup"><span data-stu-id="36a0b-465">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="36a0b-466">Traitement des conversions implicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="36a0b-466">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="36a0b-467">Une conversion implicite définie par l’utilisateur de type `S` en type `T` est traitée comme suit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-467">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="36a0b-468">Déterminez les types `S0` et `T0`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-468">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="36a0b-469">Si `S` ou `T` sont des types Nullable, `S0` et `T0` sont leurs types sous-jacents, sinon `S0` et `T0` sont égaux à `S` et `T` respectivement.</span><span class="sxs-lookup"><span data-stu-id="36a0b-469">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="36a0b-470">Recherchez l’ensemble de types, `D`, à partir duquel les opérateurs de conversion définis par l’utilisateur seront pris en compte.</span><span class="sxs-lookup"><span data-stu-id="36a0b-470">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="36a0b-471">Cet ensemble se compose d' `S0` (si `S0` est une classe ou un struct), des classes de base de `S0` (si `S0` est une classe) et `T0` (si `T0` est une classe ou un struct).</span><span class="sxs-lookup"><span data-stu-id="36a0b-471">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="36a0b-472">Recherchez l’ensemble des opérateurs de conversion démontés et définis par l’utilisateur applicables, `U`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-472">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="36a0b-473">Cet ensemble se compose des opérateurs de conversion implicite définis par l’utilisateur et levés déclarés par les classes ou les structs dans `D` qui convertissent un type englobant `S` en un type englobé par `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-473">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="36a0b-474">Si `U` est vide, la conversion n’est pas définie et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-474">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-475">Recherchez le type de source le plus spécifique, `SX`, des opérateurs dans `U`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-475">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="36a0b-476">Si l’un des opérateurs de `U` convertir à partir d' `S`, `SX` est `S`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-476">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="36a0b-477">Dans le cas contraire, `SX` est le type le plus englobé dans l’ensemble combiné des types de sources des opérateurs dans `U`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-477">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="36a0b-478">Si exactement un type le plus englobé est introuvable, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-478">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-479">Recherchez le type de cible le plus spécifique, `TX`, des opérateurs dans `U`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-479">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="36a0b-480">Si l’un des opérateurs de `U` convertir en `T`, `TX` est `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-480">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="36a0b-481">Dans le cas contraire, `TX` est le type le plus englobant dans l’ensemble combiné des types cibles des opérateurs dans `U`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-481">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="36a0b-482">Si un seul type englobant est introuvable, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-482">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-483">Recherchez l’opérateur de conversion le plus spécifique :</span><span class="sxs-lookup"><span data-stu-id="36a0b-483">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="36a0b-484">Si `U` contient exactement un opérateur de conversion défini par l’utilisateur qui effectue la conversion de `SX` en `TX`, il s’agit de l’opérateur de conversion le plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="36a0b-484">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="36a0b-485">Sinon, si `U` contient exactement un opérateur de conversion levé qui convertit de `SX` en `TX`, il s’agit de l’opérateur de conversion le plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="36a0b-485">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="36a0b-486">Dans le cas contraire, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-486">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-487">Enfin, appliquez la conversion :</span><span class="sxs-lookup"><span data-stu-id="36a0b-487">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="36a0b-488">Si `S` n’est pas `SX`, une conversion implicite standard de `S` en `SX` est effectuée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-488">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="36a0b-489">L’opérateur de conversion le plus spécifique est appelé pour convertir `SX` en `TX`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-489">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="36a0b-490">Si `TX` n’est pas `T`, une conversion implicite standard de `TX` en `T` est effectuée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-490">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="36a0b-491">Traitement des conversions explicites définies par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="36a0b-491">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="36a0b-492">Une conversion explicite définie par l’utilisateur du type `S` en type `T` est traitée comme suit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-492">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="36a0b-493">Déterminez les types `S0` et `T0`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-493">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="36a0b-494">Si `S` ou `T` sont des types Nullable, `S0` et `T0` sont leurs types sous-jacents, sinon `S0` et `T0` sont égaux à `S` et `T` respectivement.</span><span class="sxs-lookup"><span data-stu-id="36a0b-494">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="36a0b-495">Recherchez l’ensemble de types, `D`, à partir duquel les opérateurs de conversion définis par l’utilisateur seront pris en compte.</span><span class="sxs-lookup"><span data-stu-id="36a0b-495">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="36a0b-496">Cet ensemble se compose d' `S0` (si `S0` est une classe ou un struct), des classes de base de `S0` (si `S0` est une classe), d' `T0` (si `T0` est une classe ou un struct) et des classes de base de `T0` (si `T0` est une classe).</span><span class="sxs-lookup"><span data-stu-id="36a0b-496">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="36a0b-497">Recherchez l’ensemble des opérateurs de conversion démontés et définis par l’utilisateur applicables, `U`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-497">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="36a0b-498">Cet ensemble se compose des opérateurs de conversion implicite ou explicite définis par l’utilisateur déclarés par les classes ou les structs dans `D` qui effectuent une conversion à partir d’un type englobant ou englobé par `S` à un type englobant ou englobé par `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-498">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="36a0b-499">Si `U` est vide, la conversion n’est pas définie et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-499">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-500">Recherchez le type de source le plus spécifique, `SX`, des opérateurs dans `U`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-500">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="36a0b-501">Si l’un des opérateurs de `U` convertir à partir d' `S`, `SX` est `S`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-501">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="36a0b-502">Sinon, si l’un des opérateurs de `U` convertir des types qui englobent `S`, `SX` est le type le plus englobé dans l’ensemble combiné des types de sources de ces opérateurs.</span><span class="sxs-lookup"><span data-stu-id="36a0b-502">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="36a0b-503">Si aucun type englobant le plus n’est trouvé, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-503">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="36a0b-504">Dans le cas contraire, `SX` est le type le plus englobant dans l’ensemble combiné des types de sources des opérateurs dans `U`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-504">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="36a0b-505">Si un seul type englobant est introuvable, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-505">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-506">Recherchez le type de cible le plus spécifique, `TX`, des opérateurs dans `U`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-506">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="36a0b-507">Si l’un des opérateurs de `U` convertir en `T`, `TX` est `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-507">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="36a0b-508">Sinon, si l’un des opérateurs de `U` convertir en types qui sont entourés par `T`, `TX` est le type le plus englobant dans l’ensemble combiné de types cibles de ces opérateurs.</span><span class="sxs-lookup"><span data-stu-id="36a0b-508">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="36a0b-509">Si un seul type englobant est introuvable, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-509">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="36a0b-510">Dans le cas contraire, `TX` est le type le plus englobé dans l’ensemble combiné de types cibles des opérateurs dans `U`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-510">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="36a0b-511">Si aucun type englobant le plus n’est trouvé, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-511">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-512">Recherchez l’opérateur de conversion le plus spécifique :</span><span class="sxs-lookup"><span data-stu-id="36a0b-512">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="36a0b-513">Si `U` contient exactement un opérateur de conversion défini par l’utilisateur qui effectue la conversion de `SX` en `TX`, il s’agit de l’opérateur de conversion le plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="36a0b-513">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="36a0b-514">Sinon, si `U` contient exactement un opérateur de conversion levé qui convertit de `SX` en `TX`, il s’agit de l’opérateur de conversion le plus spécifique.</span><span class="sxs-lookup"><span data-stu-id="36a0b-514">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="36a0b-515">Dans le cas contraire, la conversion est ambiguë et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-515">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-516">Enfin, appliquez la conversion :</span><span class="sxs-lookup"><span data-stu-id="36a0b-516">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="36a0b-517">Si `S` n’est pas `SX`, une conversion explicite standard de `S` en `SX` est effectuée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-517">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="36a0b-518">L’opérateur de conversion défini par l’utilisateur le plus spécifique est appelé pour convertir des `SX` en `TX`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-518">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="36a0b-519">Si `TX` n’est pas `T`, une conversion explicite standard de `TX` en `T` est effectuée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-519">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="36a0b-520">Conversions de fonctions anonymes</span><span class="sxs-lookup"><span data-stu-id="36a0b-520">Anonymous function conversions</span></span>

<span data-ttu-id="36a0b-521">Un *anonymous_method_expression* ou *lambda_expression* est classé comme une fonction anonyme ([expressions de fonction anonymes](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-521">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="36a0b-522">L’expression n’a pas de type mais peut être convertie implicitement en un type délégué compatible ou un type d’arborescence d’expression.</span><span class="sxs-lookup"><span data-stu-id="36a0b-522">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="36a0b-523">Plus précisément, une fonction anonyme `F` est compatible avec un type délégué `D` fourni :</span><span class="sxs-lookup"><span data-stu-id="36a0b-523">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="36a0b-524">Si `F` contient une *anonymous_function_signature*, `D` et `F` ont le même nombre de paramètres.</span><span class="sxs-lookup"><span data-stu-id="36a0b-524">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="36a0b-525">Si `F` ne contient pas de *anonymous_function_signature*, `D` peut avoir zéro, un ou plusieurs paramètres de tout type, à condition qu’aucun paramètre de `D` n’ait le modificateur de paramètre `out`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-525">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="36a0b-526">Si `F` contient une liste de paramètres explicitement typée, chaque paramètre dans `D` a les mêmes type et modificateurs que le paramètre correspondant dans `F`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-526">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="36a0b-527">Si `F` contient une liste de paramètres typée implicitement, `D` n’a pas de paramètres `ref` ou `out`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-527">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="36a0b-528">Si le corps de `F` est une expression et que `D` a un type de retour `void` ou `F` est Async et `D` a le type de retour `Task`, alors, lorsque chaque paramètre de `F` reçoit le type du paramètre correspondant dans `D`, le corps de `F` est une expression valide (les [expressions](expressions.md)WRT) qui serait autorisée en tant que *statement_expression* ([instructions d’expression](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-528">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="36a0b-529">Si le corps de `F` est un bloc d’instructions et `D` a un type de retour `void` ou `F` est Async et `D` a le type de retour `Task`, alors, lorsque chaque paramètre de `F` reçoit le type du paramètre correspondant dans `D`, le corps de `F` est un bloc d’instruction valide ( [blocs](statements.md#blocks)WRT) dans lequel aucune instruction `return` spécifie une expression.</span><span class="sxs-lookup"><span data-stu-id="36a0b-529">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="36a0b-530">Si le corps de `F` est une expression et que *`F` est non asynchrone et `D`* a un type de retour non void `T`, *ou* `F` est Async et `D` a un type de retour `Task<T>`, alors, lorsque chaque paramètre de `F` reçoit le type du paramètre correspondant dans `D`, le corps de `F` est une expression valide ( [expressions](expressions.md)WRT) qui est implicitement convertible en `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-530">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="36a0b-531">Si le corps de `F` est un bloc d’instructions et *que `F` est non asynchrone et `D`* a un type de retour non void `T`, *ou* `F` est Async et `D` a un type de retour `Task<T>`, alors, lorsque chaque paramètre de `F` reçoit le type du paramètre correspondant dans `D`, le corps de `F` est un bloc d’instructions valide ( [blocs](statements.md#blocks)WRT) avec un point de terminaison non accessible dans lequel chaque instruction `return` spécifie une expression implicitement convertible en `T`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-531">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="36a0b-532">Pour des raisons de concision, cette section utilise la forme abrégée pour les types de tâches `Task` et `Task<T>` ([fonctions Async](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-532">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="36a0b-533">Une expression lambda `F` est compatible avec un type d’arborescence d’expression `Expression<D>` si `F` est compatible avec le type délégué `D`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-533">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="36a0b-534">Notez que cela ne s’applique pas aux méthodes anonymes, mais uniquement aux expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="36a0b-534">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="36a0b-535">Certaines expressions lambda ne peuvent pas être converties en types d’arborescence d’expression : bien que la conversion *existe*, elle échoue au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="36a0b-535">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="36a0b-536">C’est le cas si l’expression lambda :</span><span class="sxs-lookup"><span data-stu-id="36a0b-536">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="36a0b-537">A un corps de *bloc*</span><span class="sxs-lookup"><span data-stu-id="36a0b-537">Has a *block* body</span></span>
*  <span data-ttu-id="36a0b-538">Contient des opérateurs d’assignation simples ou composés</span><span class="sxs-lookup"><span data-stu-id="36a0b-538">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="36a0b-539">Contient une expression liée dynamiquement</span><span class="sxs-lookup"><span data-stu-id="36a0b-539">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="36a0b-540">Est asynchrone</span><span class="sxs-lookup"><span data-stu-id="36a0b-540">Is async</span></span>

<span data-ttu-id="36a0b-541">Les exemples qui suivent utilisent un type délégué générique `Func<A,R>` qui représente une fonction qui accepte un argument de type `A` et retourne une valeur de type `R`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-541">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="36a0b-542">Dans les affectations</span><span class="sxs-lookup"><span data-stu-id="36a0b-542">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="36a0b-543">le paramètre et les types de retour de chaque fonction anonyme sont déterminés à partir du type de la variable à laquelle la fonction anonyme est assignée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-543">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="36a0b-544">La première assignation convertit correctement la fonction anonyme en type délégué `Func<int,int>` car, lorsque `x` reçoit le type `int`, `x+1` est une expression valide qui est implicitement convertible en type `int`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-544">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="36a0b-545">De même, la deuxième assignation convertit correctement la fonction anonyme en type délégué `Func<int,double>`, car le résultat de `x+1` (de type `int`) est implicitement convertible en type `double`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-545">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="36a0b-546">Toutefois, la troisième assignation est une erreur au moment de la compilation, car, lorsque `x` est donné à un type `double`, le résultat de `x+1` (de type `double`) n’est pas implicitement convertible en type `int`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-546">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="36a0b-547">La quatrième assignation convertit correctement la fonction Async anonyme en type délégué `Func<int, Task<int>>`, car le résultat de `x+1` (de type `int`) est implicitement convertible en type de résultat `int` du type de tâche `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-547">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="36a0b-548">Les fonctions anonymes peuvent influencer la résolution de surcharge et participer à l’inférence de type.</span><span class="sxs-lookup"><span data-stu-id="36a0b-548">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="36a0b-549">Pour plus d’informations, consultez [membres de fonction](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="36a0b-549">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="36a0b-550">Évaluation de conversions de fonctions anonymes en types délégués</span><span class="sxs-lookup"><span data-stu-id="36a0b-550">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="36a0b-551">La conversion d’une fonction anonyme en type délégué produit une instance de délégué qui fait référence à la fonction anonyme et au jeu (éventuellement vide) des variables externes capturées qui sont actives au moment de l’évaluation.</span><span class="sxs-lookup"><span data-stu-id="36a0b-551">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="36a0b-552">Lorsque le délégué est appelé, le corps de la fonction anonyme est exécuté.</span><span class="sxs-lookup"><span data-stu-id="36a0b-552">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="36a0b-553">Le code du corps est exécuté à l’aide de l’ensemble des variables externes capturées référencées par le délégué.</span><span class="sxs-lookup"><span data-stu-id="36a0b-553">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="36a0b-554">La liste d’appel d’un délégué produit à partir d’une fonction anonyme contient une seule entrée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-554">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="36a0b-555">L’objet cible et la méthode cible exacts du délégué ne sont pas spécifiés.</span><span class="sxs-lookup"><span data-stu-id="36a0b-555">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="36a0b-556">En particulier, il n’est pas spécifié si l’objet cible du délégué est `null`, la valeur `this` du membre de fonction englobant ou un autre objet.</span><span class="sxs-lookup"><span data-stu-id="36a0b-556">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="36a0b-557">Les conversions de fonctions anonymes sémantiquement identiques avec le même ensemble (éventuellement vide) d’instances de variable externe capturées vers les mêmes types délégués sont autorisées (mais pas obligatoires) pour retourner la même instance de délégué.</span><span class="sxs-lookup"><span data-stu-id="36a0b-557">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="36a0b-558">Le terme sémantiquement identique est utilisé ici pour signifier que l’exécution des fonctions anonymes produira, dans tous les cas, les mêmes effets en raison des mêmes arguments.</span><span class="sxs-lookup"><span data-stu-id="36a0b-558">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="36a0b-559">Cette règle permet d’optimiser le code tel que le suivant.</span><span class="sxs-lookup"><span data-stu-id="36a0b-559">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="36a0b-560">Étant donné que les deux délégués de fonction anonymes ont le même ensemble (vide) de variables externes capturées, et puisque les fonctions anonymes sont sémantiquement identiques, le compilateur est autorisé à faire en sorte que les délégués fassent référence à la même méthode cible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-560">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="36a0b-561">En effet, le compilateur est autorisé à retourner la même instance de délégué à partir des deux expressions de fonction anonymes.</span><span class="sxs-lookup"><span data-stu-id="36a0b-561">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="36a0b-562">Évaluation de conversions de fonctions anonymes en types d’arborescences d’expression</span><span class="sxs-lookup"><span data-stu-id="36a0b-562">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="36a0b-563">La conversion d’une fonction anonyme en un type d’arborescence d’expression produit une arborescence d’expression ([types d’arborescence d’expression](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-563">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="36a0b-564">Plus précisément, l’évaluation de la conversion de fonction anonyme provoque la construction d’une structure d’objet qui représente la structure de la fonction anonyme elle-même.</span><span class="sxs-lookup"><span data-stu-id="36a0b-564">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="36a0b-565">La structure précise de l’arborescence de l’expression, ainsi que le processus exact de création de celle-ci, sont définis par l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="36a0b-565">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="36a0b-566">Exemple d'implémentation</span><span class="sxs-lookup"><span data-stu-id="36a0b-566">Implementation example</span></span>

<span data-ttu-id="36a0b-567">Cette section décrit une implémentation possible de conversions de fonctions anonymes en termes C# d’autres constructions.</span><span class="sxs-lookup"><span data-stu-id="36a0b-567">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="36a0b-568">L’implémentation décrite ici est basée sur les mêmes principes que ceux utilisés par C# le compilateur Microsoft, mais il ne s’agit pas d’une implémentation forcée, ni de la seule possibilité.</span><span class="sxs-lookup"><span data-stu-id="36a0b-568">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="36a0b-569">Il mentionne brièvement les conversions vers les arborescences d’expressions, car leur sémantique exacte ne se situe pas dans le cadre de cette spécification.</span><span class="sxs-lookup"><span data-stu-id="36a0b-569">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="36a0b-570">Le reste de cette section fournit plusieurs exemples de code qui contient des fonctions anonymes avec différentes caractéristiques.</span><span class="sxs-lookup"><span data-stu-id="36a0b-570">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="36a0b-571">Pour chaque exemple, une traduction correspondante vers du code qui utilise uniquement C# d’autres constructions est fournie.</span><span class="sxs-lookup"><span data-stu-id="36a0b-571">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="36a0b-572">Dans les exemples, l’identificateur `D` est supposé par représenter le type délégué suivant :</span><span class="sxs-lookup"><span data-stu-id="36a0b-572">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="36a0b-573">La forme la plus simple d’une fonction anonyme est celle qui ne capture aucune variable externe :</span><span class="sxs-lookup"><span data-stu-id="36a0b-573">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="36a0b-574">Il peut être traduit en une instanciation de délégué qui fait référence à une méthode statique générée par le compilateur dans laquelle le code de la fonction anonyme est placé :</span><span class="sxs-lookup"><span data-stu-id="36a0b-574">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="36a0b-575">Dans l’exemple suivant, la fonction anonyme fait référence aux membres d’instance de `this`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-575">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="36a0b-576">Il peut être traduit en une méthode d’instance générée par le compilateur contenant le code de la fonction anonyme :</span><span class="sxs-lookup"><span data-stu-id="36a0b-576">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="36a0b-577">Dans cet exemple, la fonction anonyme capture une variable locale :</span><span class="sxs-lookup"><span data-stu-id="36a0b-577">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="36a0b-578">La durée de vie de la variable locale doit maintenant être étendue à au moins la durée de vie du délégué de fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="36a0b-578">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="36a0b-579">Cela peut être obtenu en « délevage » la variable locale dans un champ d’une classe générée par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-579">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="36a0b-580">L’instanciation de la variable locale ([instanciation de variables locales](expressions.md#instantiation-of-local-variables)) correspond ensuite à la création d’une instance de la classe générée par le compilateur, et l’accès à la variable locale correspond à l’accès à un champ dans l’instance de la classe générée par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-580">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="36a0b-581">En outre, la fonction anonyme devient une méthode d’instance de la classe générée par le compilateur :</span><span class="sxs-lookup"><span data-stu-id="36a0b-581">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="36a0b-582">Enfin, la fonction anonyme suivante capture `this` ainsi que deux variables locales avec des durées de vie différentes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-582">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="36a0b-583">Ici, une classe générée par le compilateur est créée pour chaque bloc d’instructions dans lequel les variables locales sont capturées, de sorte que les variables locales dans les différents blocs peuvent avoir des durées de vie indépendantes.</span><span class="sxs-lookup"><span data-stu-id="36a0b-583">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="36a0b-584">Une instance de `__Locals2`, la classe générée par le compilateur pour le bloc d’instructions interne, contient la variable locale `z` et un champ qui fait référence à une instance de `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-584">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="36a0b-585">Une instance de `__Locals1`, la classe générée par le compilateur pour le bloc d’instructions externe, contient la variable locale `y` et un champ qui référence `this` du membre de fonction englobant.</span><span class="sxs-lookup"><span data-stu-id="36a0b-585">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="36a0b-586">Avec ces structures de données, il est possible d’atteindre toutes les variables externes capturées par le biais d’une instance de `__Local2`, et le code de la fonction anonyme peut donc être implémenté comme une méthode d’instance de cette classe.</span><span class="sxs-lookup"><span data-stu-id="36a0b-586">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="36a0b-587">La même technique appliquée ici pour capturer les variables locales peut également être utilisée lors de la conversion de fonctions anonymes en arborescences d’expressions : les références aux objets générés par le compilateur peuvent être stockées dans l’arborescence de l’expression, et l’accès aux variables locales peut être représentés en tant qu’accès au champ sur ces objets.</span><span class="sxs-lookup"><span data-stu-id="36a0b-587">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="36a0b-588">L’avantage de cette approche est qu’elle permet aux variables locales « levées » d’être partagées entre les délégués et les arborescences d’expressions.</span><span class="sxs-lookup"><span data-stu-id="36a0b-588">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="36a0b-589">Conversions de groupe de méthodes</span><span class="sxs-lookup"><span data-stu-id="36a0b-589">Method group conversions</span></span>

<span data-ttu-id="36a0b-590">Une conversion implicite ([conversions implicites](conversions.md#implicit-conversions)) existe d’un groupe de méthodes ([classifications d’expressions](expressions.md#expression-classifications)) en un type délégué compatible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-590">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="36a0b-591">Pour un type délégué `D` et une expression `E` classée comme un groupe de méthodes, une conversion implicite existe de `E` en `D` si `E` contient au moins une méthode applicable dans sa forme normale ([fonction membre applicable](expressions.md#applicable-function-member)) à une liste d’arguments construite à l’aide des types de paramètres et des modificateurs de `D`, comme décrit dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="36a0b-591">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="36a0b-592">L’application de compilation d’une conversion d’un groupe de méthodes `E` à un type délégué `D` est décrite dans ce qui suit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-592">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="36a0b-593">Notez que l’existence d’une conversion implicite de `E` en `D` ne garantit pas que l’application de compilation de la conversion échouera sans erreur.</span><span class="sxs-lookup"><span data-stu-id="36a0b-593">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="36a0b-594">Une seule méthode `M` est sélectionnée correspondant à un appel de méthode ([appel de méthode](expressions.md#method-invocations)) de la forme `E(A)`, avec les modifications suivantes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-594">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="36a0b-595">La liste d’arguments `A` est une liste d’expressions, chacune classée en tant que variable et avec le type et le modificateur (`ref` ou `out`) du paramètre correspondant dans la *formal_parameter_list* de `D`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-595">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="36a0b-596">Les méthodes candidates prises en compte sont uniquement celles qui sont applicables dans leur forme normale ([fonction membre applicable](expressions.md#applicable-function-member)), et non celles qui s’appliquent uniquement dans leur forme développée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-596">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="36a0b-597">Si l’algorithme d' [appels de méthode](expressions.md#method-invocations) génère une erreur, une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-597">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="36a0b-598">Dans le cas contraire, l’algorithme produit une seule meilleure méthode `M` avoir le même nombre de paramètres que `D` et la conversion est considérée comme existante.</span><span class="sxs-lookup"><span data-stu-id="36a0b-598">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="36a0b-599">La méthode sélectionnée `M` doit être compatible ([déléguer la compatibilité](delegates.md#delegate-compatibility)) avec le type délégué `D`ou, dans le cas contraire, une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="36a0b-599">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="36a0b-600">Si la méthode sélectionnée `M` est une méthode d’instance, l’expression d’instance associée à `E` détermine l’objet cible du délégué.</span><span class="sxs-lookup"><span data-stu-id="36a0b-600">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="36a0b-601">Si la méthode sélectionnée M est une méthode d’extension qui est indiquée au moyen d’un accès de membre sur une expression d’instance, cette expression de l’instance détermine l’objet cible du délégué.</span><span class="sxs-lookup"><span data-stu-id="36a0b-601">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="36a0b-602">Le résultat de la conversion est une valeur de type `D`, à savoir un délégué nouvellement créé qui fait référence à la méthode et à l’objet cible sélectionnés.</span><span class="sxs-lookup"><span data-stu-id="36a0b-602">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="36a0b-603">Notez que ce processus peut mener à la création d’un délégué à une méthode d’extension, si l’algorithme d' [appels de méthode](expressions.md#method-invocations) ne parvient pas à trouver une méthode d’instance mais réussit à traiter l’appel de `E(A)` en tant qu’appel de méthode d’extension ([appels de méthode d’extension](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="36a0b-603">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="36a0b-604">Un délégué ainsi créé capture la méthode d’extension ainsi que son premier argument.</span><span class="sxs-lookup"><span data-stu-id="36a0b-604">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="36a0b-605">L’exemple suivant illustre les conversions de groupe de méthodes :</span><span class="sxs-lookup"><span data-stu-id="36a0b-605">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="36a0b-606">L’assignation à `d1` convertit implicitement le groupe de méthodes `F` en une valeur de type `D1`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-606">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="36a0b-607">L’assignation à `d2` montre comment il est possible de créer un délégué vers une méthode qui a des types de paramètres moins dérivés (contravariant) et un type de retour plus dérivé (covariant).</span><span class="sxs-lookup"><span data-stu-id="36a0b-607">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="36a0b-608">L’assignation à `d3` montre comment aucune conversion n’existe si la méthode n’est pas applicable.</span><span class="sxs-lookup"><span data-stu-id="36a0b-608">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="36a0b-609">L’assignation à `d4` montre comment la méthode doit être applicable dans sa forme normale.</span><span class="sxs-lookup"><span data-stu-id="36a0b-609">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="36a0b-610">L’assignation à `d5` montre comment les types de paramètres et de retour du délégué et de la méthode sont autorisés à différer uniquement pour les types référence.</span><span class="sxs-lookup"><span data-stu-id="36a0b-610">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="36a0b-611">Comme avec toutes les autres conversions implicites et explicites, l’opérateur de cast peut être utilisé pour effectuer explicitement une conversion de groupe de méthodes.</span><span class="sxs-lookup"><span data-stu-id="36a0b-611">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="36a0b-612">Ainsi, l’exemple</span><span class="sxs-lookup"><span data-stu-id="36a0b-612">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="36a0b-613">à la place, il est possible d’écrire</span><span class="sxs-lookup"><span data-stu-id="36a0b-613">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="36a0b-614">Les groupes de méthodes peuvent influencer la résolution de surcharge et participer à l’inférence de type.</span><span class="sxs-lookup"><span data-stu-id="36a0b-614">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="36a0b-615">Pour plus d’informations, consultez [membres de fonction](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="36a0b-615">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="36a0b-616">L’évaluation au moment de l’exécution d’une conversion de groupe de méthodes se déroule comme suit :</span><span class="sxs-lookup"><span data-stu-id="36a0b-616">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="36a0b-617">Si la méthode sélectionnée au moment de la compilation est une méthode d’instance, ou s’il s’agit d’une méthode d’extension accessible en tant que méthode d’instance, l’objet cible du délégué est déterminé à partir de l’expression d’instance associée à `E`:</span><span class="sxs-lookup"><span data-stu-id="36a0b-617">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="36a0b-618">L’expression d’instance est évaluée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-618">The instance expression is evaluated.</span></span> <span data-ttu-id="36a0b-619">Si cette évaluation provoque une exception, aucune autre étape n’est exécutée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-619">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="36a0b-620">Si l’expression d’instance est d’un *reference_type*, la valeur calculée par l’expression d’instance devient l’objet cible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-620">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="36a0b-621">Si la méthode sélectionnée est une méthode d’instance et que l’objet cible est `null`, un `System.NullReferenceException` est levé et aucune autre étape n’est exécutée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-621">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="36a0b-622">Si l’expression d’instance est d’un *Value_type*, une opération boxing ([conversions boxing](types.md#boxing-conversions)) est effectuée pour convertir la valeur en objet, et cet objet devient l’objet cible.</span><span class="sxs-lookup"><span data-stu-id="36a0b-622">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="36a0b-623">Sinon, la méthode sélectionnée fait partie d’un appel de méthode statique, et l’objet cible du délégué est `null`.</span><span class="sxs-lookup"><span data-stu-id="36a0b-623">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="36a0b-624">Une nouvelle instance du type délégué `D` est allouée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-624">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="36a0b-625">Si la mémoire disponible est insuffisante pour allouer la nouvelle instance, une `System.OutOfMemoryException` est levée et aucune autre étape n’est exécutée.</span><span class="sxs-lookup"><span data-stu-id="36a0b-625">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="36a0b-626">La nouvelle instance de délégué est initialisée avec une référence à la méthode qui a été déterminée au moment de la compilation et une référence à l’objet cible calculé ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="36a0b-626">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
