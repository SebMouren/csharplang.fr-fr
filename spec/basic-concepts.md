---
ms.openlocfilehash: ff31585520c9090ad92893a930327112743c8e77
ms.sourcegitcommit: 892af9016b3317a8fae12d195014dc38ba51cf16
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/01/2019
ms.locfileid: "71704005"
---
# <a name="basic-concepts"></a><span data-ttu-id="4f071-101">Concepts de base</span><span class="sxs-lookup"><span data-stu-id="4f071-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="4f071-102">Démarrage de l'application</span><span class="sxs-lookup"><span data-stu-id="4f071-102">Application Startup</span></span>

<span data-ttu-id="4f071-103">Un assembly qui a un ***point d’entrée*** est appelé ***application***.</span><span class="sxs-lookup"><span data-stu-id="4f071-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="4f071-104">Lorsqu’une application est exécutée, un nouveau ***domaine d’application*** est créé.</span><span class="sxs-lookup"><span data-stu-id="4f071-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="4f071-105">Plusieurs instanciations différentes d’une application peuvent exister sur le même ordinateur en même temps et chacune possède son propre domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="4f071-106">Un domaine d’application permet l’isolation d’applications en jouant le rôle d’un conteneur pour l’état de l’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="4f071-107">Un domaine d’application agit comme un conteneur et une limite pour les types définis dans l’application et les bibliothèques de classes qu’il utilise.</span><span class="sxs-lookup"><span data-stu-id="4f071-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="4f071-108">Les types chargés dans un domaine d’application sont différents du même type chargé dans un autre domaine d’application, et les instances d’objets ne sont pas directement partagées entre les domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="4f071-109">Par exemple, chaque domaine d’application possède sa propre copie de variables statiques pour ces types, et un constructeur statique pour un type est exécuté au plus une fois par domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="4f071-110">Les implémentations sont gratuites pour fournir une stratégie ou des mécanismes spécifiques à l’implémentation pour la création et la destruction de domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="4f071-111">Le démarrage de l' ***application*** se produit lorsque l’environnement d’exécution appelle une méthode désignée, appelée point d’entrée de l’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="4f071-112">Cette méthode de point d’entrée est toujours nommée `Main` et peut avoir l’une des signatures suivantes :</span><span class="sxs-lookup"><span data-stu-id="4f071-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="4f071-113">Comme indiqué, le point d’entrée peut éventuellement retourner une valeur `int`.</span><span class="sxs-lookup"><span data-stu-id="4f071-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="4f071-114">Cette valeur de retour est utilisée dans l’arrêt de l’application (arrêt de l'[application](basic-concepts.md#application-termination)).</span><span class="sxs-lookup"><span data-stu-id="4f071-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="4f071-115">Le point d’entrée peut éventuellement avoir un paramètre formel.</span><span class="sxs-lookup"><span data-stu-id="4f071-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="4f071-116">Le paramètre peut avoir n’importe quel nom, mais le type du paramètre doit être `string[]`.</span><span class="sxs-lookup"><span data-stu-id="4f071-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="4f071-117">Si le paramètre formel est présent, l’environnement d’exécution crée et passe un argument `string[]` contenant les arguments de ligne de commande spécifiés au démarrage de l’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="4f071-118">L’argument `string[]` n’est jamais null, mais peut avoir une longueur de zéro si aucun argument de ligne de commande n’a été spécifié.</span><span class="sxs-lookup"><span data-stu-id="4f071-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="4f071-119">Étant C# donné que prend en charge la surcharge de méthode, une classe ou un struct peut contenir plusieurs définitions d’une méthode, à condition que chacune ait une signature différente.</span><span class="sxs-lookup"><span data-stu-id="4f071-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="4f071-120">Toutefois, au sein d’un même programme, aucune classe ou aucun struct ne peut contenir plusieurs méthodes appelées `Main` dont la définition la qualifie à utiliser comme point d’entrée de l’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="4f071-121">Toutefois, d’autres versions surchargées de `Main` sont autorisées, à condition qu’elles aient plusieurs paramètres, ou que leur seul paramètre soit autre que le type `string[]`.</span><span class="sxs-lookup"><span data-stu-id="4f071-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="4f071-122">Une application peut être composée de plusieurs classes ou structures.</span><span class="sxs-lookup"><span data-stu-id="4f071-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="4f071-123">Il est possible que plus d’une de ces classes ou structures contiennent une méthode appelée `Main` dont la définition la qualifie à utiliser comme point d’entrée de l’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="4f071-124">Dans ce cas, un mécanisme externe (tel qu’une option du compilateur de ligne de commande) doit être utilisé pour sélectionner l’une de ces méthodes `Main` comme point d’entrée.</span><span class="sxs-lookup"><span data-stu-id="4f071-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="4f071-125">Dans C#, chaque méthode doit être définie en tant que membre d’une classe ou d’un struct.</span><span class="sxs-lookup"><span data-stu-id="4f071-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="4f071-126">En règle générale, l’accessibilité déclarée ([accessibilité déclarée](basic-concepts.md#declared-accessibility)) d’une méthode est déterminée par les modificateurs d’accès ([modificateurs d’accès](classes.md#access-modifiers)) spécifiés dans sa déclaration, et de la même façon, l’accessibilité déclarée d’un type est déterminée par le modificateurs d’accès spécifiés dans sa déclaration.</span><span class="sxs-lookup"><span data-stu-id="4f071-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="4f071-127">Pour qu’une méthode donnée d’un type donné puisse être appelée, le type et le membre doivent être accessibles.</span><span class="sxs-lookup"><span data-stu-id="4f071-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="4f071-128">Toutefois, le point d’entrée de l’application est un cas particulier.</span><span class="sxs-lookup"><span data-stu-id="4f071-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="4f071-129">Plus précisément, l’environnement d’exécution peut accéder au point d’entrée de l’application, quelle que soit l’accessibilité déclarée et indépendamment de l’accessibilité déclarée de ses déclarations de type englobant.</span><span class="sxs-lookup"><span data-stu-id="4f071-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="4f071-130">La méthode de point d’entrée de l’application ne peut pas figurer dans une déclaration de classe générique.</span><span class="sxs-lookup"><span data-stu-id="4f071-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="4f071-131">Dans tous les autres aspects, les méthodes de point d’entrée se comportent comme celles qui ne sont pas des points d’entrée.</span><span class="sxs-lookup"><span data-stu-id="4f071-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="4f071-132">Arrêt de l’application</span><span class="sxs-lookup"><span data-stu-id="4f071-132">Application termination</span></span>

<span data-ttu-id="4f071-133">L’arrêt de l' ***application*** retourne le contrôle à l’environnement d’exécution.</span><span class="sxs-lookup"><span data-stu-id="4f071-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="4f071-134">Si le type de retour de la méthode de ***point d’entrée*** de l’application est `int`, la valeur retournée fait office de code d’état d' ***arrêt***de l’application.</span><span class="sxs-lookup"><span data-stu-id="4f071-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="4f071-135">L’objectif de ce code est de permettre la communication de la réussite ou de l’échec à l’environnement d’exécution.</span><span class="sxs-lookup"><span data-stu-id="4f071-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="4f071-136">Si le type de retour de la méthode de point d’entrée est `void`, l’atteinte de l’accolade fermante (`}`) qui termine cette méthode, ou l’exécution d’une instruction `return` qui n’a aucune expression, aboutit à un code d’état d’arrêt de `0`.</span><span class="sxs-lookup"><span data-stu-id="4f071-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="4f071-137">Avant l’arrêt d’une application, les destructeurs de tous ses objets qui n’ont pas encore été récupérés par le garbage collector sont appelés, à moins que ce nettoyage ait été supprimé (par un appel à la méthode de la bibliothèque `GC.SuppressFinalize`, par exemple).</span><span class="sxs-lookup"><span data-stu-id="4f071-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="4f071-138">Déclarations</span><span class="sxs-lookup"><span data-stu-id="4f071-138">Declarations</span></span>

<span data-ttu-id="4f071-139">Les déclarations d' C# un programme définissent les éléments constitutifs du programme.</span><span class="sxs-lookup"><span data-stu-id="4f071-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="4f071-140">C#les programmes sont organisés à l’aide d’espaces de noms ([espaces de noms](namespaces.md)), qui peuvent contenir des déclarations de type et des déclarations d’espaces de noms imbriqués.</span><span class="sxs-lookup"><span data-stu-id="4f071-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="4f071-141">Les déclarations de type ([déclarations de type](namespaces.md#type-declarations)) sont utilisées pour définir des classes ([classes](classes.md)), des structures ([structs](structs.md)), des interfaces ([interfaces](interfaces.md)), des enums ([énumérations](enums.md)) et des délégués ([délégués](delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="4f071-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="4f071-142">Les genres de membres autorisés dans une déclaration de type dépendent de la forme de la déclaration de type.</span><span class="sxs-lookup"><span data-stu-id="4f071-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="4f071-143">Par exemple, les déclarations de classe peuvent contenir des déclarations pour les constantes ([constantes](classes.md#constants)), les champs ([champs](classes.md#fields)), les méthodes ([méthodes](classes.md#methods)), les propriétés ([Propriétés](classes.md#properties)), les événements ([événements](classes.md#events)), les indexeurs ([indexeurs](classes.md#indexers)), opérateurs ([opérateurs](classes.md#operators)), constructeurs d’instance ([constructeurs d’instance](classes.md#instance-constructors)), constructeurs statiques ([constructeurs statiques](classes.md#static-constructors)), destructeurs ([destructeurs](classes.md#destructors)) et types imbriqués ([types imbriqués](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="4f071-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="4f071-144">Une déclaration définit un nom dans l' ***espace de déclaration*** auquel la déclaration appartient.</span><span class="sxs-lookup"><span data-stu-id="4f071-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="4f071-145">À l’exception des membres surchargés ([signatures et surcharge](basic-concepts.md#signatures-and-overloading)), il s’agit d’une erreur au moment de la compilation d’avoir au moins deux déclarations qui introduisent des membres portant le même nom dans un espace de déclaration.</span><span class="sxs-lookup"><span data-stu-id="4f071-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="4f071-146">Il n’est jamais possible pour un espace de déclaration de contenir différents genres de membres portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="4f071-147">Par exemple, un espace de déclaration ne peut jamais contenir un champ et une méthode du même nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="4f071-148">Il existe différents types d’espaces de déclaration, comme décrit dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="4f071-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="4f071-149">Dans tous les fichiers sources d’un programme, *namespace_member_declaration*sans *namespace_declaration* englobant sont membres d’un espace de déclaration combiné unique, appelé ***espace de déclaration global***.</span><span class="sxs-lookup"><span data-stu-id="4f071-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="4f071-150">Dans tous les fichiers sources d’un programme, les *namespace_member_declaration*dans *namespace_declaration*s qui ont le même nom d’espace de noms complet sont membres d’un espace de déclaration combiné unique.</span><span class="sxs-lookup"><span data-stu-id="4f071-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="4f071-151">Chaque déclaration de classe, de struct ou d’interface crée un nouvel espace de déclaration.</span><span class="sxs-lookup"><span data-stu-id="4f071-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="4f071-152">Les noms sont introduits dans cet espace de déclaration via *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s ou *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4f071-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="4f071-153">Sauf pour les déclarations de constructeur d’instance surchargé et les déclarations de constructeur statiques, une classe ou un struct ne peut pas contenir une déclaration de membre portant le même nom que la classe ou le struct.</span><span class="sxs-lookup"><span data-stu-id="4f071-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="4f071-154">Une classe, un struct ou une interface autorise la déclaration de méthodes surchargées et d’indexeurs.</span><span class="sxs-lookup"><span data-stu-id="4f071-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="4f071-155">En outre, une classe ou un struct autorise la déclaration de constructeurs et d’opérateurs d’instance surchargés.</span><span class="sxs-lookup"><span data-stu-id="4f071-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="4f071-156">Par exemple, une classe, un struct ou une interface peut contenir plusieurs déclarations de méthode portant le même nom, à condition que ces déclarations de méthode diffèrent dans leur signature ([signatures et surcharge](basic-concepts.md#signatures-and-overloading)).</span><span class="sxs-lookup"><span data-stu-id="4f071-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="4f071-157">Notez que les classes de base ne contribuent pas à l’espace de déclaration d’une classe et que les interfaces de base ne contribuent pas à l’espace de déclaration d’une interface.</span><span class="sxs-lookup"><span data-stu-id="4f071-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="4f071-158">Ainsi, une classe ou une interface dérivée est autorisée à déclarer un membre portant le même nom qu’un membre hérité.</span><span class="sxs-lookup"><span data-stu-id="4f071-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="4f071-159">Ce membre est dit de ***Masquer*** le membre hérité.</span><span class="sxs-lookup"><span data-stu-id="4f071-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="4f071-160">Chaque déclaration Delegate crée un nouvel espace de déclaration.</span><span class="sxs-lookup"><span data-stu-id="4f071-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="4f071-161">Les noms sont introduits dans cet espace de déclaration via des paramètres formels (*fixed_parameter*s et *parameter_array*s) et *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4f071-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="4f071-162">Chaque déclaration d’énumération crée un nouvel espace de déclaration.</span><span class="sxs-lookup"><span data-stu-id="4f071-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="4f071-163">Les noms sont introduits dans cet espace de déclaration par le biais de *enum_member_declarations*.</span><span class="sxs-lookup"><span data-stu-id="4f071-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="4f071-164">Chaque déclaration de méthode, déclaration d’indexeur, déclaration d’opérateur, déclaration de constructeur d’instance et fonction anonyme crée un espace de déclaration appelé ***espace de déclaration de variable locale***.</span><span class="sxs-lookup"><span data-stu-id="4f071-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="4f071-165">Les noms sont introduits dans cet espace de déclaration via des paramètres formels (*fixed_parameter*s et *parameter_array*s) et *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4f071-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="4f071-166">Le corps de la fonction membre ou de la fonction anonyme, le cas échéant, est considéré comme imbriqué dans l’espace de déclaration de la variable locale.</span><span class="sxs-lookup"><span data-stu-id="4f071-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="4f071-167">Il s’agit d’une erreur pour un espace de déclaration de variable locale et un espace de déclaration de variable locale imbriqué pour contenir des éléments portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="4f071-168">Ainsi, dans un espace de déclaration imbriqué, il n’est pas possible de déclarer une variable locale ou une constante portant le même nom qu’une variable locale ou une constante dans un espace de déclaration englobant.</span><span class="sxs-lookup"><span data-stu-id="4f071-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="4f071-169">Il est possible que deux espaces de déclaration contiennent des éléments portant le même nom, à condition que l’espace de déclaration ne contienne pas l’autre.</span><span class="sxs-lookup"><span data-stu-id="4f071-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="4f071-170">Chaque *bloc* ou *switch_block* , ainsi qu’une instruction *for*, *foreach* et *using* , crée un espace de déclaration de variable locale pour les variables locales et les constantes locales.</span><span class="sxs-lookup"><span data-stu-id="4f071-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="4f071-171">Les noms sont introduits dans cet espace de déclaration par le biais de *local_variable_declaration*s et *local_constant_declaration*s.</span><span class="sxs-lookup"><span data-stu-id="4f071-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="4f071-172">Notez que les blocs qui se produisent en tant que ou dans le corps d’un membre de fonction ou d’une fonction anonyme sont imbriqués dans l’espace de déclaration de variable locale déclaré par ces fonctions pour leurs paramètres.</span><span class="sxs-lookup"><span data-stu-id="4f071-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="4f071-173">Par conséquent, il s’agit d’une erreur d’avoir une méthode avec une variable locale et un paramètre du même nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="4f071-174">Chaque *bloc* ou *switch_block* crée un espace de déclaration distinct pour les étiquettes.</span><span class="sxs-lookup"><span data-stu-id="4f071-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="4f071-175">Les noms sont introduits dans cet espace de déclaration par le biais de *labeled_statement*s et les noms sont référencés par le biais de *goto_statement*s.</span><span class="sxs-lookup"><span data-stu-id="4f071-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="4f071-176">L' ***espace de déclaration d’étiquette*** d’un bloc comprend tous les blocs imbriqués.</span><span class="sxs-lookup"><span data-stu-id="4f071-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="4f071-177">Ainsi, dans un bloc imbriqué, il n’est pas possible de déclarer une étiquette portant le même nom qu’une étiquette dans un bloc englobant.</span><span class="sxs-lookup"><span data-stu-id="4f071-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="4f071-178">L’ordre textuel dans lequel les noms sont déclarés n’a généralement pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="4f071-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="4f071-179">En particulier, l’ordre textuel n’est pas significatif pour la déclaration et l’utilisation des espaces de noms, des constantes, des méthodes, des propriétés, des événements, des indexeurs, des opérateurs, des constructeurs d’instance, des destructeurs, des constructeurs statiques et des types.</span><span class="sxs-lookup"><span data-stu-id="4f071-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="4f071-180">L’ordre de déclaration est significatif des manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="4f071-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="4f071-181">L’ordre de déclaration pour les déclarations de champ et les déclarations de variable locale détermine l’ordre dans lequel leurs initialiseurs (le cas échéant) sont exécutés.</span><span class="sxs-lookup"><span data-stu-id="4f071-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="4f071-182">Les variables locales doivent être définies avant d’être utilisées ([étendues](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="4f071-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="4f071-183">L’ordre de déclaration pour les déclarations de membre enum ([membres enum](enums.md#enum-members)) est significatif lorsque les valeurs *constant_expression* sont omises.</span><span class="sxs-lookup"><span data-stu-id="4f071-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="4f071-184">L’espace de déclaration d’un espace de noms est « Open Closed » et deux déclarations d’espaces de noms portant le même nom qualifié complet participent au même espace de déclaration.</span><span class="sxs-lookup"><span data-stu-id="4f071-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="4f071-185">Exemple :</span><span class="sxs-lookup"><span data-stu-id="4f071-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="4f071-186">Les deux déclarations d’espaces de noms ci-dessus contribuent au même espace de déclaration, dans ce cas, en déclarant deux classes avec les noms qualifiés complets `Megacorp.Data.Customer` et `Megacorp.Data.Order`.</span><span class="sxs-lookup"><span data-stu-id="4f071-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="4f071-187">Étant donné que les deux déclarations contribuent au même espace de déclaration, elles auraient provoqué une erreur au moment de la compilation si chacune contient une déclaration d’une classe portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="4f071-188">Comme indiqué ci-dessus, l’espace de déclaration d’un bloc comprend tous les blocs imbriqués.</span><span class="sxs-lookup"><span data-stu-id="4f071-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="4f071-189">Ainsi, dans l’exemple suivant, les méthodes `F` et `G` provoquent une erreur au moment de la compilation, car le nom `i` est déclaré dans le bloc externe et ne peut pas être redéclaré dans le bloc interne.</span><span class="sxs-lookup"><span data-stu-id="4f071-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="4f071-190">Toutefois, les méthodes `H` et `I` sont valides, car les deux `i` sont déclarées dans des blocs non imbriqués distincts.</span><span class="sxs-lookup"><span data-stu-id="4f071-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="4f071-191">Membres</span><span class="sxs-lookup"><span data-stu-id="4f071-191">Members</span></span>

<span data-ttu-id="4f071-192">Les espaces de noms et les types ont des ***membres***.</span><span class="sxs-lookup"><span data-stu-id="4f071-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="4f071-193">Les membres d’une entité sont généralement disponibles à l’aide d’un nom qualifié qui commence par une référence à l’entité, suivi d’un jeton « `.` », suivi du nom du membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="4f071-194">Les membres d’un type sont déclarés dans la déclaration de type ou ***hérités*** de la classe de base du type.</span><span class="sxs-lookup"><span data-stu-id="4f071-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="4f071-195">Lorsqu’un type hérite d’une classe de base, tous les membres de la classe de base, à l’exception des constructeurs d’instance, des destructeurs et des constructeurs statiques, deviennent membres du type dérivé.</span><span class="sxs-lookup"><span data-stu-id="4f071-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="4f071-196">L’accessibilité déclarée d’un membre de classe de base ne contrôle pas si le membre est hérité ; l’héritage s’étend à tout membre qui n’est pas un constructeur d’instance, un constructeur statique ou un destructeur.</span><span class="sxs-lookup"><span data-stu-id="4f071-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="4f071-197">Toutefois, un membre hérité peut ne pas être accessible dans un type dérivé, soit en raison de son accessibilité déclarée ([accessibilité déclarée](basic-concepts.md#declared-accessibility)), soit parce qu’il est masqué par une déclaration dans le type lui-même ([masquage par héritage](basic-concepts.md#hiding-through-inheritance)).</span><span class="sxs-lookup"><span data-stu-id="4f071-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="4f071-198">Membres d’espace de noms</span><span class="sxs-lookup"><span data-stu-id="4f071-198">Namespace members</span></span>

<span data-ttu-id="4f071-199">Les espaces de noms et les types qui n’ont pas d’espace de noms englobant sont membres de l' ***espace de noms global***.</span><span class="sxs-lookup"><span data-stu-id="4f071-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="4f071-200">Cela correspond directement aux noms déclarés dans l’espace de déclaration globale.</span><span class="sxs-lookup"><span data-stu-id="4f071-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="4f071-201">Les espaces de noms et les types déclarés dans un espace de noms sont membres de cet espace de noms.</span><span class="sxs-lookup"><span data-stu-id="4f071-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="4f071-202">Cela correspond directement aux noms déclarés dans l’espace de déclaration de l’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="4f071-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="4f071-203">Les espaces de noms ne présentent aucune limitation d’accès.</span><span class="sxs-lookup"><span data-stu-id="4f071-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="4f071-204">Il n’est pas possible de déclarer des espaces de noms privés, protégés ou internes, et les noms d’espaces de noms sont toujours accessibles publiquement.</span><span class="sxs-lookup"><span data-stu-id="4f071-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="4f071-205">Membres de struct</span><span class="sxs-lookup"><span data-stu-id="4f071-205">Struct members</span></span>

<span data-ttu-id="4f071-206">Les membres d’un struct sont les membres déclarés dans le struct et les membres hérités de la classe de base directe du struct `System.ValueType` et la classe de base indirecte `object`.</span><span class="sxs-lookup"><span data-stu-id="4f071-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="4f071-207">Les membres d’un type simple correspondent directement aux membres du type struct dont le type est simple :</span><span class="sxs-lookup"><span data-stu-id="4f071-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="4f071-208">Les membres de `sbyte` sont les membres de la structure `System.SByte`.</span><span class="sxs-lookup"><span data-stu-id="4f071-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="4f071-209">Les membres de `byte` sont les membres de la structure `System.Byte`.</span><span class="sxs-lookup"><span data-stu-id="4f071-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="4f071-210">Les membres de `short` sont les membres de la structure `System.Int16`.</span><span class="sxs-lookup"><span data-stu-id="4f071-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="4f071-211">Les membres de `ushort` sont les membres de la structure `System.UInt16`.</span><span class="sxs-lookup"><span data-stu-id="4f071-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="4f071-212">Les membres de `int` sont les membres de la structure `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="4f071-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="4f071-213">Les membres de `uint` sont les membres de la structure `System.UInt32`.</span><span class="sxs-lookup"><span data-stu-id="4f071-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="4f071-214">Les membres de `long` sont les membres de la structure `System.Int64`.</span><span class="sxs-lookup"><span data-stu-id="4f071-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="4f071-215">Les membres de `ulong` sont les membres de la structure `System.UInt64`.</span><span class="sxs-lookup"><span data-stu-id="4f071-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="4f071-216">Les membres de `char` sont les membres de la structure `System.Char`.</span><span class="sxs-lookup"><span data-stu-id="4f071-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="4f071-217">Les membres de `float` sont les membres de la structure `System.Single`.</span><span class="sxs-lookup"><span data-stu-id="4f071-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="4f071-218">Les membres de `double` sont les membres de la structure `System.Double`.</span><span class="sxs-lookup"><span data-stu-id="4f071-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="4f071-219">Les membres de `decimal` sont les membres de la structure `System.Decimal`.</span><span class="sxs-lookup"><span data-stu-id="4f071-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="4f071-220">Les membres de `bool` sont les membres de la structure `System.Boolean`.</span><span class="sxs-lookup"><span data-stu-id="4f071-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="4f071-221">Membres de l’énumération</span><span class="sxs-lookup"><span data-stu-id="4f071-221">Enumeration members</span></span>

<span data-ttu-id="4f071-222">Les membres d’une énumération sont les constantes déclarées dans l’énumération et les membres hérités de la classe de base directe de l’énumération `System.Enum` et les classes de base indirectes `System.ValueType` et `object`.</span><span class="sxs-lookup"><span data-stu-id="4f071-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="4f071-223">Membres de classe</span><span class="sxs-lookup"><span data-stu-id="4f071-223">Class members</span></span>

<span data-ttu-id="4f071-224">Les membres d’une classe sont les membres déclarés dans la classe et les membres hérités de la classe de base (à l’exception de la classe `object` qui n’a pas de classe de base).</span><span class="sxs-lookup"><span data-stu-id="4f071-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="4f071-225">Les membres hérités de la classe de base incluent les constantes, les champs, les méthodes, les propriétés, les événements, les indexeurs, les opérateurs et les types de la classe de base, mais pas les constructeurs d’instance, les destructeurs et les constructeurs statiques de la classe de base.</span><span class="sxs-lookup"><span data-stu-id="4f071-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="4f071-226">Les membres de la classe de base sont hérités sans tenir compte de leur accessibilité.</span><span class="sxs-lookup"><span data-stu-id="4f071-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="4f071-227">Une déclaration de classe peut contenir des déclarations de constantes, des champs, des méthodes, des propriétés, des événements, des indexeurs, des opérateurs, des constructeurs d’instance, des destructeurs, des constructeurs statiques et des types.</span><span class="sxs-lookup"><span data-stu-id="4f071-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="4f071-228">Les membres de `object` et `string` correspondent directement aux membres des types de classe qu’ils aliasent :</span><span class="sxs-lookup"><span data-stu-id="4f071-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="4f071-229">Les membres de `object` sont les membres de la classe `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="4f071-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="4f071-230">Les membres de `string` sont les membres de la classe `System.String`.</span><span class="sxs-lookup"><span data-stu-id="4f071-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="4f071-231">Membres d’interface</span><span class="sxs-lookup"><span data-stu-id="4f071-231">Interface members</span></span>

<span data-ttu-id="4f071-232">Les membres d’une interface sont les membres déclarés dans l’interface et dans toutes les interfaces de base de l’interface.</span><span class="sxs-lookup"><span data-stu-id="4f071-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="4f071-233">Les membres de la classe `object` ne sont pas, strictement parlants, des membres de toute interface ([membres d’interface](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="4f071-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="4f071-234">Toutefois, les membres de la classe `object` sont disponibles via la recherche de membres dans n’importe quel type d’interface ([recherche de membre](expressions.md#member-lookup)).</span><span class="sxs-lookup"><span data-stu-id="4f071-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="4f071-235">Membres du tableau</span><span class="sxs-lookup"><span data-stu-id="4f071-235">Array members</span></span>

<span data-ttu-id="4f071-236">Les membres d’un tableau sont les membres hérités de la classe `System.Array`.</span><span class="sxs-lookup"><span data-stu-id="4f071-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="4f071-237">Membres délégués</span><span class="sxs-lookup"><span data-stu-id="4f071-237">Delegate members</span></span>

<span data-ttu-id="4f071-238">Les membres d’un délégué sont les membres hérités de la classe `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="4f071-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="4f071-239">Accès au membre</span><span class="sxs-lookup"><span data-stu-id="4f071-239">Member access</span></span>

<span data-ttu-id="4f071-240">Les déclarations de membres permettent de contrôler l’accès aux membres.</span><span class="sxs-lookup"><span data-stu-id="4f071-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="4f071-241">L’accessibilité d’un membre est établie par l’accessibilité déclarée ([accessibilité déclarée](basic-concepts.md#declared-accessibility)) du membre combiné avec l’accessibilité du type conteneur immédiatement, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="4f071-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="4f071-242">Lorsque l’accès à un membre particulier est autorisé, le membre est dit ***accessible***.</span><span class="sxs-lookup"><span data-stu-id="4f071-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="4f071-243">Inversement, lorsque l’accès à un membre particulier n’est pas autorisé, le membre est dit ***inaccessible***.</span><span class="sxs-lookup"><span data-stu-id="4f071-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="4f071-244">L’accès à un membre est autorisé lorsque l’emplacement du texte dans lequel l’accès a lieu est inclus dans le domaine d’accessibilité ([domaines d’accessibilité](basic-concepts.md#accessibility-domains)) du membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="4f071-245">Accessibilité déclarée</span><span class="sxs-lookup"><span data-stu-id="4f071-245">Declared accessibility</span></span>

<span data-ttu-id="4f071-246">L' ***accessibilité déclarée*** d’un membre peut être l’une des suivantes :</span><span class="sxs-lookup"><span data-stu-id="4f071-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="4f071-247">Public, qui est sélectionné en incluant un modificateur `public` dans la déclaration de membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="4f071-248">La signification intuitive de `public` est « accès non limité ».</span><span class="sxs-lookup"><span data-stu-id="4f071-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="4f071-249">Protégé, qui est sélectionné en incluant un modificateur `protected` dans la déclaration de membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="4f071-250">La signification intuitive de `protected` est « l’accès est limité à la classe conteneur ou aux types dérivés de la classe conteneur ».</span><span class="sxs-lookup"><span data-stu-id="4f071-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="4f071-251">Interne, qui est sélectionné en incluant un modificateur `internal` dans la déclaration de membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="4f071-252">La signification intuitive de `internal` est « accès limité à ce programme ».</span><span class="sxs-lookup"><span data-stu-id="4f071-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="4f071-253">Protected internal (c’est-à-dire protected ou Internal), qui est sélectionné en incluant à la fois un modificateur `protected` et un modificateur `internal` dans la déclaration de membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="4f071-254">La signification intuitive de `protected internal` est « accès limité à ce programme ou aux types dérivés de la classe conteneur ».</span><span class="sxs-lookup"><span data-stu-id="4f071-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="4f071-255">Privé, qui est sélectionné en incluant un modificateur `private` dans la déclaration de membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="4f071-256">La signification intuitive de `private` est « accès limité au type conteneur ».</span><span class="sxs-lookup"><span data-stu-id="4f071-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="4f071-257">En fonction du contexte dans lequel la déclaration d’un membre a lieu, seuls certains types d’accessibilité déclarés sont autorisés.</span><span class="sxs-lookup"><span data-stu-id="4f071-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="4f071-258">En outre, lorsqu’une déclaration de membre n’inclut pas de modificateur d’accès, le contexte dans lequel la déclaration a lieu détermine l’accessibilité déclarée par défaut.</span><span class="sxs-lookup"><span data-stu-id="4f071-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="4f071-259">Les espaces de noms ont implicitement `public` l’accessibilité déclarée.</span><span class="sxs-lookup"><span data-stu-id="4f071-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4f071-260">Aucun modificateur d’accès n’est autorisé sur les déclarations d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="4f071-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="4f071-261">Les types déclarés dans les unités de compilation ou les espaces de noms peuvent avoir l’accessibilité déclarée `public` ou `internal` et la valeur par défaut `internal` l’accessibilité déclarée.</span><span class="sxs-lookup"><span data-stu-id="4f071-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="4f071-262">Les membres de classe peuvent avoir l’un des cinq types d’accessibilité déclarés et la valeur par défaut à `private` l’accessibilité déclarée.</span><span class="sxs-lookup"><span data-stu-id="4f071-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="4f071-263">(Notez qu’un type déclaré en tant que membre d’une classe peut avoir l’un des cinq types d’accessibilité déclarés, alors qu’un type déclaré en tant que membre d’un espace de noms ne peut avoir que l’accessibilité déclarée `public` ou `internal`.)</span><span class="sxs-lookup"><span data-stu-id="4f071-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="4f071-264">Les membres de struct peuvent avoir l’accessibilité déclarée `public`, `internal` ou `private`, et la valeur par défaut `private` l’accessibilité déclarée, car les structs sont implicitement sealed.</span><span class="sxs-lookup"><span data-stu-id="4f071-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="4f071-265">Les membres de struct introduits dans un struct (autrement dit, qui n’est pas hérité par ce struct) ne peuvent pas avoir l’accessibilité déclarée `protected` ou `protected internal`.</span><span class="sxs-lookup"><span data-stu-id="4f071-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="4f071-266">(Notez qu’un type déclaré en tant que membre d’un struct peut avoir l’accessibilité déclarée `public`, `internal` ou `private`, alors qu’un type déclaré en tant que membre d’un espace de noms ne peut avoir qu’une accessibilité `public` ou `internal`.)</span><span class="sxs-lookup"><span data-stu-id="4f071-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="4f071-267">Les membres d’interface ont implicitement `public` l’accessibilité déclarée.</span><span class="sxs-lookup"><span data-stu-id="4f071-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4f071-268">Aucun modificateur d’accès n’est autorisé sur les déclarations de membres d’interface.</span><span class="sxs-lookup"><span data-stu-id="4f071-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="4f071-269">Les membres de l’énumération ont implicitement `public` l’accessibilité déclarée.</span><span class="sxs-lookup"><span data-stu-id="4f071-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4f071-270">Aucun modificateur d’accès n’est autorisé sur les déclarations de membre d’énumération.</span><span class="sxs-lookup"><span data-stu-id="4f071-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="4f071-271">Domaines d’accessibilité</span><span class="sxs-lookup"><span data-stu-id="4f071-271">Accessibility domains</span></span>

<span data-ttu-id="4f071-272">Le ***domaine d’accessibilité*** d’un membre se compose des sections (éventuellement disjointes) du texte de programme dans lesquelles l’accès au membre est autorisé.</span><span class="sxs-lookup"><span data-stu-id="4f071-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="4f071-273">Dans le cadre de la définition du domaine d’accessibilité d’un membre, un membre est dit comme étant de ***niveau supérieur*** s’il n’est pas déclaré dans un type, et un membre est dit ***imbriqué*** s’il est déclaré dans un autre type.</span><span class="sxs-lookup"><span data-stu-id="4f071-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="4f071-274">En outre, le ***texte de programme*** d’un programme est défini comme tout le texte de programme contenu dans tous les fichiers sources du programme, et le texte de programme d’un type est défini comme tout le texte de programme contenu dans le *type_declaration*s de ce type (y compris, éventuellement, les types imbriqués dans le type).</span><span class="sxs-lookup"><span data-stu-id="4f071-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="4f071-275">Le domaine d’accessibilité d’un type prédéfini (tel que `object`, `int` ou `double`) est illimité.</span><span class="sxs-lookup"><span data-stu-id="4f071-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="4f071-276">Le domaine d’accessibilité d’un type indépendant de niveau supérieur `T` ([types liés et indépendants](types.md#bound-and-unbound-types)) qui est déclaré dans un programme `P` est défini comme suit :</span><span class="sxs-lookup"><span data-stu-id="4f071-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="4f071-277">Si l’accessibilité déclarée de `T` est `public`, le domaine d’accessibilité de `T` est le texte de programme de `P` et tout programme qui référence `P`.</span><span class="sxs-lookup"><span data-stu-id="4f071-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="4f071-278">Si l'accessibilité déclarée de `T` est `internal`, le domaine d'accessibilité de `T` correspond au texte de programme de `P`.</span><span class="sxs-lookup"><span data-stu-id="4f071-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="4f071-279">À partir de ces définitions, il en résulte que le domaine d’accessibilité d’un type indépendant de niveau supérieur est toujours au moins le texte de programme du programme dans lequel ce type est déclaré.</span><span class="sxs-lookup"><span data-stu-id="4f071-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="4f071-280">Le domaine d’accessibilité d’un type construit `T<A1, ..., An>` est l’intersection du domaine d’accessibilité du type générique indépendant `T` et les domaines d’accessibilité des arguments de type `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="4f071-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="4f071-281">Le domaine d’accessibilité d’un membre imbriqué `M` déclaré dans un type `T` dans un programme `P` est défini comme suit (Notez que `M` lui-même peut être un type) :</span><span class="sxs-lookup"><span data-stu-id="4f071-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="4f071-282">Si l'accessibilité déclarée de `M` est `public`, le domaine d'accessibilité de `M` correspond à celui de `T`.</span><span class="sxs-lookup"><span data-stu-id="4f071-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="4f071-283">Si l’accessibilité déclarée de `M` est `protected internal`, laissez `D` être l’Union du texte de programme de `P` et le texte de programme de tout type dérivé de `T`, déclaré en dehors de `P`.</span><span class="sxs-lookup"><span data-stu-id="4f071-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="4f071-284">Le domaine d’accessibilité de `M` correspond à l’intersection du domaine d’accessibilité de `T` avec `D`.</span><span class="sxs-lookup"><span data-stu-id="4f071-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="4f071-285">Si l’accessibilité déclarée de `M` est `protected`, laissez `D` être l’Union du texte de programme de `T` et le texte de programme de n’importe quel type dérivé de `T`.</span><span class="sxs-lookup"><span data-stu-id="4f071-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="4f071-286">Le domaine d’accessibilité de `M` correspond à l’intersection du domaine d’accessibilité de `T` avec `D`.</span><span class="sxs-lookup"><span data-stu-id="4f071-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="4f071-287">Si l'accessibilité déclarée de `M` est `internal`, le domaine d'accessibilité de `M` correspond à l'intersection du domaine d'accessibilité de `T` avec le texte de programme de `P`.</span><span class="sxs-lookup"><span data-stu-id="4f071-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="4f071-288">Si l'accessibilité déclarée de `M` est `private`, le domaine d'accessibilité de `M` correspond au texte de programme de `T`.</span><span class="sxs-lookup"><span data-stu-id="4f071-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="4f071-289">À partir de ces définitions, il s’ensuit que le domaine d’accessibilité d’un membre imbriqué est toujours au moins le texte de programme du type dans lequel le membre est déclaré.</span><span class="sxs-lookup"><span data-stu-id="4f071-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="4f071-290">En outre, il s’ensuit que le domaine d’accessibilité d’un membre n’est jamais plus inclusif que le domaine d’accessibilité du type dans lequel le membre est déclaré.</span><span class="sxs-lookup"><span data-stu-id="4f071-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="4f071-291">En termes intuitifs, lors de l’accès à un type ou membre `M`, les étapes suivantes sont évaluées pour s’assurer que l’accès est autorisé :</span><span class="sxs-lookup"><span data-stu-id="4f071-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="4f071-292">Premièrement, si `M` est déclaré dans un type (par opposition à une unité de compilation ou un espace de noms), une erreur de compilation se produit si ce type n’est pas accessible.</span><span class="sxs-lookup"><span data-stu-id="4f071-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="4f071-293">Ensuite, si `M` est `public`, l’accès est autorisé.</span><span class="sxs-lookup"><span data-stu-id="4f071-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="4f071-294">Sinon, si `M` est `protected internal`, l’accès est autorisé s’il se produit dans le programme dans lequel `M` est déclaré, ou s’il se produit dans une classe dérivée de la classe dans laquelle `M` est déclarée et qui a lieu via le type de classe dérivée ([protected accès pour les membres d’instance](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="4f071-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="4f071-295">Sinon, si `M` est `protected`, l’accès est autorisé s’il se produit dans la classe dans laquelle `M` est déclaré, ou s’il se produit dans une classe dérivée de la classe dans laquelle `M` est déclarée et qui a lieu via le type de classe dérivée ([protected accès pour les membres d’instance](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="4f071-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="4f071-296">Sinon, si `M` est `internal`, l’accès est autorisé s’il se produit dans le programme dans lequel `M` est déclaré.</span><span class="sxs-lookup"><span data-stu-id="4f071-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="4f071-297">Sinon, si `M` est `private`, l’accès est autorisé s’il se produit dans le type dans lequel `M` est déclaré.</span><span class="sxs-lookup"><span data-stu-id="4f071-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="4f071-298">Dans le cas contraire, le type ou le membre n’est pas accessible et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="4f071-299">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="4f071-300">les classes et les membres ont les domaines d’accessibilité suivants :</span><span class="sxs-lookup"><span data-stu-id="4f071-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="4f071-301">Le domaine d’accessibilité de `A` et `A.X` est illimité.</span><span class="sxs-lookup"><span data-stu-id="4f071-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="4f071-302">Le domaine d’accessibilité de `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X` et `B.C.Y` est le texte du programme contenant.</span><span class="sxs-lookup"><span data-stu-id="4f071-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="4f071-303">Le domaine d’accessibilité de `A.Z` correspond au texte de programme de `A`.</span><span class="sxs-lookup"><span data-stu-id="4f071-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="4f071-304">Le domaine d’accessibilité de `B.Z` et `B.D` est le texte de programme de `B`, y compris le texte de programme de `B.C` et `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4f071-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="4f071-305">Le domaine d’accessibilité de `B.C.Z` correspond au texte de programme de `B.C`.</span><span class="sxs-lookup"><span data-stu-id="4f071-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="4f071-306">Le domaine d’accessibilité de `B.D.X` et `B.D.Y` est le texte de programme de `B`, y compris le texte de programme de `B.C` et `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4f071-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="4f071-307">Le domaine d’accessibilité de `B.D.Z` correspond au texte de programme de `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4f071-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="4f071-308">Comme l’illustre l’exemple, le domaine d’accessibilité d’un membre n’est jamais plus grand que celui d’un type conteneur.</span><span class="sxs-lookup"><span data-stu-id="4f071-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="4f071-309">Par exemple, même si tous les membres `X` ont une accessibilité déclarée publique, tous les @no__t, mais-1 ont des domaines d’accessibilité qui sont limités par un type conteneur.</span><span class="sxs-lookup"><span data-stu-id="4f071-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="4f071-310">Comme décrit dans [membres](basic-concepts.md#members), tous les membres d’une classe de base, à l’exception des constructeurs d’instance, des destructeurs et des constructeurs statiques, sont hérités par les types dérivés.</span><span class="sxs-lookup"><span data-stu-id="4f071-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="4f071-311">Cela comprend même les membres privés d’une classe de base.</span><span class="sxs-lookup"><span data-stu-id="4f071-311">This includes even private members of a base class.</span></span> <span data-ttu-id="4f071-312">Toutefois, le domaine d’accessibilité d’un membre privé comprend uniquement le texte de programme du type dans lequel le membre est déclaré.</span><span class="sxs-lookup"><span data-stu-id="4f071-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="4f071-313">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="4f071-314">la classe `B` hérite du membre privé `x` de la classe `A`.</span><span class="sxs-lookup"><span data-stu-id="4f071-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="4f071-315">Étant donné que le membre est privé, il est uniquement accessible dans le *class_body* de `A`.</span><span class="sxs-lookup"><span data-stu-id="4f071-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="4f071-316">Ainsi, l’accès à `b.x` réussit dans la méthode `A.F`, mais échoue dans la méthode `B.F`.</span><span class="sxs-lookup"><span data-stu-id="4f071-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="4f071-317">Accès protégé pour les membres d’instance</span><span class="sxs-lookup"><span data-stu-id="4f071-317">Protected access for instance members</span></span>

<span data-ttu-id="4f071-318">Lorsqu’un membre d’instance `protected` est accessible en dehors du texte de programme de la classe dans laquelle il est déclaré, et quand un membre d’instance `protected internal` est accessible en dehors du texte de programme du programme dans lequel il est déclaré, l’accès doit avoir lieu dans une classe déclaration qui dérive de la classe dans laquelle elle est déclarée.</span><span class="sxs-lookup"><span data-stu-id="4f071-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="4f071-319">En outre, l’accès doit être effectué par le biais d’une instance de ce type de classe dérivée ou d’un type de classe construit à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="4f071-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="4f071-320">Cette restriction empêche une classe dérivée d’accéder aux membres protégés d’autres classes dérivées, même lorsque les membres sont hérités de la même classe de base.</span><span class="sxs-lookup"><span data-stu-id="4f071-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="4f071-321">Laissez `B` être une classe de base qui déclare un membre d’instance protégée `M` et laissez `D` être une classe qui dérive de `B`.</span><span class="sxs-lookup"><span data-stu-id="4f071-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="4f071-322">Dans le *class_body* de `D`, l’accès à `M` peut prendre l’une des formes suivantes :</span><span class="sxs-lookup"><span data-stu-id="4f071-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="4f071-323">*Type_name* ou *primary_expression* non qualifié de la forme `M`.</span><span class="sxs-lookup"><span data-stu-id="4f071-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="4f071-324">Un *primary_expression* de la forme `E.M`, à condition que le type de `E` soit `T` ou une classe dérivée de `T`, où `T` est le type de classe `D` ou un type de classe construit à partir de `D`</span><span class="sxs-lookup"><span data-stu-id="4f071-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="4f071-325">*Primary_expression* de la forme `base.M`.</span><span class="sxs-lookup"><span data-stu-id="4f071-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="4f071-326">En plus de ces formes d’accès, une classe dérivée peut accéder à un constructeur d’instance protégé d’une classe de base dans un *constructor_initializer* ([initialiseurs de constructeur](classes.md#constructor-initializers)).</span><span class="sxs-lookup"><span data-stu-id="4f071-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="4f071-327">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="4f071-328">dans `A`, il est possible d’accéder à `x` via des instances de `A` et `B`, car dans les deux cas, l’accès s’effectue via une instance de `A` ou une classe dérivée de `A`.</span><span class="sxs-lookup"><span data-stu-id="4f071-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="4f071-329">Toutefois, dans `B`, il n’est pas possible d’accéder à `x` via une instance de `A`, puisque `A` ne dérive pas de `B`.</span><span class="sxs-lookup"><span data-stu-id="4f071-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="4f071-330">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="4f071-331">les trois assignations à `x` sont autorisées, car elles ont toutes lieu via des instances de types de classe construits à partir du type générique.</span><span class="sxs-lookup"><span data-stu-id="4f071-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="4f071-332">Contraintes d’accessibilité</span><span class="sxs-lookup"><span data-stu-id="4f071-332">Accessibility constraints</span></span>

<span data-ttu-id="4f071-333">Plusieurs constructions dans le C# langage requièrent qu’un type soit ***au moins aussi accessible qu'*** un membre ou un autre type.</span><span class="sxs-lookup"><span data-stu-id="4f071-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="4f071-334">Un type `T` est considéré comme étant au moins aussi accessible qu’un membre ou un type `M` si le domaine d’accessibilité de `T` est un sur-ensemble du domaine d’accessibilité de `M`.</span><span class="sxs-lookup"><span data-stu-id="4f071-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="4f071-335">En d’autres termes, `T` est au moins aussi accessible que `M` si `T` est accessible dans tous les contextes dans lesquels `M` est accessible.</span><span class="sxs-lookup"><span data-stu-id="4f071-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="4f071-336">Les contraintes d’accessibilité suivantes existent :</span><span class="sxs-lookup"><span data-stu-id="4f071-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="4f071-337">La classe de base directe d’un type de classe doit être au moins aussi accessible que le type de classe lui-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="4f071-338">Les interfaces de base explicites d’un type d’interface doivent être au moins aussi accessibles que le type d’interface lui-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="4f071-339">Le type de retour et les types de paramètres d’un type délégué doivent être au moins aussi accessibles que le type délégué lui-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="4f071-340">Le type d’une constante doit être au moins aussi accessible que la constante elle-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="4f071-341">Le type d’un champ doit être au moins aussi accessible que le champ lui-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="4f071-342">Le type de retour et les types de paramètres d’une méthode doivent être au moins aussi accessibles que la méthode elle-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="4f071-343">Le type d’une propriété doit être au moins aussi accessible que la propriété elle-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="4f071-344">Le type d’un événement doit être au moins aussi accessible que l’événement lui-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="4f071-345">Le type et les types de paramètres d’un indexeur doivent être au moins aussi accessibles que l’indexeur lui-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="4f071-346">Le type de retour et les types de paramètres d’un opérateur doivent être au moins aussi accessibles que l’opérateur lui-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="4f071-347">Les types de paramètres d’un constructeur d’instance doivent être au moins aussi accessibles que le constructeur d’instance lui-même.</span><span class="sxs-lookup"><span data-stu-id="4f071-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="4f071-348">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="4f071-349">la classe `B` génère une erreur au moment de la compilation, car `A` n’est pas au moins aussi accessible que `B`.</span><span class="sxs-lookup"><span data-stu-id="4f071-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="4f071-350">De même, dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="4f071-351">la méthode `H` dans `B` génère une erreur au moment de la compilation, car le type de retour `A` n’est pas au moins aussi accessible que la méthode.</span><span class="sxs-lookup"><span data-stu-id="4f071-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="4f071-352">Signatures et surcharge</span><span class="sxs-lookup"><span data-stu-id="4f071-352">Signatures and overloading</span></span>

<span data-ttu-id="4f071-353">Les méthodes, constructeurs d’instance, indexeurs et opérateurs sont caractérisés par leurs ***signatures***:</span><span class="sxs-lookup"><span data-stu-id="4f071-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="4f071-354">La signature d’une méthode se compose du nom de la méthode, du nombre de paramètres de type et du type et du type (valeur, référence ou sortie) de chacun de ses paramètres formels, pris en compte dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="4f071-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4f071-355">Pour ces raisons, tout paramètre de type de la méthode qui se produit dans le type d’un paramètre formel est identifié par son nom, mais par sa position ordinale dans la liste d’arguments de type de la méthode.</span><span class="sxs-lookup"><span data-stu-id="4f071-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="4f071-356">La signature d’une méthode n’inclut pas spécifiquement le type de retour, le modificateur `params` qui peut être spécifié pour le paramètre le plus à droite, ni les contraintes de paramètre de type facultatives.</span><span class="sxs-lookup"><span data-stu-id="4f071-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="4f071-357">La signature d’un constructeur d’instance se compose du type et du type (valeur, référence ou sortie) de chacun de ses paramètres formels, pris en compte dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="4f071-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4f071-358">La signature d’un constructeur d’instance n’inclut pas spécifiquement le modificateur `params` qui peut être spécifié pour le paramètre le plus à droite.</span><span class="sxs-lookup"><span data-stu-id="4f071-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="4f071-359">La signature d’un indexeur se compose du type de chacun de ses paramètres formels, pris en compte dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="4f071-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4f071-360">La signature d’un indexeur n’inclut pas spécifiquement le type d’élément et n’inclut pas non plus le modificateur `params` qui peut être spécifié pour le paramètre le plus à droite.</span><span class="sxs-lookup"><span data-stu-id="4f071-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="4f071-361">La signature d’un opérateur se compose du nom de l’opérateur et du type de chacun de ses paramètres formels, pris en compte dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="4f071-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4f071-362">La signature d’un opérateur n’inclut pas spécifiquement le type de résultat.</span><span class="sxs-lookup"><span data-stu-id="4f071-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="4f071-363">Les signatures sont le mécanisme d’activation pour la ***surcharge*** des membres dans des classes, des structures et des interfaces :</span><span class="sxs-lookup"><span data-stu-id="4f071-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="4f071-364">La surcharge de méthodes permet à une classe, un struct ou une interface de déclarer plusieurs méthodes portant le même nom, à condition que leurs signatures soient uniques dans cette classe, structure ou interface.</span><span class="sxs-lookup"><span data-stu-id="4f071-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="4f071-365">La surcharge des constructeurs d’instance permet à une classe ou un struct de déclarer plusieurs constructeurs d’instance, à condition que leurs signatures soient uniques au sein de cette classe ou de ce struct.</span><span class="sxs-lookup"><span data-stu-id="4f071-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="4f071-366">La surcharge d’indexeurs permet à une classe, un struct ou une interface de déclarer plusieurs indexeurs, à condition que leurs signatures soient uniques au sein de cette classe, structure ou interface.</span><span class="sxs-lookup"><span data-stu-id="4f071-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="4f071-367">La surcharge des opérateurs permet à une classe ou un struct de déclarer plusieurs opérateurs portant le même nom, à condition que leurs signatures soient uniques au sein de cette classe ou de ce struct.</span><span class="sxs-lookup"><span data-stu-id="4f071-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="4f071-368">Bien que les modificateurs de paramètres `out` et `ref` soient considérés comme faisant partie d’une signature, les membres déclarés dans un même type ne peuvent pas différer dans la signature uniquement par `ref` et `out`.</span><span class="sxs-lookup"><span data-stu-id="4f071-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="4f071-369">Une erreur de compilation se produit si deux membres sont déclarés dans le même type avec des signatures qui seraient les mêmes si tous les paramètres dans les deux méthodes avec des modificateurs `out` ont été changés en modificateurs `ref`.</span><span class="sxs-lookup"><span data-stu-id="4f071-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="4f071-370">À d’autres fins de correspondance de signature (par exemple, le masquage ou la substitution), `ref` et `out` sont considérés comme faisant partie de la signature et ne correspondent pas l’un à l’autre.</span><span class="sxs-lookup"><span data-stu-id="4f071-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="4f071-371">(Cette restriction consiste à permettre C# aux programmes d’être facilement traduits pour s’exécuter sur le Common Language Infrastructure (interface de commande), ce qui ne permet pas de définir des méthodes qui diffèrent uniquement par `ref` et `out`.)</span><span class="sxs-lookup"><span data-stu-id="4f071-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="4f071-372">Pour les besoins des signatures, les types `object` et `dynamic` sont considérés comme identiques.</span><span class="sxs-lookup"><span data-stu-id="4f071-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="4f071-373">Les membres déclarés dans un même type ne peuvent donc pas être différents dans la signature uniquement par `object` et `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="4f071-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="4f071-374">L’exemple suivant montre un ensemble de déclarations de méthode surchargées, ainsi que leurs signatures.</span><span class="sxs-lookup"><span data-stu-id="4f071-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="4f071-375">Notez que les modificateurs de paramètre `ref` et `out` ([paramètres de méthode](classes.md#method-parameters)) font partie d’une signature.</span><span class="sxs-lookup"><span data-stu-id="4f071-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="4f071-376">Par conséquent, `F(int)` et `F(ref int)` sont des signatures uniques.</span><span class="sxs-lookup"><span data-stu-id="4f071-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="4f071-377">Toutefois, `F(ref int)` et `F(out int)` ne peuvent pas être déclarés dans la même interface, car leurs signatures diffèrent uniquement par `ref` et `out`.</span><span class="sxs-lookup"><span data-stu-id="4f071-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="4f071-378">Notez également que le type de retour et le modificateur `params` ne font pas partie d’une signature. il n’est donc pas possible de se surcharger uniquement en fonction du type de retour ou de l’inclusion ou de l’exclusion du modificateur `params`.</span><span class="sxs-lookup"><span data-stu-id="4f071-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="4f071-379">Ainsi, les déclarations des méthodes `F(int)` et `F(params string[])` identifiées ci-dessus entraînent une erreur au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="4f071-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="4f071-380">Portées</span><span class="sxs-lookup"><span data-stu-id="4f071-380">Scopes</span></span>

<span data-ttu-id="4f071-381">La ***portée*** d’un nom est la région du texte de programme dans laquelle il est possible de faire référence à l’entité déclarée par le nom sans qualification du nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="4f071-382">Les portées peuvent être ***imbriquées***et une portée interne peut redéclarer la signification d’un nom à partir d’une étendue externe (Toutefois, cela ne supprime pas la restriction imposée par les [déclarations](basic-concepts.md#declarations) dans un bloc imbriqué il n’est pas possible de déclarer une variable locale avec l’instruction nom identique à celui d’une variable locale dans un bloc englobant).</span><span class="sxs-lookup"><span data-stu-id="4f071-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="4f071-383">Le nom de l’étendue externe est ensuite dit ***masqué*** dans la région du texte de programme couvert par l’étendue interne, et l’accès au nom externe n’est possible qu’en qualifiant le nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="4f071-384">L’étendue d’un membre d’espace de noms déclaré par un *namespace_member_declaration* ([membres d’espace de noms](namespaces.md#namespace-members)) sans *namespace_declaration* englobant correspond au texte de programme entier.</span><span class="sxs-lookup"><span data-stu-id="4f071-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="4f071-385">La portée d’un membre d’espace de noms déclaré par un *namespace_member_declaration* dans un *namespace_declaration* dont le nom qualifié complet est `N` est le *namespace_body* de chaque *namespace_declaration* dont la le nom qualifié est `N` ou commence par `N`, suivi d’un point.</span><span class="sxs-lookup"><span data-stu-id="4f071-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="4f071-386">L’étendue de nom définie par un *extern_alias_directive* s’étend sur les *using_directive*s, *global_attributes* et *namespace_member_declaration*s de son corps d’unité de compilation ou d’espace de noms contenant immédiatement.</span><span class="sxs-lookup"><span data-stu-id="4f071-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="4f071-387">Un *extern_alias_directive* ne contribue pas aux nouveaux membres de l’espace de déclaration sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="4f071-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="4f071-388">En d’autres termes, un *extern_alias_directive* n’est pas transitif, mais il affecte uniquement l’unité de compilation ou le corps de l’espace de noms dans lequel il se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="4f071-389">L’étendue d’un nom défini ou importé par un *using_directive* ([à l’aide de directives](namespaces.md#using-directives)) s’étend sur les *namespace_member_declaration*s du *compilation_unit* ou *namespace_body* dans lequel le *using_directive* se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="4f071-390">Un *using_directive* peut rendre zéro ou plusieurs noms d’espace de noms, de type ou de membre disponibles dans un *compilation_unit* ou *namespace_body*particulier, mais ne contribue pas à de nouveaux membres dans l’espace de déclaration sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="4f071-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="4f071-391">En d’autres termes, un *using_directive* n’est pas transitif, mais affecte uniquement le *compilation_unit* ou le *namespace_body* dans lequel il se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="4f071-392">La portée d’un paramètre de type déclaré par un *type_parameter_list* sur un *class_declaration* ([déclarations de classe](classes.md#class-declarations)) est *class_base*, *type_parameter_constraints_clause*s et *class_body* de ce  *class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="4f071-393">La portée d’un paramètre de type déclaré par un *type_parameter_list* sur un *struct_declaration* ([déclarations de struct](structs.md#struct-declarations)) est *struct_interfaces*, *type_parameter_constraints_clause*s et *struct_body* de *struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="4f071-394">La portée d’un paramètre de type déclaré par un *type_parameter_list* sur un *interface_declaration* ([déclarations d’interface](interfaces.md#interface-declarations)) est *interface_base*, *type_parameter_constraints_clause*s et *interface_body* de cet *interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="4f071-395">La portée d’un paramètre de type déclaré par un *type_parameter_list* sur un *delegate_declaration* ([déclarations de délégué](delegates.md#delegate-declarations)) est *type_retour*, *formal_parameter_list*et *type_parameter_constraints_clause* s de ce *delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="4f071-396">La portée d’un membre déclaré par un *class_member_declaration* ([corps de classe](classes.md#class-body)) est le *class_body* dans lequel la déclaration se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="4f071-397">En outre, l’étendue d’un membre de classe s’étend au *class_body* de ces classes dérivées qui sont incluses dans le domaine d’accessibilité ([domaines d’accessibilité](basic-concepts.md#accessibility-domains)) du membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="4f071-398">La portée d’un membre déclaré par un *struct_member_declaration* ([membres de struct](structs.md#struct-members)) est le *struct_body* dans lequel la déclaration se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4f071-399">La portée d’un membre déclaré par un *enum_member_declaration* ([membres enum](enums.md#enum-members)) est le *enum_body* dans lequel la déclaration se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4f071-400">La portée d’un paramètre déclaré dans un *method_declaration* ([méthodes](classes.md#methods)) est le *method_body* de ce *method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="4f071-401">La portée d’un paramètre déclaré dans un *indexer_declaration* ([indexeurs](classes.md#indexers)) est le *accessor_declarations* de ce *indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="4f071-402">La portée d’un paramètre déclaré dans un *operator_declaration* ([opérateurs](classes.md#operators)) est le *bloc* de ce *operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="4f071-403">La portée d’un paramètre déclaré dans un *constructor_declaration* ([constructeurs d’instance](classes.md#instance-constructors)) est le *constructor_initializer* et le *bloc* de ce *constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="4f071-404">La portée d’un paramètre déclaré dans un *lambda_expression* ([expressions de fonction anonymes](expressions.md#anonymous-function-expressions)) est le *anonymous_function_body* de ce *lambda_expression*</span><span class="sxs-lookup"><span data-stu-id="4f071-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="4f071-405">La portée d’un paramètre déclaré dans un *anonymous_method_expression* ([expressions de fonction anonymes](expressions.md#anonymous-function-expressions)) est le *bloc* de ce *anonymous_method_expression*.</span><span class="sxs-lookup"><span data-stu-id="4f071-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="4f071-406">La portée d’une étiquette déclarée dans un *labeled_statement* ([instructions étiquetées](statements.md#labeled-statements)) est le *bloc* dans lequel la déclaration se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4f071-407">La portée d’une variable locale déclarée dans un *local_variable_declaration* ([déclarations de variables locales](statements.md#local-variable-declarations)) est le bloc dans lequel la déclaration se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="4f071-408">La portée d’une variable locale déclarée dans un *switch_block* d’une instruction `switch` ([l’instruction switch](statements.md#the-switch-statement)) est *switch_block*.</span><span class="sxs-lookup"><span data-stu-id="4f071-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="4f071-409">La portée d’une variable locale déclarée dans *un for_initializer* d’une instruction `for` ([l’instruction for](statements.md#the-for-statement)) est *for_initializer*, *for_condition*, *for_iterator*et l' *instruction* contenue de l’objet instruction `for`.</span><span class="sxs-lookup"><span data-stu-id="4f071-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="4f071-410">La portée d’une constante locale déclarée dans un *local_constant_declaration* ([déclarations de constantes locales](statements.md#local-constant-declarations)) est le bloc dans lequel la déclaration se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="4f071-411">Il s’agit d’une erreur de compilation pour faire référence à une constante locale dans une position textuelle qui précède son *constant_declarator*.</span><span class="sxs-lookup"><span data-stu-id="4f071-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="4f071-412">La portée d’une variable déclarée dans le cadre d’un *foreach_statement*, *using_statement*, *lock_statement* ou *query_expression* est déterminée par l’expansion de la construction donnée.</span><span class="sxs-lookup"><span data-stu-id="4f071-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="4f071-413">Dans l’étendue d’un espace de noms, d’une classe, d’une structure ou d’un membre d’énumération, il est possible de faire référence au membre dans une position textuelle qui précède la déclaration du membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="4f071-414">Exemple :</span><span class="sxs-lookup"><span data-stu-id="4f071-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="4f071-415">Ici, il est valide pour `F` de faire référence à `i` avant d’être déclaré.</span><span class="sxs-lookup"><span data-stu-id="4f071-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="4f071-416">Dans l’étendue d’une variable locale, il s’agit d’une erreur de compilation qui fait référence à la variable locale dans une position textuelle qui précède le *local_variable_declarator* de la variable locale.</span><span class="sxs-lookup"><span data-stu-id="4f071-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="4f071-417">Exemple :</span><span class="sxs-lookup"><span data-stu-id="4f071-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="4f071-418">Dans la méthode `F` ci-dessus, la première assignation à `i` ne fait pas référence au champ déclaré dans l’étendue externe.</span><span class="sxs-lookup"><span data-stu-id="4f071-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="4f071-419">Au lieu de cela, il fait référence à la variable locale et génère une erreur de compilation, car il précède la déclaration de la variable dans le texte.</span><span class="sxs-lookup"><span data-stu-id="4f071-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="4f071-420">Dans la méthode `G`, l’utilisation de `j` dans l’initialiseur pour la déclaration de `j` est valide, car l’utilisation ne précède pas *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="4f071-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="4f071-421">Dans la méthode `H`, un *local_variable_declarator* suivant fait correctement référence à une variable locale déclarée dans un *local_variable_declarator* antérieur au sein du même *local_variable_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4f071-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="4f071-422">Les règles de portée pour les variables locales sont conçues pour garantir que la signification d’un nom utilisé dans un contexte d’expression est toujours la même dans un bloc.</span><span class="sxs-lookup"><span data-stu-id="4f071-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="4f071-423">Si la portée d’une variable locale ne doit s’étendre qu’à partir de sa déclaration à la fin du bloc, alors, dans l’exemple ci-dessus, la première assignation est assignée à la variable d’instance et la deuxième assignation est assignée à la variable locale, ce qui peut aboutir à erreurs au moment de la compilation si les instructions du bloc ont été réorganisées par la suite.</span><span class="sxs-lookup"><span data-stu-id="4f071-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="4f071-424">La signification d’un nom dans un bloc peut varier selon le contexte dans lequel le nom est utilisé.</span><span class="sxs-lookup"><span data-stu-id="4f071-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="4f071-425">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="4f071-426">le nom `A` est utilisé dans un contexte d’expression pour faire référence à la variable locale `A` et dans un contexte de type pour faire référence à la classe `A`.</span><span class="sxs-lookup"><span data-stu-id="4f071-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="4f071-427">Masquage de nom</span><span class="sxs-lookup"><span data-stu-id="4f071-427">Name hiding</span></span>

<span data-ttu-id="4f071-428">La portée d’une entité comprend généralement plus de texte de programme que l’espace de déclaration de l’entité.</span><span class="sxs-lookup"><span data-stu-id="4f071-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="4f071-429">En particulier, l’étendue d’une entité peut inclure des déclarations qui introduisent de nouveaux espaces de déclaration contenant des entités du même nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="4f071-430">De telles déclarations entraînent le ***masquage***de l’entité d’origine.</span><span class="sxs-lookup"><span data-stu-id="4f071-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="4f071-431">À l’inverse, une entité est dite ***visible*** lorsqu’elle n’est pas masquée.</span><span class="sxs-lookup"><span data-stu-id="4f071-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="4f071-432">Le masquage de nom se produit lorsque les étendues se chevauchent lors de l’imbrication et lorsque les étendues chevauchent l’héritage.</span><span class="sxs-lookup"><span data-stu-id="4f071-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="4f071-433">Les caractéristiques des deux types de masquage sont décrites dans les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="4f071-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="4f071-434">Masquer par imbrication</span><span class="sxs-lookup"><span data-stu-id="4f071-434">Hiding through nesting</span></span>

<span data-ttu-id="4f071-435">Le masquage de nom via l’imbrication peut se produire en raison de l’imbrication d’espaces de noms ou de types dans les espaces de noms, en raison de l’imbrication de types dans des classes ou des structs, et de la suite de déclarations de variables locales et de paramètres.</span><span class="sxs-lookup"><span data-stu-id="4f071-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="4f071-436">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="4f071-437">dans la méthode `F`, la variable d’instance `i` est masquée par la variable locale `i`, mais dans la méthode `G`, `i` fait toujours référence à la variable d’instance.</span><span class="sxs-lookup"><span data-stu-id="4f071-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="4f071-438">Lorsqu’un nom dans une portée interne masque un nom dans une portée externe, il masque toutes les occurrences surchargées de ce nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="4f071-439">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="4f071-440">l’appel `F(1)` appelle la `F` déclarée dans `Inner`, car toutes les occurrences externes de `F` sont masquées par la déclaration interne.</span><span class="sxs-lookup"><span data-stu-id="4f071-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="4f071-441">Pour la même raison, l’appel `F("Hello")` génère une erreur au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="4f071-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="4f071-442">Masquer par héritage</span><span class="sxs-lookup"><span data-stu-id="4f071-442">Hiding through inheritance</span></span>

<span data-ttu-id="4f071-443">Le masquage de nom par héritage se produit lorsque des classes ou des structs déclarent des noms qui ont été hérités de classes de base.</span><span class="sxs-lookup"><span data-stu-id="4f071-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="4f071-444">Ce type de masquage de nom prend l’une des formes suivantes :</span><span class="sxs-lookup"><span data-stu-id="4f071-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="4f071-445">Une constante, un champ, une propriété, un événement ou un type introduit dans une classe ou un struct masque tous les membres de la classe de base portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="4f071-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="4f071-446">Une méthode introduite dans une classe ou un struct masque tous les membres de classe de base non-méthode portant le même nom, ainsi que toutes les méthodes de la classe de base ayant la même signature (nom de méthode et nombre de paramètres, modificateurs et types).</span><span class="sxs-lookup"><span data-stu-id="4f071-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="4f071-447">Un indexeur introduit dans une classe ou un struct masque tous les indexeurs de la classe de base avec la même signature (nombre de paramètres et types).</span><span class="sxs-lookup"><span data-stu-id="4f071-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="4f071-448">Les règles gouvernant les déclarations d’opérateur ([opérateurs](classes.md#operators)) rendent impossible une classe dérivée de déclarer un opérateur avec la même signature qu’un opérateur dans une classe de base.</span><span class="sxs-lookup"><span data-stu-id="4f071-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="4f071-449">Ainsi, les opérateurs ne sont jamais masqués.</span><span class="sxs-lookup"><span data-stu-id="4f071-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="4f071-450">Contrairement au masquage d’un nom dans une portée externe, le masquage d’un nom accessible à partir d’une portée héritée entraîne le signalement d’un avertissement.</span><span class="sxs-lookup"><span data-stu-id="4f071-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="4f071-451">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="4f071-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="4f071-452">la déclaration de `F` dans `Derived` provoque le signalement d’un avertissement.</span><span class="sxs-lookup"><span data-stu-id="4f071-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="4f071-453">Le masquage d’un nom hérité n’est pas une erreur, car cela empêche l’évolution distincte des classes de base.</span><span class="sxs-lookup"><span data-stu-id="4f071-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="4f071-454">Par exemple, la situation ci-dessus peut être due au fait qu’une version ultérieure de `Base` a introduit une méthode `F` qui n’était pas présente dans une version antérieure de la classe.</span><span class="sxs-lookup"><span data-stu-id="4f071-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="4f071-455">Si la situation précédente était une erreur, toute modification apportée à une classe de base dans une bibliothèque de classes avec version distincte pourrait entraîner la non-validité des classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="4f071-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="4f071-456">L’avertissement provoqué par le masquage d’un nom hérité peut être éliminé grâce à l’utilisation du modificateur `new` :</span><span class="sxs-lookup"><span data-stu-id="4f071-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="4f071-457">Le modificateur `new` indique que la `F` dans `Derived` est « New », et qu’elle est effectivement destinée à masquer le membre hérité.</span><span class="sxs-lookup"><span data-stu-id="4f071-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="4f071-458">Une déclaration d’un nouveau membre masque un membre hérité uniquement dans la portée du nouveau membre.</span><span class="sxs-lookup"><span data-stu-id="4f071-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="4f071-459">Dans l’exemple ci-dessus, la déclaration de `F` dans `Derived` masque le `F` hérité de `Base`, mais étant donné que la nouvelle `F` dans `Derived` a un accès privé, son étendue ne s’étend pas à `MoreDerived`.</span><span class="sxs-lookup"><span data-stu-id="4f071-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="4f071-460">Ainsi, l’appel `F()` dans `MoreDerived.G` est valide et appellera `Base.F`.</span><span class="sxs-lookup"><span data-stu-id="4f071-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="4f071-461">Noms d’espaces de noms et de types</span><span class="sxs-lookup"><span data-stu-id="4f071-461">Namespace and type names</span></span>

<span data-ttu-id="4f071-462">Plusieurs contextes dans un C# programme nécessitent la spécification d’un *namespace_name* ou d’un *type_name* .</span><span class="sxs-lookup"><span data-stu-id="4f071-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="4f071-463">Un *namespace_name* est un *namespace_or_type_name* qui fait référence à un espace de noms.</span><span class="sxs-lookup"><span data-stu-id="4f071-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="4f071-464">À la résolution suivante, comme décrit ci-dessous, le *namespace_or_type_name* d’un *namespace_name* doit faire référence à un espace de noms, sinon une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="4f071-465">Aucun argument de type ([arguments de type](types.md#type-arguments)) ne peut être présent dans un *namespace_name* (seuls les types peuvent avoir des arguments de type).</span><span class="sxs-lookup"><span data-stu-id="4f071-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="4f071-466">Un *type_name* est un *namespace_or_type_name* qui fait référence à un type.</span><span class="sxs-lookup"><span data-stu-id="4f071-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="4f071-467">Après la résolution comme décrit ci-dessous, le *namespace_or_type_name* d’un *type_name* doit faire référence à un type, ou une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="4f071-468">Si le *namespace_or_type_name* est un membre d’alias qualifié, son sens est décrit dans [qualificateurs d’alias d’espace de noms](namespaces.md#namespace-alias-qualifiers).</span><span class="sxs-lookup"><span data-stu-id="4f071-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="4f071-469">Dans le cas contraire, un *namespace_or_type_name* a l’une des quatre formes suivantes :</span><span class="sxs-lookup"><span data-stu-id="4f071-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="4f071-470">où `I` est un identificateur unique, `N` est un *namespace_or_type_name* et `<A1, ..., Ak>` est un *type_argument_list*facultatif.</span><span class="sxs-lookup"><span data-stu-id="4f071-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="4f071-471">Si aucun *type_argument_list* n’est spécifié, envisagez `k` pour être égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="4f071-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="4f071-472">La signification d’un *namespace_or_type_name* est déterminée comme suit :</span><span class="sxs-lookup"><span data-stu-id="4f071-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="4f071-473">Si le *namespace_or_type_name* se présente sous la forme `I` ou sous la forme `I<A1, ..., Ak>` :</span><span class="sxs-lookup"><span data-stu-id="4f071-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="4f071-474">Si `K` est égal à zéro et que le *namespace_or_type_name* apparaît dans une déclaration de méthode générique ([méthodes](classes.md#methods)) et si cette déclaration comprend un paramètre de type ([paramètres de type](classes.md#type-parameters)) nommé @ no__t-4, le *namespace_or_type_ Name* fait référence à ce paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="4f071-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="4f071-475">Sinon, si le *namespace_or_type_name* apparaît dans une déclaration de type, pour chaque type d’instance @ no__t-1 ([type d’instance](classes.md#the-instance-type)), en commençant par le type d’instance de cette déclaration de type et en continuant avec le type d’instance de chaque Déclaration de classe ou de struct englobante (le cas échéant) :</span><span class="sxs-lookup"><span data-stu-id="4f071-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="4f071-476">Si `K` est égal à zéro et que la déclaration de `T` comprend un paramètre de type nommé @ no__t-2, le *namespace_or_type_name* fait référence à ce paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="4f071-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="4f071-477">Sinon, si le *namespace_or_type_name* apparaît dans le corps de la déclaration de type et que `T` ou l’un de ses types de base contient un type accessible imbriqué ayant les paramètres Name @ no__t-2 et `K` @ no__t-4Type, le *namespace_or_type _name* fait référence à ce type construit avec les arguments de type donnés.</span><span class="sxs-lookup"><span data-stu-id="4f071-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="4f071-478">S’il existe plusieurs types de ce type, le type déclaré dans le type plus dérivé est sélectionné.</span><span class="sxs-lookup"><span data-stu-id="4f071-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="4f071-479">Notez que les membres qui ne sont pas de type (constantes, champs, méthodes, propriétés, indexeurs, opérateurs, constructeurs d’instance, destructeurs et constructeurs statiques) et les membres de type avec un nombre différent de paramètres de type sont ignorés lors de la détermination de la signification du *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="4f071-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="4f071-480">Si les étapes précédentes n’ont pas réussi, pour chaque espace de noms @ no__t-0, en commençant par l’espace de noms dans lequel le *namespace_or_type_name* se produit, en continuant avec chaque espace de noms englobant (le cas échéant) et en terminant par l’espace de noms global, les éléments suivants les étapes sont évaluées jusqu’à ce qu’une entité soit localisée :</span><span class="sxs-lookup"><span data-stu-id="4f071-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="4f071-481">Si `K` est égal à zéro et que `I` est le nom d’un espace de noms dans @ no__t-2, alors :</span><span class="sxs-lookup"><span data-stu-id="4f071-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="4f071-482">Si l’emplacement où le *namespace_or_type_name* se produit est entouré d’une déclaration d’espace de noms pour `N` et que la déclaration d’espace de noms contient un *extern_alias_directive* ou *using_alias_directive* qui associe le nom @ no __t-4 avec un espace de noms ou un type, le *namespace_or_type_name* est ambigu et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="4f071-483">Sinon, *namespace_or_type_name* fait référence à l’espace de noms nommé `I` dans `N`.</span><span class="sxs-lookup"><span data-stu-id="4f071-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="4f071-484">Sinon, si `N` contient un type accessible avec les paramètres Name @ no__t-1 et `K` @ no__t-3Type, alors :</span><span class="sxs-lookup"><span data-stu-id="4f071-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="4f071-485">Si `K` est égal à zéro et que l’emplacement où le *namespace_or_type_name* se produit est entouré d’une déclaration d’espace de noms pour `N` et que la déclaration d’espace de noms contient un *extern_alias_directive* ou *using_alias_directive* qui associe le nom @ no__t-5 à un espace de noms ou à un type, alors le *namespace_or_type_name* est ambigu et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="4f071-486">Sinon, *namespace_or_type_name* fait référence au type construit avec les arguments de type donnés.</span><span class="sxs-lookup"><span data-stu-id="4f071-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="4f071-487">Sinon, si l’emplacement où le *namespace_or_type_name* se produit est entouré d’une déclaration d’espace de noms pour `N` :</span><span class="sxs-lookup"><span data-stu-id="4f071-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="4f071-488">Si `K` est égal à zéro et que la déclaration d’espace de noms contient un *extern_alias_directive* ou un *using_alias_directive* qui associe le nom @ no__t-3 à un espace de noms ou un type importé, le *namespace_or_type_name* fait référence à ce. espace de noms ou type.</span><span class="sxs-lookup"><span data-stu-id="4f071-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="4f071-489">Sinon, si les espaces de noms et les déclarations de type importés par les *using_namespace_directive*et *using_alias_directive*s de la déclaration d’espace de noms contiennent exactement un type accessible portant le nom @ no__t-2 et `K` @ no__t-4Type paramètres, puis le *namespace_or_type_name* fait référence à ce type construit avec les arguments de type donnés.</span><span class="sxs-lookup"><span data-stu-id="4f071-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="4f071-490">Sinon, si les espaces de noms et les déclarations de type importés par les *using_namespace_directive*et *using_alias_directive*s de la déclaration d’espace de noms contiennent plusieurs types accessibles portant le nom @ no__t-2 et `K` @ no__t-4Type paramètres, le *namespace_or_type_name* est ambigu et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="4f071-491">Dans le cas contraire, le *namespace_or_type_name* n’est pas défini et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="4f071-492">Dans le cas contraire, le *namespace_or_type_name* se présente sous la forme `N.I` ou sous la forme `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="4f071-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="4f071-493">`N` est tout d’abord résolu en tant que *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="4f071-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="4f071-494">Si la résolution de `N` échoue, une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="4f071-495">Dans le cas contraire, `N.I` ou `N.I<A1, ..., Ak>` est résolu comme suit :</span><span class="sxs-lookup"><span data-stu-id="4f071-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="4f071-496">Si `K` est égal à zéro et que `N` fait référence à un espace de noms et que `N` contient un espace de noms imbriqué avec le nom `I`, le *namespace_or_type_name* fait référence à cet espace de noms imbriqué.</span><span class="sxs-lookup"><span data-stu-id="4f071-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="4f071-497">Sinon, si `N` fait référence à un espace de noms et que `N` contient un type accessible avec les paramètres Name @ no__t-2 et `K` @ no__t-4Type, alors le *namespace_or_type_name* fait référence à ce type construit avec les arguments de type donnés.</span><span class="sxs-lookup"><span data-stu-id="4f071-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="4f071-498">Sinon, si `N` fait référence à un type de classe ou de struct (éventuellement construit) et que `N` ou l’une de ses classes de base contient un type accessible imbriqué ayant les paramètres Name @ no__t-2 et `K` @ no__t-4Type, alors le *namespace_or_type_name* fait référence à ce type a été construit avec les arguments de type donnés.</span><span class="sxs-lookup"><span data-stu-id="4f071-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="4f071-499">S’il existe plusieurs types de ce type, le type déclaré dans le type plus dérivé est sélectionné.</span><span class="sxs-lookup"><span data-stu-id="4f071-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="4f071-500">Notez que si la signification de `N.I` est déterminée dans le cadre de la résolution de la spécification de la classe de base de `N`, la classe de base directe de `N` est considérée comme Object ([classes de base](classes.md#base-classes)).</span><span class="sxs-lookup"><span data-stu-id="4f071-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="4f071-501">Dans le cas contraire, `N.I` est un *namespace_or_type_name*non valide et une erreur de compilation se produit.</span><span class="sxs-lookup"><span data-stu-id="4f071-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="4f071-502">Un *namespace_or_type_name* est autorisé à référencer une classe statique ([classes statiques](classes.md#static-classes)) uniquement si</span><span class="sxs-lookup"><span data-stu-id="4f071-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="4f071-503">*Namespace_or_type_name* est le `T` dans un *namespace_or_type_name* de la forme `T.I`, ou</span><span class="sxs-lookup"><span data-stu-id="4f071-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="4f071-504">*Namespace_or_type_name* est le `T` dans un *typeof_expression* ([liste d’arguments](expressions.md#argument-lists)1) de la forme `typeof(T)`.</span><span class="sxs-lookup"><span data-stu-id="4f071-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="4f071-505">Noms qualifiés complets</span><span class="sxs-lookup"><span data-stu-id="4f071-505">Fully qualified names</span></span>

<span data-ttu-id="4f071-506">Chaque espace de noms et type a un ***nom qualifié complet***, qui identifie de façon unique l’espace de noms ou le type parmi tous les autres.</span><span class="sxs-lookup"><span data-stu-id="4f071-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="4f071-507">Le nom qualifié complet d’un espace de noms ou d’un type `N` est déterminé comme suit :</span><span class="sxs-lookup"><span data-stu-id="4f071-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="4f071-508">Si `N` est un membre de l’espace de noms global, son nom complet est `N`.</span><span class="sxs-lookup"><span data-stu-id="4f071-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="4f071-509">Dans le cas contraire, son nom qualifié complet est `S.N`, où `S` est le nom qualifié complet de l’espace de noms ou du type dans lequel `N` est déclaré.</span><span class="sxs-lookup"><span data-stu-id="4f071-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="4f071-510">En d’autres termes, le nom qualifié complet de `N` est le chemin d’accès hiérarchique complet des identificateurs qui mènent à `N`, en commençant par l’espace de noms global.</span><span class="sxs-lookup"><span data-stu-id="4f071-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="4f071-511">Étant donné que chaque membre d’un espace de noms ou d’un type doit avoir un nom unique, il suit que le nom qualifié complet d’un espace de noms ou d’un type est toujours unique.</span><span class="sxs-lookup"><span data-stu-id="4f071-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="4f071-512">L’exemple ci-dessous montre plusieurs déclarations d’espace de noms et de type, ainsi que leurs noms complets associés.</span><span class="sxs-lookup"><span data-stu-id="4f071-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="4f071-513">Gestion automatique de la mémoire</span><span class="sxs-lookup"><span data-stu-id="4f071-513">Automatic memory management</span></span>

<span data-ttu-id="4f071-514">C#utilise la gestion automatique de la mémoire, qui évite aux développeurs d’allouer et de libérer manuellement la mémoire occupée par les objets.</span><span class="sxs-lookup"><span data-stu-id="4f071-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="4f071-515">Les stratégies de gestion automatique de la mémoire sont implémentées par un ***garbage collector***.</span><span class="sxs-lookup"><span data-stu-id="4f071-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="4f071-516">Le cycle de vie de la gestion de la mémoire d’un objet est le suivant :</span><span class="sxs-lookup"><span data-stu-id="4f071-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="4f071-517">Lorsque l’objet est créé, la mémoire est allouée, le constructeur est exécuté et l’objet est considéré comme dynamique.</span><span class="sxs-lookup"><span data-stu-id="4f071-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="4f071-518">Si l’objet, ou une partie de celui-ci, n’est pas accessible par une continuation d’exécution possible, autre que l’exécution de destructeurs, l’objet est considéré comme n’étant plus utilisé et il est éligible pour la destruction.</span><span class="sxs-lookup"><span data-stu-id="4f071-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="4f071-519">Le C# compilateur et le garbage collector peuvent choisir d’analyser le code pour déterminer les références à un objet qui peuvent être utilisées ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="4f071-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="4f071-520">Par exemple, si une variable locale qui est dans la portée est la seule référence existante à un objet, mais que cette variable locale n’est jamais référencée dans une éventuelle continuation d’exécution à partir du point d’exécution actuel de la procédure, le garbage collector peut (mais n’est pas requis pour) traiter l’objet comme n’étant plus utilisé.</span><span class="sxs-lookup"><span data-stu-id="4f071-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="4f071-521">Une fois que l’objet est éligible pour la destruction, à une date non spécifiée plus tard, le[destructeur (le cas échéant) de](classes.md#destructors)l’objet est exécuté.</span><span class="sxs-lookup"><span data-stu-id="4f071-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="4f071-522">Dans des circonstances normales, le destructeur de l’objet est exécuté une seule fois, bien que les API spécifiques à l’implémentation puissent autoriser le remplacement de ce comportement.</span><span class="sxs-lookup"><span data-stu-id="4f071-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="4f071-523">Une fois que le destructeur pour un objet est exécuté, si cet objet, ou une partie de celui-ci, n’est pas accessible par toute continuation d’exécution possible, y compris l’exécution de destructeurs, l’objet est considéré comme étant inaccessible et l’objet devient éligible pour la collecte.</span><span class="sxs-lookup"><span data-stu-id="4f071-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="4f071-524">Enfin, une fois que l’objet est éligible pour la collecte, le garbage collector libère la mémoire associée à cet objet.</span><span class="sxs-lookup"><span data-stu-id="4f071-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="4f071-525">Le garbage collector conserve des informations sur l’utilisation des objets et utilise ces informations pour prendre des décisions de gestion de la mémoire, telles que l’emplacement de la mémoire pour localiser un objet nouvellement créé, quand déplacer un objet, et quand un objet n’est plus utilisé ou n’est pas accessible.</span><span class="sxs-lookup"><span data-stu-id="4f071-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="4f071-526">Comme les autres langages qui supposent l’existence d’un C# garbage collector, est conçu de sorte que le garbage collector puisse implémenter une large gamme de stratégies de gestion de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="4f071-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="4f071-527">Par exemple, C# ne nécessite pas l’exécution des destructeurs ou la collecte des objets dès qu’ils sont éligibles, ou l’exécution des destructeurs dans un ordre particulier ou sur un thread particulier.</span><span class="sxs-lookup"><span data-stu-id="4f071-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="4f071-528">Le comportement du garbage collector peut être contrôlé, à un certain degré, via des méthodes statiques sur la classe `System.GC`.</span><span class="sxs-lookup"><span data-stu-id="4f071-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="4f071-529">Cette classe peut être utilisée pour demander qu’une collection se produise, que les destructeurs soient exécutés (ou non), et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="4f071-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="4f071-530">Dans la mesure où le garbage collector est autorisé à atteindre une grande latitude en déterminant quand collecter des objets et exécuter des destructeurs, une implémentation conforme peut produire une sortie qui diffère de celle indiquée par le code suivant.</span><span class="sxs-lookup"><span data-stu-id="4f071-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="4f071-531">Le programme</span><span class="sxs-lookup"><span data-stu-id="4f071-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="4f071-532">crée une instance de la classe `A` et une instance de la classe `B`.</span><span class="sxs-lookup"><span data-stu-id="4f071-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="4f071-533">Ces objets deviennent éligibles pour garbage collection lorsque la valeur `null` est assignée à la variable `b`, étant donné qu’il est impossible pour un code écrit par l’utilisateur d’y accéder.</span><span class="sxs-lookup"><span data-stu-id="4f071-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="4f071-534">La sortie peut être</span><span class="sxs-lookup"><span data-stu-id="4f071-534">The output could be either</span></span>

```console
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="4f071-535">ou</span><span class="sxs-lookup"><span data-stu-id="4f071-535">or</span></span>
```console
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="4f071-536">étant donné que le langage n’impose aucune contrainte sur l’ordre dans lequel les objets sont récupérés par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="4f071-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="4f071-537">Dans les cas subtils, la distinction entre « éligible à la destruction » et « éligible pour la collecte » peut être importante.</span><span class="sxs-lookup"><span data-stu-id="4f071-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="4f071-538">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="4f071-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="4f071-539">Dans le programme ci-dessus, si le garbage collector choisit d’exécuter le destructeur de `A` avant le destructeur de `B`, la sortie de ce programme peut être :</span><span class="sxs-lookup"><span data-stu-id="4f071-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```console
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="4f071-540">Notez que même si l’instance de `A` n’était pas en cours d’utilisation et que le destructeur de `A` était exécuté, il est toujours possible pour les méthodes de `A` (dans ce cas, `F`) d’être appelées à partir d’un autre destructeur.</span><span class="sxs-lookup"><span data-stu-id="4f071-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="4f071-541">Notez également que l’exécution d’un destructeur peut entraîner la réutilisation d’un objet à partir du programme principal.</span><span class="sxs-lookup"><span data-stu-id="4f071-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="4f071-542">Dans ce cas, l’exécution du destructeur de `B` a entraîné une instance de `A` qui n’était pas utilisée précédemment pour devenir accessible à partir de la référence active `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="4f071-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="4f071-543">Après l’appel à `WaitForPendingFinalizers`, l’instance de `B` est éligible pour la collection, mais l’instance de `A` ne l’est pas, en raison de la référence `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="4f071-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="4f071-544">Pour éviter toute confusion et un comportement inattendu, il est généralement judicieux que les destructeurs effectuent uniquement un nettoyage sur les données stockées dans les champs de leur propre objet, et non sur les objets référencés ou les champs statiques.</span><span class="sxs-lookup"><span data-stu-id="4f071-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="4f071-545">Une alternative à l’utilisation des destructeurs consiste à permettre à une classe d’implémenter l’interface `System.IDisposable`.</span><span class="sxs-lookup"><span data-stu-id="4f071-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="4f071-546">Cela permet au client de l’objet de déterminer quand libérer les ressources de l’objet, en généralement en accédant à l’objet en tant que ressource dans une instruction `using` ([l’instruction using](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="4f071-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="4f071-547">Ordre d’exécution</span><span class="sxs-lookup"><span data-stu-id="4f071-547">Execution order</span></span>

<span data-ttu-id="4f071-548">L’exécution d' C# un programme continue de telle sorte que les effets secondaires de chaque thread d’exécution soient conservés aux points d’exécution critiques.</span><span class="sxs-lookup"><span data-stu-id="4f071-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="4f071-549">Un ***effet secondaire*** est défini comme une lecture ou une écriture d’un champ volatile, une écriture dans une variable non volatile, une écriture dans une ressource externe et la levée d’une exception.</span><span class="sxs-lookup"><span data-stu-id="4f071-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="4f071-550">Les points d’exécution critiques à partir desquels l’ordre de ces effets secondaires doivent être préservés sont des références à des champs volatils ([champs volatils](classes.md#volatile-fields)), à des instructions `lock` ([instruction lock](statements.md#the-lock-statement)) et à la création et à l’arrêt des threads.</span><span class="sxs-lookup"><span data-stu-id="4f071-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="4f071-551">L’environnement d’exécution est libre de modifier l’ordre d’exécution d' C# un programme, selon les contraintes suivantes :</span><span class="sxs-lookup"><span data-stu-id="4f071-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="4f071-552">La dépendance des données est conservée dans un thread d’exécution.</span><span class="sxs-lookup"><span data-stu-id="4f071-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="4f071-553">Autrement dit, la valeur de chaque variable est calculée comme si toutes les instructions du thread étaient exécutées dans l’ordre du programme d’origine.</span><span class="sxs-lookup"><span data-stu-id="4f071-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="4f071-554">Les règles de classement d’initialisation sont conservées ([initialisation de champ](classes.md#field-initialization) et [initialiseurs de variable](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="4f071-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="4f071-555">L’ordre des effets secondaires est préservé en ce qui concerne les lectures et les écritures volatiles ([champs volatiles](classes.md#volatile-fields)).</span><span class="sxs-lookup"><span data-stu-id="4f071-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="4f071-556">En outre, l’environnement d’exécution n’a pas besoin d’évaluer une partie d’une expression s’il peut déduire que la valeur de cette expression n’est pas utilisée et qu’aucun effet secondaire nécessaire n’est produit (y compris les effets causés par l’appel d’une méthode ou l’accès à un champ volatile).</span><span class="sxs-lookup"><span data-stu-id="4f071-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="4f071-557">Lorsque l’exécution du programme est interrompue par un événement asynchrone (par exemple, une exception levée par un autre thread), il n’est pas garanti que les effets secondaires observables sont visibles dans l’ordre du programme d’origine.</span><span class="sxs-lookup"><span data-stu-id="4f071-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>
