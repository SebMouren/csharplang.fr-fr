# <a name="types"></a><span data-ttu-id="3ee6f-101">Types</span><span class="sxs-lookup"><span data-stu-id="3ee6f-101">Types</span></span>

<span data-ttu-id="3ee6f-102">Les types du langage c# sont divisés en deux catégories principales : ***types valeur*** et ***référencent des types***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="3ee6f-103">Types valeur et types référence peuvent être ***types génériques***, qui accepte un ou plusieurs ***paramètres de type***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="3ee6f-104">Paramètres de type peuvent désigner les deux types valeur et types référence.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="3ee6f-105">La dernière catégorie de types, des pointeurs, est disponible uniquement dans du code unsafe.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="3ee6f-106">Ce sujet est abordé plus en détail dans [types pointeur](unsafe-code.md#pointer-types).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="3ee6f-107">Types valeur diffèrent des types référence dans la mesure où les variables des types valeur contiennent directement leurs données, tandis que le magasin de types de variables de la référence ***références*** à leurs données, ce dernier connu en tant que ***objets***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="3ee6f-108">Avec les types référence, il est possible de deux variables référencent le même objet et par conséquent, les opérations sur une variable peuvent affecter l’objet référencé par l’autre variable.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="3ee6f-109">Avec les types valeur, les variables disposent chacune leur propre copie des données, et il n’est pas possible pour les opérations sur une d’affecter l’autre.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="3ee6f-110">Système de type de # est unifié afin qu’une valeur de n’importe quel type peut être traitée en tant qu’objet.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="3ee6f-111">Chaque type dans C# dérive directement ou indirectement du type `object`, et `object` est la classe de base fondamentale de tous les types.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="3ee6f-112">Les valeurs des types référence sont considérées comme des objets simplement en affichant les valeurs en tant que type `object`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="3ee6f-113">Valeurs des types valeur sont traitées en tant qu’objets en effectuant les opérations de boxing et unboxing ([Boxing et unboxing](types.md#boxing-and-unboxing)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="3ee6f-114">Types de valeur</span><span class="sxs-lookup"><span data-stu-id="3ee6f-114">Value types</span></span>

<span data-ttu-id="3ee6f-115">Un type valeur est un type struct ou un type d’énumération.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="3ee6f-116">C# fournit un ensemble de types struct prédéfinis appelés les ***types simples***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="3ee6f-117">Les types simples sont identifiés par des mots réservés.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="3ee6f-118">Contrairement à une variable d’un type référence, une variable d’un type valeur peut contenir la valeur `null` uniquement si le type de valeur est un type nullable.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="3ee6f-119">Pour chaque type de valeur non nullable, il existe un type valeur nullable correspondant qui dénote le même ensemble de valeurs, ainsi que la valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="3ee6f-120">Assignation à une variable d’un type valeur crée une copie de la valeur assignée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="3ee6f-121">Cela diffère d’affectation à une variable de type référence, qui copie la référence mais pas l’objet identifié par la référence.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="3ee6f-122">Le type System.ValueType</span><span class="sxs-lookup"><span data-stu-id="3ee6f-122">The System.ValueType type</span></span>

<span data-ttu-id="3ee6f-123">Tous les types valeur héritent implicitement de la classe `System.ValueType`, qui, à son tour, hérite de la classe `object`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="3ee6f-124">Il n’est pas possible pour n’importe quel type de dériver à partir d’un type valeur et types valeur sont sealed donc implicitement ([des classes Sealed](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="3ee6f-125">Notez que `System.ValueType` n’est pas lui-même un *value_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="3ee6f-126">Au lieu de cela, il est un *class_type* à partir de laquelle toutes les *value_type*s sont automatiquement dérivées.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="3ee6f-127">Constructeurs par défaut</span><span class="sxs-lookup"><span data-stu-id="3ee6f-127">Default constructors</span></span>

<span data-ttu-id="3ee6f-128">Tous les types valeur déclarent implicitement un constructeur d’instance sans paramètre public appelé le ***constructeur par défaut***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="3ee6f-129">Le constructeur par défaut retourne une instance initialisée à zéro, appelée le ***valeur par défaut*** pour le type de valeur :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="3ee6f-130">Pour toutes les *simple_type*s, la valeur par défaut est la valeur produite par un modèle de bit de tous les zéros non significatifs :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="3ee6f-131">Pour `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, et `ulong`, la valeur par défaut est `0`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="3ee6f-132">Pour `char`, la valeur par défaut est `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="3ee6f-133">Pour `float`, la valeur par défaut est `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="3ee6f-134">Pour `double`, la valeur par défaut est `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="3ee6f-135">Pour `decimal`, la valeur par défaut est `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="3ee6f-136">Pour `bool`, la valeur par défaut est `false`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="3ee6f-137">Pour un *type_de_liste* `E`, la valeur par défaut est `0`, converti au type `E`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="3ee6f-138">Pour un *struct_type*, la valeur par défaut est la valeur produite en affectant tous les champs de type valeur leur valeur par défaut et référence de tous les champs de type `null`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="3ee6f-139">Pour un *nullable_type* la valeur par défaut est une instance pour laquelle le `HasValue` propriété a la valeur false et le `Value` propriété n’est pas définie.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="3ee6f-140">La valeur par défaut est également connu sous le ***valeur null*** du type nullable.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="3ee6f-141">Comme tout autre constructeur d’instance, le constructeur par défaut d’un type valeur est appelé en utilisant le `new` opérateur.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="3ee6f-142">Pour des raisons d’efficacité, cette exigence ne vise que l’implémentation génère réellement un appel de constructeur.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="3ee6f-143">Dans l’exemple suivant, les variables `i` et `j` sont initialisés à zéro.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="3ee6f-144">Étant donné que chaque type valeur a implicitement un constructeur d’instance sans paramètre public, il n’est pas possible pour un type struct contenir une déclaration explicite d’un constructeur sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="3ee6f-145">Un type struct est toutefois autorisé à déclarer des constructeurs d’instance paramétrés ([constructeurs](structs.md#constructors)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="3ee6f-146">Types struct</span><span class="sxs-lookup"><span data-stu-id="3ee6f-146">Struct types</span></span>

<span data-ttu-id="3ee6f-147">Un type struct est un type valeur qui peut déclarer des constantes, champs, méthodes, propriétés, indexeurs, opérateurs, constructeurs d’instance, les constructeurs statiques et les types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="3ee6f-148">La déclaration de types struct est décrite dans [déclarations de Struct](structs.md#struct-declarations).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="3ee6f-149">Types simples</span><span class="sxs-lookup"><span data-stu-id="3ee6f-149">Simple types</span></span>

<span data-ttu-id="3ee6f-150">C# fournit un ensemble de types struct prédéfinis appelés les ***types simples***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="3ee6f-151">Les types simples sont identifiés par des mots réservés, mais ces mots réservés sont tout simplement des alias pour les types struct prédéfinis dans le `System` espace de noms, comme décrit dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="3ee6f-152">__Mot réservé__</span><span class="sxs-lookup"><span data-stu-id="3ee6f-152">__Reserved word__</span></span> | <span data-ttu-id="3ee6f-153">__Type d’alias__</span><span class="sxs-lookup"><span data-stu-id="3ee6f-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="3ee6f-154">Puisqu’un type simple alias un type struct, chaque type simple possède des membres.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="3ee6f-155">Par exemple, `int` possède les membres déclarés dans `System.Int32` et les membres hérités de `System.Object`, et les instructions suivantes sont autorisées :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="3ee6f-156">Les types simples diffèrent des autres types struct en ce qu’ils autorisent certaines opérations supplémentaires :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="3ee6f-157">La plupart des types simples permettent de valeurs doit être créé en écrivant *littéraux* ([littéraux](lexical-structure.md#literals)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="3ee6f-158">Par exemple, `123` est un littéral de type `int` et `'a'` est un littéral de type `char`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="3ee6f-159">C# ne prévoit pas pour les littéraux de types struct en général, et non par défaut des valeurs d’autres types struct sont finalement toujours créées par le biais des constructeurs d’instances de ces types struct.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="3ee6f-160">Lorsque les opérandes d’une expression sont toutes les constantes de type simple, il est possible pour le compilateur évaluer l’expression au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="3ee6f-161">Une telle expression est appelée un *constant_expression* ([expressions constantes](expressions.md#constant-expressions)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="3ee6f-162">Expressions impliquant des opérateurs définis par d’autres types struct ne sont pas considérés comme des expressions constantes.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="3ee6f-163">Via `const` déclarations, il est possible de déclarer des constantes des types simples ([constantes](classes.md#constants)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="3ee6f-164">Il n’est pas possible d’avoir des constantes d’autres types struct, mais un résultat similaire est fourni par `static readonly` champs.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="3ee6f-165">Conversions de types simples peuvent participer à l’évaluation des opérateurs de conversion définie par d’autres types struct, mais un opérateur de conversion définie par l’utilisateur ne peut jamais participer d’évaluation d’un autre opérateur défini par l’utilisateur ([version d’évaluation de conversions définies par l’utilisateur](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="3ee6f-166">Types intégraux</span><span class="sxs-lookup"><span data-stu-id="3ee6f-166">Integral types</span></span>

<span data-ttu-id="3ee6f-167">C# prend en charge neuf types intégraux : `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, et `char`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="3ee6f-168">Les types intégraux ont les tailles et les plages de valeurs suivants :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="3ee6f-169">Le `sbyte` type représente 8 bits entiers signés dont les valeurs comprises entre -128 et 127.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="3ee6f-170">Le `byte` type représente des entiers 8 bits non signés avec des valeurs comprises entre 0 et 255.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="3ee6f-171">Le `short` type représente 16 bits entiers signés dont les valeurs comprises entre -32768 et 32767.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="3ee6f-172">Le `ushort` type représente des entiers 16 bits non signés avec des valeurs comprises entre 0 et 65535.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="3ee6f-173">Le `int` type représente 32 bits entiers signés dont les valeurs comprises entre -2147483648 et 2147483647.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="3ee6f-174">Le `uint` type représente des entiers 32 bits non signés avec des valeurs comprises entre 0 et 4294967295.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="3ee6f-175">Le `long` type représente des entiers de 64 bits avec des valeurs comprises entre -9223372036854775808 et 9223372036854775807 signés.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="3ee6f-176">Le `ulong` type représente des entiers 64 bits non signés avec des valeurs comprises entre 0 et 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="3ee6f-177">Le `char` type représente des entiers 16 bits non signés avec des valeurs comprises entre 0 et 65535.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="3ee6f-178">Le jeu de valeurs possibles pour le `char` type correspond au jeu de caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="3ee6f-179">Bien que `char` possède la même représentation en tant que `ushort`, pas toutes les opérations autorisées sur un type sont autorisées sur l’autre.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="3ee6f-180">Le type intégral opérateurs unaires et binaires fonctionnent toujours avec précision de 32 bits signée, précision de 32 bits non signée, les précision 64 bits signée ou non signée 64 bits précision :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="3ee6f-181">Dans le cas de `+` et `~` opérateurs, l’opérande est converti en type `T`, où `T` est le premier de `int`, `uint`, `long`, et `ulong` qui peut représenter entièrement toutes les valeurs possibles de l’opérande.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="3ee6f-182">L’opération est ensuite effectuée à l’aide de la précision du type `T`, et le type du résultat est `T`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="3ee6f-183">Dans le cas de `-` opérateur, l’opérande est converti en type `T`, où `T` est le premier de `int` et `long` qui peut représenter entièrement toutes les valeurs possibles de l’opérande.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="3ee6f-184">L’opération est ensuite effectuée à l’aide de la précision du type `T`, et le type du résultat est `T`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="3ee6f-185">L’unaire `-` opérateur ne peut pas être appliqué aux opérandes de type `ulong`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="3ee6f-186">Pour le fichier binaire `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, et `<=` opérateurs, les opérandes sont convertis en type `T`, où `T` est le premier de `int`, `uint`, `long`, et `ulong` qui peut représenter entièrement toutes les possibles valeurs des deux opérandes.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="3ee6f-187">L’opération est ensuite effectuée à l’aide de la précision du type `T`, et le type du résultat est `T` (ou `bool` pour les opérateurs relationnels).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="3ee6f-188">Il n’est pas autorisée pour un opérande de type `long` et l’autre pour être de type `ulong` avec les opérateurs binaires.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="3ee6f-189">Pour le fichier binaire `<<` et `>>` opérateurs, l’opérande gauche est converti en type `T`, où `T` est le premier de `int`, `uint`, `long`, et `ulong` qui peut représenter entièrement toutes les valeurs possibles de l’opérande.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="3ee6f-190">L’opération est ensuite effectuée à l’aide de la précision du type `T`, et le type du résultat est `T`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="3ee6f-191">Le `char` type est classé comme un type intégral, mais il diffère des autres types intégraux de deux manières :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="3ee6f-192">Aucune conversion implicite des autres types vers le `char` type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="3ee6f-193">En particulier, même si le `sbyte`, `byte`, et `ushort` types ont des plages de valeurs qui sont entièrement pouvant être représentées à l’aide de la `char` tapez, les conversions implicites de `sbyte`, `byte`, ou `ushort` à `char` n’existent pas.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="3ee6f-194">Constantes de la `char` type doit être écrites en tant que *character_literal*s ou en tant que *integer_literal*s en combinaison avec un cast en type `char`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="3ee6f-195">Par exemple, `(char)10` est identique à `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="3ee6f-196">Le `checked` et `unchecked` instructions et opérateurs sont utilisées pour contrôler le contrôle de dépassement pour les opérations arithmétiques de type intégral et les conversions ([les opérateurs checked et unchecked](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="3ee6f-197">Dans un `checked` contexte, un dépassement de capacité génère une erreur de compilation ou provoque un `System.OverflowException` levée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="3ee6f-198">Dans un `unchecked` contexte, dépassements de capacité sont ignorés et tous les bits de poids fort qui ne tiennent pas dans le type de destination sont ignorées.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="3ee6f-199">Types à virgule flottante</span><span class="sxs-lookup"><span data-stu-id="3ee6f-199">Floating point types</span></span>

<span data-ttu-id="3ee6f-200">C# prend en charge deux types à virgule flottante : `float` et `double`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="3ee6f-201">Le `float` et `double` types sont représentés en utilisant les 32 bits simple précision et 64 bits double précision IEEE 754 formats, qui fournissent des ensembles de valeurs suivants :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="3ee6f-202">Positif zéro et zéro négatif.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-202">Positive zero and negative zero.</span></span> <span data-ttu-id="3ee6f-203">Dans la plupart des cas, un zéro positif et négatif zéro se comportent de façon identique que la simple valeur zéro, mais certaines opérations de faire la distinction entre les deux ([opérateur de Division](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="3ee6f-204">L’infini positif et infini négatif.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="3ee6f-205">Infinis sont produites par des opérations telles que la division par zéro d’un nombre différent de zéro.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="3ee6f-206">Par exemple, `1.0 / 0.0` génère l’infini positif, et `-1.0 / 0.0` l’infini négatif.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="3ee6f-207">Le ***Not-a-Number*** valeur, souvent abrégé NaN.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="3ee6f-208">Valeurs NaN sont produites par des opérations à virgule flottante non valides, telles que la division de zéro par zéro.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="3ee6f-209">L’ensemble fini de valeurs non nulles de l’écran `s * m * 2^e`, où `s` est 1 ou -1, et `m` et `e` sont déterminés par le type à virgule flottante particulier : pour `float`, `0 < m < 2^24` et `-149 <= e <= 104`et pour `double`, `0 < m < 2^53` et `1075 <= e <= 970`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `1075 <= e <= 970`.</span></span> <span data-ttu-id="3ee6f-210">Les nombres à virgule flottante dénormalisés sont considérés comme des valeurs non nulles valides.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="3ee6f-211">Le `float` type peut représenter des valeurs comprises entre environ `1.5 * 10^-45` à `3.4 * 10^38` avec une précision de 7 chiffres.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="3ee6f-212">Le `double` type peut représenter des valeurs comprises entre environ `5.0 * 10^-324` à `1.7 × 10^308` avec une précision de 15-16 chiffres.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="3ee6f-213">Si l’un des opérandes d’un opérateur binaire est d’un type à virgule flottante, puis l’autre opérande doit être d’un type intégral ou d’un type à virgule flottante, et l’opération est évaluée comme suit :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="3ee6f-214">Si l’un des opérandes est de type intégral, cet opérande est converti vers le type à virgule flottante de l’autre opérande.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="3ee6f-215">Ensuite, si un des opérandes est de type `double`, l’autre opérande est converti en `double`, l’opération est effectuée à l’aide au moins `double` plage et précision et le type du résultat est `double` (ou `bool` pour le opérateurs relationnels).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="3ee6f-216">Sinon, l’opération est effectuée à l’aide au moins `float` plage et précision et le type du résultat est `float` (ou `bool` pour les opérateurs relationnels).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="3ee6f-217">Les opérateurs à virgule flottante, y compris les opérateurs d’assignation, produisent jamais d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="3ee6f-218">Au lieu de cela, dans des situations exceptionnelles, les opérations à virgule flottante produisent zéro, l’infini ou NaN, comme décrit ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="3ee6f-219">Si le résultat d’une opération à virgule flottante est trop petit pour le format de destination, le résultat de l’opération devient le zéro positif ou zéro négatif.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="3ee6f-220">Si le résultat d’une opération à virgule flottante est trop grand pour le format de destination, le résultat de l’opération devient l’infini positif ou l’infini négatif.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="3ee6f-221">Si une opération à virgule flottante n’est pas valide, le résultat de l’opération devient une NaN.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="3ee6f-222">Si un ou deux opérandes d’une opération à virgule flottante est NaN, le résultat de l’opération devient une NaN.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="3ee6f-223">Les opérations à virgule flottante peuvent être exécutées avec une précision plus élevée que le type de résultat de l’opération.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="3ee6f-224">Par exemple, certaines architectures matérielles prennent en charge un type à virgule flottante « étendu » ou « long double » avec la plage supérieure et une précision à la `double` tapez, puis appliquer implicitement toutes les opérations à virgule flottante à l’aide de ce type de précision plus élevé.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="3ee6f-225">Qu’au prix de performances ces architectures matérielles est possible d’effectuer des opérations à virgule flottante avec moins de précision, et plutôt que d’imposer une implémentation se dérouler au détriment des performances et précision, c# autorise un type de précision plus élevé être utilisé pour toutes les opérations à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="3ee6f-226">Autres que des résultats plus précis, cette méthode présente rarement des effets mesurables.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="3ee6f-227">Toutefois, dans les expressions de la forme `x * y / z`, où la multiplication produit un résultat qui est en dehors de la `double` plage, mais la division qui suit affiche le résultat temporaire dans le `double` de plage, le fait que l’expression est évaluée dans une plage plus haute format peut provoquer un résultat fini à produire au lieu d’un nombre infini.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="3ee6f-228">Le type decimal</span><span class="sxs-lookup"><span data-stu-id="3ee6f-228">The decimal type</span></span>

<span data-ttu-id="3ee6f-229">Le type `decimal` est un type de données 128 bits adapté aux calculs financiers et monétaires.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="3ee6f-230">Le `decimal` type peut représenter des valeurs comprises entre `1.0 * 10^-28` à environ `7.9 * 10^28` avec 28-29 chiffres significatifs.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="3ee6f-231">L’ensemble fini de valeurs de type `decimal` présentent sous la forme `(-1)^s * c * 10^-e`, où le signe `s` est 0 ou 1, le coefficient `c` est donnée par `0 <= *c* < 2^96`et l’échelle `e` est telle que `0 <= e <= 28`. Le `decimal` type ne prend pas en charge les zéros signés, infinis ou NaN.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="3ee6f-232">Un `decimal` est représentée comme un entier 96 bits mis à l’échelle par une puissance de dix.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="3ee6f-233">Pour `decimal`s avec une valeur absolue inférieure à `1.0m`, la valeur est exacte jusqu'à la 28ème décimale, mais pas plus loin.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="3ee6f-234">Pour `decimal`s avec une valeur absolue supérieure ou égale à `1.0m`, la valeur est exacte à 28 ou 29 chiffres.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="3ee6f-235">Contraire au `float` et `double` des types de données, des nombres fractionnaires décimaux, comme 0,1 peuvent être représentées exactement dans le `decimal` représentation.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="3ee6f-236">Dans le `float` et `double` représentations, ces nombres sont souvent des fractions infinies, rendre ces représentations plus propices à arrondi erreurs.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="3ee6f-237">Si l’un des opérandes d’un opérateur binaire est de type `decimal`, puis l’autre opérande doit être de type intégral ou de type `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="3ee6f-238">Si un opérande de type intégral est présent, il est converti en `decimal` avant l’opération est effectuée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="3ee6f-239">Le résultat d’une opération sur les valeurs de type `decimal` est que qui résulterait de calcul d’un résultat exact (préservation mise à l’échelle, comme défini pour chaque opérateur) et ensuite arrondi pour s’ajuster à la représentation.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="3ee6f-240">Les résultats sont arrondis à la plus proche de la valeur représentable, et que, lorsqu’un résultat est proche de deux valeurs représentables, à la valeur qui a un nombre pair à la position de chiffre moins significatif (cela est appelé « l’arrondi bancaire »).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="3ee6f-241">Un zéro résultat a toujours un signe de 0 et une échelle de 0.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="3ee6f-242">Si une opération arithmétique décimale produit une valeur inférieure ou égale à `5 * 10^-29` en valeur absolue, le résultat de l’opération devient égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="3ee6f-243">Si un `decimal` opération arithmétique produit un résultat qui est trop grand pour le `decimal` format, un `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="3ee6f-244">Le `decimal` type a une précision supérieure, mais de plus petite plage que les types à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="3ee6f-245">Par conséquent, les conversions de types à virgule flottante `decimal` peut générer des exceptions de dépassement de capacité et les conversions de `decimal` pour les types à virgule flottante peut entraîner une perte de précision.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="3ee6f-246">Pour ces raisons, n’existe aucune conversion implicite entre les types à virgule flottante et `decimal`, et sans cast explicite, il n’est pas possible de combiner à virgule flottante et `decimal` opérandes dans la même expression.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="3ee6f-247">Le type bool</span><span class="sxs-lookup"><span data-stu-id="3ee6f-247">The bool type</span></span>

<span data-ttu-id="3ee6f-248">Le `bool` type représente des quantités logiques booléennes.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="3ee6f-249">Les valeurs possibles de type `bool` sont `true` et `false`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="3ee6f-250">Il n’existe aucune conversion standard entre `bool` et d’autres types.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="3ee6f-251">En particulier, le `bool` type est distinct et indépendant des types intégraux et un `bool` valeur ne peut pas être utilisée à la place d’une valeur intégrale et vice versa.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="3ee6f-252">Dans les langages C et C++, une valeur zéro intégrale ou à virgule flottante ou un pointeur null peut être converti à la valeur booléenne `false`, et une valeur intégrale ou à virgule flottante de zéro ou un pointeur non null peut être converti en la valeur booléenne `true`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="3ee6f-253">En c#, ces conversions sont accomplies en comparant explicitement une valeur intégrale ou à virgule flottante à zéro ou en comparant explicitement une référence d’objet `null`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="3ee6f-254">Types d'énumération</span><span class="sxs-lookup"><span data-stu-id="3ee6f-254">Enumeration types</span></span>

<span data-ttu-id="3ee6f-255">Un type d’énumération est un type distinct avec des constantes nommées.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="3ee6f-256">Chaque type énumération a un type sous-jacent, ce qui doit être `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` ou `ulong`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="3ee6f-257">L’ensemble de valeurs du type énumération est identique à l’ensemble de valeurs du type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="3ee6f-258">Valeurs du type énumération ne sont pas limitées aux valeurs des constantes nommées.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="3ee6f-259">Types énumération sont définies dans des déclarations d’énumération ([les déclarations Enum](enums.md#enum-declarations)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="3ee6f-260">Types Nullable</span><span class="sxs-lookup"><span data-stu-id="3ee6f-260">Nullable types</span></span>

<span data-ttu-id="3ee6f-261">Un type nullable peut représenter toutes les valeurs de ses ***type sous-jacent*** ainsi que d’une valeur null supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="3ee6f-262">Un type nullable est écrit `T?`, où `T` est le type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="3ee6f-263">Cette syntaxe est l’abréviation de `System.Nullable<T>`, et les deux formes peuvent être utilisés indifféremment.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="3ee6f-264">Un ***type valeur non nullable*** à l’inverse est n’importe quel type de valeur autre que `System.Nullable<T>` et son raccourci `T?` (pour tout `T`), ainsi que n’importe quel paramètre de type est contraint à être un type valeur non nullable (autrement dit, tout paramètre de type avec un `struct` contrainte).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="3ee6f-265">Le `System.Nullable<T>` type spécifie la contrainte de type de valeur pour `T` ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)), ce qui signifie que le type sous-jacent d’un type nullable peut être n’importe quel type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="3ee6f-266">Le type sous-jacent d’un type nullable ne peut pas être un type nullable ou un type référence.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="3ee6f-267">Par exemple, `int??` et `string?` sont des types non valides.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="3ee6f-268">Une instance d’un type nullable `T?` a deux propriétés publiques en lecture seule :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="3ee6f-269">Un `HasValue` propriété de type `bool`</span><span class="sxs-lookup"><span data-stu-id="3ee6f-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="3ee6f-270">Un `Value` propriété de type `T`</span><span class="sxs-lookup"><span data-stu-id="3ee6f-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="3ee6f-271">Instance pour laquelle `HasValue` est la valeur true est dite non null.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="3ee6f-272">Une instance non null contient une valeur connue et `Value` retourne cette valeur.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="3ee6f-273">Instance pour laquelle `HasValue` est false est dite avoir la valeur null.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="3ee6f-274">Une instance null a une valeur non définie.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-274">A null instance has an undefined value.</span></span> <span data-ttu-id="3ee6f-275">Une tentative de lecture la `Value` d’une instance null provoque un `System.InvalidOperationException` levée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="3ee6f-276">Le processus de l’accès à la `Value` propriété d’une instance nullable est appelée ***désencapsulage***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="3ee6f-277">Outre le constructeur par défaut, tous les types nullable `T?` a un constructeur public qui accepte un seul argument de type `T`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="3ee6f-278">Une valeur donnée `x` de type `T`, un appel de constructeur du formulaire</span><span class="sxs-lookup"><span data-stu-id="3ee6f-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="3ee6f-279">Crée une instance non null de `T?` pour lequel le `Value` propriété est `x`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="3ee6f-280">Le processus de création d’une instance non null d’un type nullable pour une valeur donnée est appelée ***encapsulant***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="3ee6f-281">Les conversions implicites sont disponibles à partir de la `null` littéral `T?` ([Null littérales conversions](conversions.md#null-literal-conversions)) et à partir de `T` à `T?` ([les conversions implicites nullables](conversions.md#implicit-nullable-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="3ee6f-282">Types référence</span><span class="sxs-lookup"><span data-stu-id="3ee6f-282">Reference types</span></span>

<span data-ttu-id="3ee6f-283">Un type référence est un type de classe, un type d’interface, un type tableau ou un type délégué.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="3ee6f-284">Une valeur de type référence est une référence à un ***instance*** du type, connues sous le nom de ce dernier un ***objet***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="3ee6f-285">La valeur spéciale `null` est compatible avec tous les types référence et indique l’absence d’une instance.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="3ee6f-286">Types de classes</span><span class="sxs-lookup"><span data-stu-id="3ee6f-286">Class types</span></span>

<span data-ttu-id="3ee6f-287">Un type de classe définit une structure de données qui contient les données membres (constantes et champs), des fonctions membres (méthodes, propriétés, événements, indexeurs, opérateurs, constructeurs d’instance, destructeurs et constructeurs statiques) et les types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="3ee6f-288">Types de classes prend en charge l’héritage, un mécanisme par lequel les classes dérivées peuvent étendre et spécialiser les classes de base.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="3ee6f-289">Instances de types de classe sont créées à l’aide de *object_creation_expression*s ([des expressions de la création d’objet](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="3ee6f-290">Types de classe sont décrits dans [Classes](classes.md).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="3ee6f-291">Certains types de classe prédéfinis ont une signification spéciale dans le langage c#, comme décrit dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="3ee6f-292">__Type de classe__</span><span class="sxs-lookup"><span data-stu-id="3ee6f-292">__Class type__</span></span>     | <span data-ttu-id="3ee6f-293">__Description__</span><span class="sxs-lookup"><span data-stu-id="3ee6f-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="3ee6f-294">La classe de base fondamentale de tous les autres types.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="3ee6f-295">Consultez [le type d’objet](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="3ee6f-296">Le type de chaîne du langage c#.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-296">The string type of the C# language.</span></span> <span data-ttu-id="3ee6f-297">Consultez [le type de chaîne](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="3ee6f-298">La classe de base de tous les types de valeur.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-298">The base class of all value types.</span></span> <span data-ttu-id="3ee6f-299">Consultez [System.ValueType le type](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="3ee6f-300">La classe de base de tous les types enum.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-300">The base class of all enum types.</span></span> <span data-ttu-id="3ee6f-301">Consultez [Enums](enums.md).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="3ee6f-302">La classe de base de tous les types tableau.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-302">The base class of all array types.</span></span> <span data-ttu-id="3ee6f-303">Consultez [Tableaux](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="3ee6f-304">La classe de base de tous les types délégués.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-304">The base class of all delegate types.</span></span> <span data-ttu-id="3ee6f-305">Consultez [délégués](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="3ee6f-306">La classe de base de tous les types d’exception.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-306">The base class of all exception types.</span></span> <span data-ttu-id="3ee6f-307">Consultez [Exceptions](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="3ee6f-308">Le type d’objet</span><span class="sxs-lookup"><span data-stu-id="3ee6f-308">The object type</span></span>

<span data-ttu-id="3ee6f-309">Le `object` type de classe est la classe de base fondamentale de tous les autres types.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="3ee6f-310">Chaque type dans c# dérive directement ou indirectement le `object` type de classe.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="3ee6f-311">Le mot clé `object` est simplement un alias de la classe prédéfinie `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="3ee6f-312">Le type dynamique</span><span class="sxs-lookup"><span data-stu-id="3ee6f-312">The dynamic type</span></span>

<span data-ttu-id="3ee6f-313">Le `dynamic` Entrez comme `object`, peut faire référence à n’importe quel objet.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="3ee6f-314">Lorsque les opérateurs sont appliqués à des expressions de type `dynamic`, leur résolution est différée jusqu'à ce que le programme est exécuté.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="3ee6f-315">Par conséquent, si l’opérateur légalement ne peut pas être appliqué qu’à l’objet référencé, aucune erreur n’est donné pendant la compilation.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="3ee6f-316">À la place une exception est levée en cas d’échec de résolution de l’opérateur au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="3ee6f-317">Son but est de permettre la liaison dynamique, qui est décrite en détail dans [liaison dynamique](expressions.md#dynamic-binding).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="3ee6f-318">`dynamic` est considéré comme identique au `object` sauf dans les points suivants :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="3ee6f-319">Opérations sur les expressions de type `dynamic` peut être liée de manière dynamique ([liaison dynamique](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="3ee6f-320">Inférence de type ([l’inférence de Type](expressions.md#type-inference)) préféreront `dynamic` sur `object` si les deux sont des candidats.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="3ee6f-321">En raison de l’équivalence, les blocages suivantes :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="3ee6f-322">Il existe une conversion implicite d’identité entre `object` et `dynamic`et entre les types construits sont les mêmes lors du remplacement `dynamic` avec `object`</span><span class="sxs-lookup"><span data-stu-id="3ee6f-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="3ee6f-323">Les conversions implicites et explicites vers et depuis `object` s’appliquent également vers et depuis `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="3ee6f-324">Les signatures de méthode sont les mêmes lors du remplacement `dynamic` avec `object` sont considérés comme la même signature</span><span class="sxs-lookup"><span data-stu-id="3ee6f-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="3ee6f-325">Le type `dynamic` est indiscernable `object` au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="3ee6f-326">Une expression de type `dynamic` est appelé un ***expression dynamique***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="3ee6f-327">Le type de chaîne</span><span class="sxs-lookup"><span data-stu-id="3ee6f-327">The string type</span></span>

<span data-ttu-id="3ee6f-328">Le `string` type est un type classe sealed qui hérite directement de `object`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="3ee6f-329">Instances de la `string` classe représentent les chaînes de caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="3ee6f-330">Valeurs de la `string` type peut être écrit en tant que littéraux de chaîne ([littéraux de chaîne](lexical-structure.md#string-literals)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="3ee6f-331">Le mot clé `string` est simplement un alias de la classe prédéfinie `System.String`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="3ee6f-332">Types interface</span><span class="sxs-lookup"><span data-stu-id="3ee6f-332">Interface types</span></span>

<span data-ttu-id="3ee6f-333">Une interface définit un contrat.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-333">An interface defines a contract.</span></span> <span data-ttu-id="3ee6f-334">Une classe ou un struct qui implémente une interface doit adhérer à ce contrat.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="3ee6f-335">Une interface peut hériter de plusieurs interfaces de base, et une classe ou un struct peut implémenter plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="3ee6f-336">Types d’interface sont décrits dans [Interfaces](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="3ee6f-337">Types de tableaux</span><span class="sxs-lookup"><span data-stu-id="3ee6f-337">Array types</span></span>

<span data-ttu-id="3ee6f-338">Un tableau est une structure de données qui contient zéro ou plusieurs variables qui sont accessibles par le biais des indices calculés.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="3ee6f-339">Les variables contenues dans un tableau, également appelé éléments du tableau, sont tous du même type, et ce type est appelé le type d’élément du tableau.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="3ee6f-340">Les types tableau sont décrits dans [tableaux](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="3ee6f-341">Types délégués</span><span class="sxs-lookup"><span data-stu-id="3ee6f-341">Delegate types</span></span>

<span data-ttu-id="3ee6f-342">Un délégué est une structure de données qui fait référence à une ou plusieurs méthodes.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="3ee6f-343">Par exemple méthodes, il fait également référence à leurs instances d’objet correspondant.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="3ee6f-344">L’équivalent le plus proche d’un délégué en C ou C++ est un pointeur de fonction, mais tandis que les fonctions statiques ne peut référencer qu’un pointeur de fonction, un délégué peut faire référence à la fois static et méthodes d’instance.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="3ee6f-345">Dans ce cas, le délégué stocke non seulement une référence au point d’entrée de la méthode, mais également une référence à l’instance d’objet sur lequel appeler la méthode.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="3ee6f-346">Types délégués sont décrits dans [délégués](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="3ee6f-347">Boxing et unboxing</span><span class="sxs-lookup"><span data-stu-id="3ee6f-347">Boxing and unboxing</span></span>

<span data-ttu-id="3ee6f-348">Le concept de boxing et unboxing est central au système de type de #.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="3ee6f-349">Il fournit un pont entre *value_type*s et *reference_type*s en permettant de n’importe quelle valeur d’un *value_type* à convertir vers et à partir de type `object`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="3ee6f-350">Boxing et unboxing permettent une vue unifiée du système de type dans lequel une valeur de n’importe quel type peut finalement être traitée en tant qu’objet.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="3ee6f-351">Conversions boxing</span><span class="sxs-lookup"><span data-stu-id="3ee6f-351">Boxing conversions</span></span>

<span data-ttu-id="3ee6f-352">Une conversion boxing permet un *value_type* être implicitement converti dans un *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="3ee6f-353">Les conversions boxing suivantes existent :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="3ee6f-354">À partir d’un *value_type* au type `object`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="3ee6f-355">À partir d’un *value_type* au type `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="3ee6f-356">À partir d’un *non_nullable_value_type* aux *interface_type* implémentée par le *value_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="3ee6f-357">À partir d’un *nullable_type* aux *interface_type* implémentée par le type sous-jacent de la *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="3ee6f-358">À partir d’un *type_de_liste* au type `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="3ee6f-359">À partir d’un *nullable_type* avec sous-jacent *type_de_liste* au type `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="3ee6f-360">Notez qu’une conversion implicite d’un paramètre de type sera exécutée en tant qu’une conversion boxing si au moment de l’exécution il finit par conversion à partir d’un type valeur à un type référence ([conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="3ee6f-361">Conversion boxing d’une valeur un *non_nullable_value_type* se compose d’allouer une instance d’objet et à copier le *non_nullable_value_type* valeur dans cette instance.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="3ee6f-362">Conversion boxing d’une valeur un *nullable_type* génère une référence null s’il s’agit du `null` valeur (`HasValue` est `false`), ou le résultat de dévoilement et boxing de la valeur sous-jacente dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="3ee6f-363">Le processus de conversion boxing d’une valeur un *non_nullable_value_type* explique parfaitement d’imaginer l’existence d’un générique ***classe de boxing***, qui se comporte comme s’il était déclaré comme suit :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="3ee6f-364">Le boxing d’une valeur `v` de type `T` maintenant se compose de l’exécution de l’expression `new Box<T>(v)`et en retournant l’instance obtenue en tant que valeur de type `object`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="3ee6f-365">Par conséquent, les instructions</span><span class="sxs-lookup"><span data-stu-id="3ee6f-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="3ee6f-366">sur le plan conceptuel correspondent aux</span><span class="sxs-lookup"><span data-stu-id="3ee6f-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="3ee6f-367">Une classe de boxing comme `Box<T>` ci-dessus n’en existe pas et le type dynamique d’une valeur boxed n’est pas réellement un type de classe.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="3ee6f-368">Au lieu de cela, une valeur boxed du type `T` a le type dynamique `T`et une validation de type dynamique à l’aide de la `is` opérateur peut référencer tout simplement de type `T`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="3ee6f-369">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="3ee6f-370">génère la chaîne «`Box contains an int`» sur la console.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="3ee6f-371">Une conversion boxing implique effectuant une copie de la valeur convertie.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="3ee6f-372">Cela est différent de la conversion d’un *reference_type* à taper `object`, dans laquelle la valeur continue à référencer la même instance et simplement est considérée comme le type moins dérivé `object`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="3ee6f-373">Par exemple, prenons la déclaration</span><span class="sxs-lookup"><span data-stu-id="3ee6f-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="3ee6f-374">les instructions suivantes</span><span class="sxs-lookup"><span data-stu-id="3ee6f-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="3ee6f-375">génère la valeur 10 sur la console, car l’opération de conversion boxing implicite se produit dans l’attribution de `p` à `box` provoque la valeur de `p` doit être copié.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="3ee6f-376">Avait `Point` été déclaré un `class` au lieu de cela, la valeur 20 serait sortie car `p` et `box` serait référencent la même instance.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="3ee6f-377">Conversions unboxing</span><span class="sxs-lookup"><span data-stu-id="3ee6f-377">Unboxing conversions</span></span>

<span data-ttu-id="3ee6f-378">Une conversion unboxing permet une *reference_type* pour être converti explicitement en un *value_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="3ee6f-379">Les conversions unboxing suivantes existent :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="3ee6f-380">À partir du type `object` aux *value_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="3ee6f-381">À partir du type `System.ValueType` aux *value_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="3ee6f-382">À partir d’un *interface_type* aux *non_nullable_value_type* qui implémente le *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="3ee6f-383">À partir d’un *interface_type* aux *nullable_type* dont le type implémente le *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="3ee6f-384">À partir du type `System.Enum` aux *type_de_liste*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="3ee6f-385">À partir du type `System.Enum` aux *nullable_type* avec sous-jacent *type_de_liste*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="3ee6f-386">Notez qu’une conversion explicite à un paramètre de type sera exécutée en tant qu’une conversion unboxing si au moment de l’exécution il finit par conversion à partir d’un type référence à un type valeur ([les conversions explicites dynamiques](conversions.md#explicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="3ee6f-387">Une opération d’unboxing pour un *non_nullable_value_type* consistant à vérifier au préalable que l’instance d’objet est une valeur boxed de la donnée *non_nullable_value_type*, puis copiez la valeur de la instance.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="3ee6f-388">Unboxing à un *nullable_type* produit la valeur null de la *nullable_type* si l’opérande source est `null`, ou le résultat inclus dans un wrapper d’unboxing de l’instance d’objet pour le type sous-jacent de la *nullable_type* dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="3ee6f-389">Qui fait référence à la classe de boxing imaginaire décrite dans la section précédente, une conversion unboxing d’un objet `box` à un *value_type* `T` se compose de l’exécution de l’expression `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="3ee6f-390">Par conséquent, les instructions</span><span class="sxs-lookup"><span data-stu-id="3ee6f-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="3ee6f-391">sur le plan conceptuel correspondent aux</span><span class="sxs-lookup"><span data-stu-id="3ee6f-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="3ee6f-392">Pour une conversion unboxing à une donnée *non_nullable_value_type* pour réussir au moment de l’exécution, la valeur de l’opérande source doit être une référence à une valeur boxed de qui *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="3ee6f-393">Si l’opérande source est `null`, un `System.NullReferenceException` est levée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="3ee6f-394">Si l’opérande source est une référence à un objet incompatible, un `System.InvalidCastException` est levée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="3ee6f-395">Pour une conversion unboxing à une donnée *nullable_type* pour réussir au moment de l’exécution, la valeur de l’opérande source doit être `null` ou une référence à une valeur boxed de sous-jacent *non_nullable_value_type* de la *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="3ee6f-396">Si l’opérande source est une référence à un objet incompatible, un `System.InvalidCastException` est levée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="3ee6f-397">Types construits</span><span class="sxs-lookup"><span data-stu-id="3ee6f-397">Constructed types</span></span>

<span data-ttu-id="3ee6f-398">Une déclaration de type générique, en soi, désigne un ***indépendants de type générique*** qui est utilisé comme un « plan » pour former des différents types, par le biais d’application ***arguments de type***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="3ee6f-399">Les arguments de type sont écrits dans les crochets pointus (`<` et `>`) immédiatement après le nom du type générique.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="3ee6f-400">Un type qui inclut au moins un argument de type est appelé un ***type construit***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="3ee6f-401">Un type construit peut être utilisé dans la plupart des endroits du langage dans lequel un nom de type peut apparaître.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="3ee6f-402">Un type générique indépendant peut uniquement être utilisé dans un *typeof_expression* ([l’opérateur typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="3ee6f-403">Types construits peuvent également servir dans les expressions des noms simples ([noms simples](expressions.md#simple-names)) ou lors de l’accès à un membre ([l’accès au membre](expressions.md#member-access)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="3ee6f-404">Quand un *namespace_or_type_name* est évaluées, seuls les types génériques avec le nombre correct de paramètres sont considérés comme de type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="3ee6f-405">Par conséquent, il est possible d’utiliser le même identificateur pour identifier les différents types, tant que les types ont des nombres différents de paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="3ee6f-406">Cela est utile lorsque vous combinez des classes génériques et non génériques dans le même programme :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="3ee6f-407">Un *type_name* peut identifier un type construit même si elle ne spécifie pas directement les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="3ee6f-408">Cela peut se produire où un type est imbriqué dans une déclaration de classe générique, et le type d’instance de la déclaration du conteneur est implicitement utilisé pour la recherche de nom ([les types dans les classes génériques imbriqués](classes.md#nested-types-in-generic-classes)) :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="3ee6f-409">Dans du code unsafe, un type construit ne peut pas être utilisé comme un *unmanaged_type* ([types pointeur](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="3ee6f-410">Arguments de type</span><span class="sxs-lookup"><span data-stu-id="3ee6f-410">Type arguments</span></span>

<span data-ttu-id="3ee6f-411">Chaque argument dans une liste d’arguments de type est simplement un *type*.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="3ee6f-412">Dans du code unsafe ([code Unsafe](unsafe-code.md)), un *type_argument* ne peut pas être un type pointeur.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="3ee6f-413">Chaque argument de type doit satisfaire toutes les contraintes sur le correspondant le paramètre de type ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="3ee6f-414">Types ouverts et fermés</span><span class="sxs-lookup"><span data-stu-id="3ee6f-414">Open and closed types</span></span>

<span data-ttu-id="3ee6f-415">Tous les types peuvent être classés comme étant ***types ouverts*** ou ***fermé types***.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="3ee6f-416">Un type ouvert est un type qui implique des paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="3ee6f-417">Plus précisément :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-417">More specifically:</span></span>

*  <span data-ttu-id="3ee6f-418">Un paramètre de type définit un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="3ee6f-419">Un type tableau est un type ouvert si et seulement si son type d’élément est un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="3ee6f-420">Un type construit est un type ouvert si et seulement si un ou plusieurs de ses arguments de type sont un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="3ee6f-421">Un type imbriqué construit est un type ouvert si et seulement si un ou plusieurs de ses arguments de type ou de son ou ses types contenant les arguments de type sont un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="3ee6f-422">Un type fermé est un type qui n’est pas un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="3ee6f-423">Au moment de l’exécution, tout le code dans une déclaration de type générique est exécutée dans le contexte d’un type construit fermé qui a été créé en appliquant des arguments de type à la déclaration générique.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="3ee6f-424">Chaque paramètre de type dans le type générique est lié à un type particulier d’exécution.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="3ee6f-425">L’exécution du traitement de toutes les instructions et expressions toujours se produit avec les types fermés, et les types ouverts se produisent uniquement pendant la compilation traitement.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="3ee6f-426">Chaque type construit fermé possède son propre ensemble de variables statiques qui ne sont pas partagés avec d’autres types construits fermés.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="3ee6f-427">Dans la mesure où un type ouvert n’existe pas au moment de l’exécution, il n’existe aucune variable statique associée à un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="3ee6f-428">Deux types construits fermés sont du même type si elles sont construites à partir du même type générique indépendant et leurs arguments de type correspondant sont du même type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="3ee6f-429">Types dépendants et indépendants</span><span class="sxs-lookup"><span data-stu-id="3ee6f-429">Bound and unbound types</span></span>

<span data-ttu-id="3ee6f-430">Le terme ***indépendant du type*** fait référence à un type non générique ou un type générique indépendant.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="3ee6f-431">Le terme ***lié de type*** fait référence à un type non générique ou un type construit.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="3ee6f-432">Un type indépendant fait référence à l’entité déclarée par une déclaration de type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="3ee6f-433">Un type générique indépendant n’est pas lui-même un type et ne peut pas être utilisé comme type d’une variable, l’argument ou la valeur de retour ou comme type de base.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="3ee6f-434">La seule construction dans lequel un type générique indépendant peut être référencé est la `typeof` expression ([l’opérateur typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="3ee6f-435">Contraintes satisfaisantes</span><span class="sxs-lookup"><span data-stu-id="3ee6f-435">Satisfying constraints</span></span>

<span data-ttu-id="3ee6f-436">Chaque fois qu’un type construit ou une méthode générique est référencé, les arguments de type fourni sont vérifiées sur les contraintes de paramètre de type déclarés sur le type générique ou la méthode ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="3ee6f-437">Pour chaque `where` clause, l’argument de type `A` qui correspond au paramètre de type est vérifié par rapport à chaque contrainte comme suit :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="3ee6f-438">Si la contrainte est un type de classe, un type d’interface ou un paramètre de type, laissez `C` représentent que contrainte avec les arguments de type fourni est remplacé pour tous les paramètres de type qui s’affichent dans la contrainte.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="3ee6f-439">Pour satisfaire la contrainte, il doit être le cas tapez `A` est convertible en type `C` par une des opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="3ee6f-440">Une conversion d’identité ([conversion d’identité](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="3ee6f-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="3ee6f-441">Une conversion de référence implicite ([conversions de référence implicite](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="3ee6f-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="3ee6f-442">Une conversion boxing ([conversions Boxing](conversions.md#boxing-conversions)), à condition que le type A est un type valeur non nullable.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="3ee6f-443">Une conversion du paramètre de référence, boxing ou type implicite à partir d’un paramètre de type `A` à `C`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="3ee6f-444">Si la contrainte est la contrainte de type référence (`class`), le type `A` doit satisfaire une des opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="3ee6f-445">`A` est un type d’interface, le type de classe, le type délégué ou le type de tableau.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="3ee6f-446">Notez que `System.ValueType` et `System.Enum` sont des types référence qui correspondent à la contrainte.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="3ee6f-447">`A` est un paramètre de type est connu pour être un type référence ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="3ee6f-448">Si la contrainte est la contrainte de type valeur (`struct`), le type `A` doit satisfaire une des opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="3ee6f-449">`A` est un type struct ou type enum, mais pas un type nullable.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="3ee6f-450">Notez que `System.ValueType` et `System.Enum` sont des types référence qui ne répondent pas à cette contrainte.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="3ee6f-451">`A` est un paramètre de type ayant la contrainte de type valeur ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="3ee6f-452">Si la contrainte est la contrainte de constructeur `new()`, le type `A` ne doit pas être `abstract` et doit avoir un constructeur sans paramètre public.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="3ee6f-453">Cela est satisfaite si une des opérations suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="3ee6f-454">`A` est un type valeur, étant donné que tous les types de valeur ont un constructeur public par défaut ([constructeurs par défaut](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="3ee6f-455">`A` est un paramètre de type ayant la contrainte de constructeur ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="3ee6f-456">`A` est un paramètre de type ayant la contrainte de type valeur ([les contraintes de paramètre de Type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="3ee6f-457">`A` est une classe qui n’est pas `abstract` et contient déclaré explicitement `public` constructeur sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="3ee6f-458">`A` n’est pas `abstract` et possède un constructeur par défaut ([constructeurs par défaut](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="3ee6f-459">Une erreur de compilation se produit si un ou plusieurs des contraintes d’un paramètre type ne sont pas satisfaites par les arguments de type donné.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="3ee6f-460">Dans la mesure où les paramètres de type ne sont pas héritées, les contraintes ne sont jamais soit héritée.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="3ee6f-461">Dans l’exemple ci-dessous, `D` doit spécifier la contrainte sur son paramètre de type `T` afin que `T` satisfait à la contrainte imposée par la classe de base `B<T>`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="3ee6f-462">En revanche, la classe `E` pas besoin de spécifier une contrainte, car `List<T>` implémente `IEnumerable` pour toute `T`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="3ee6f-463">Paramètres de type</span><span class="sxs-lookup"><span data-stu-id="3ee6f-463">Type parameters</span></span>

<span data-ttu-id="3ee6f-464">Un paramètre de type est un identificateur qui désigne un type valeur ou un type référence auquel le paramètre est lié au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="3ee6f-465">Dans la mesure où un paramètre de type peut être instancié avec de nombreux arguments de type réel différents paramètres de type ont légèrement différentes opérations et les restrictions que les autres types.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="3ee6f-466">Elles incluent notamment :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-466">These include:</span></span>

*  <span data-ttu-id="3ee6f-467">Un paramètre de type ne peut pas être utilisé directement pour déclarer une classe de base ([classe de Base](classes.md#base-class)) ou une interface ([listes de paramètres de type Variant](interfaces.md#variant-type-parameter-lists)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="3ee6f-468">Les règles pour la recherche de membre sur le type de paramètres varient selon les contraintes, le cas échéant, appliqué au paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="3ee6f-469">Elles sont détaillées dans [recherche de membres](expressions.md#member-lookup).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="3ee6f-470">Les conversions disponibles pour un paramètre de type varient selon les contraintes, cas échéant, appliqué au paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="3ee6f-471">Elles sont détaillées dans [conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters) et [les conversions explicites dynamiques](conversions.md#explicit-dynamic-conversions).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="3ee6f-472">Le littéral `null` ne peut pas être converti en un type donné par un paramètre de type, sauf si le paramètre de type est connu pour être un type référence ([conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="3ee6f-473">Toutefois, un `default` expression ([des expressions de valeur par défaut](expressions.md#default-value-expressions)) peut être utilisé à la place.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="3ee6f-474">En outre, une valeur avec un type donné par un paramètre de type peut être comparée avec `null` à l’aide de `==` et `!=` ([opérateurs d’égalité de type référence](expressions.md#reference-type-equality-operators)), sauf si le paramètre de type a la contrainte de type valeur.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="3ee6f-475">Un `new` expression ([des expressions de la création d’objet](expressions.md#object-creation-expressions)) peut uniquement être utilisé avec un paramètre de type, si le paramètre de type est contraint par une *constructor_constraint* ou la valeur de contrainte (detype[ Les contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="3ee6f-476">Un paramètre de type ne peut pas être utilisé n’importe où dans un attribut.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="3ee6f-477">Un paramètre de type ne peut pas être utilisé dans un accès au membre ([l’accès au membre](expressions.md#member-access)) ou nom de type ([Namespace noms et type](basic-concepts.md#namespace-and-type-names)) pour identifier un membre statique ou un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="3ee6f-478">Dans du code unsafe, un paramètre de type ne peut pas être utilisé comme un *unmanaged_type* ([types pointeur](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="3ee6f-479">En tant que type, les paramètres de type sont purement une construction de la compilation.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="3ee6f-480">Au moment de l’exécution, chaque paramètre de type est lié à un type au moment de l’exécution qui a été spécifié en fournissant un argument de type à la déclaration de type générique.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="3ee6f-481">Par conséquent, le type d’une variable déclarée avec un paramètre ne sera type, au moment de l’exécution, être un type construit fermé ([ouvert et fermé types](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="3ee6f-482">L’exécution de l’exécution de toutes les instructions et expressions impliquant des paramètres de type utilise le type réel qui a été fourni comme argument de type pour ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="3ee6f-483">Types arborescence d’expression</span><span class="sxs-lookup"><span data-stu-id="3ee6f-483">Expression tree types</span></span>

<span data-ttu-id="3ee6f-484">***Arborescences d’expression*** permettant aux expressions lambda pour être représenté en tant que structures de données au lieu de code exécutable.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="3ee6f-485">Arborescences d’expression sont des valeurs de ***types arborescence d’expression*** du formulaire `System.Linq.Expressions.Expression<D>`, où `D` est n’importe quel type délégué.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="3ee6f-486">Pour le reste de cette spécification, nous ferons référence à ces types à l’aide de la syntaxe raccourcie `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="3ee6f-487">S’il existe une conversion à partir d’une expression lambda à un type délégué `D`, il existe également une conversion vers le type d’arborescence expression `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="3ee6f-488">Tandis que la conversion d’une expression lambda à un type délégué génère un délégué qui fait référence au code exécutable de l’expression lambda, la conversion vers un type d’arborescence expression crée une arborescence d’expression de l’expression lambda.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="3ee6f-489">Arborescences d’expression sont des représentations de données en mémoire efficace des expressions lambda et que la structure de l’expression lambda transparente et explicite.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="3ee6f-490">Tout comme un type délégué `D`, `Expression<D>` est considéré comme paramètre et types de retour, qui sont les mêmes que celles de `D`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="3ee6f-491">L’exemple suivant représente une expression lambda en tant que code exécutable et comme une arborescence d’expression.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="3ee6f-492">Car il existe une conversion en `Func<int,int>`, il existe également une conversion en `Expression<Func<int,int>>`:</span><span class="sxs-lookup"><span data-stu-id="3ee6f-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="3ee6f-493">Suivez ces affectations, le délégué `del` fait référence à une méthode qui retourne `x + 1`et l’arborescence d’expression `exp` fait référence à une structure de données qui décrit l’expression `x => x + 1`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="3ee6f-494">La définition exacte du type générique `Expression<D>` , ainsi que les règles précises pour construire une arborescence d’expression lorsqu’une expression lambda est convertie en un type arborescence d’expression, sont tous deux en dehors de l’étendue de cette spécification.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="3ee6f-495">Deux choses sont importantes pour rendre explicite :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="3ee6f-496">Pas toutes les expressions lambda peuvent être converties en arborescences d’expression.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="3ee6f-497">Par exemple, les expressions lambda avec corps d’instruction et les expressions lambda contenant des expressions d’assignation ne peut pas être représenté.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="3ee6f-498">Dans ce cas, une conversion toujours existe mais échouera au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="3ee6f-499">Ces exceptions sont détaillées dans [conversions de fonctions anonymes](conversions.md#anonymous-function-conversions).</span><span class="sxs-lookup"><span data-stu-id="3ee6f-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="3ee6f-500">`Expression<D>` offre une méthode d’instance `Compile` qui produit un délégué du type `D`:</span><span class="sxs-lookup"><span data-stu-id="3ee6f-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="3ee6f-501">L’appel de ce délégué entraîne le code représenté par l’arborescence d’expression à exécuter.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="3ee6f-502">Par conséquent, compte tenu des définitions ci-dessus, del et del2 sont équivalents et les deux instructions suivantes auront le même effet :</span><span class="sxs-lookup"><span data-stu-id="3ee6f-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="3ee6f-503">Après l’exécution de ce code, `i1` et `i2` se verront attribuer la valeur `2`.</span><span class="sxs-lookup"><span data-stu-id="3ee6f-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>

