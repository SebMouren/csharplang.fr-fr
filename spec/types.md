---
ms.openlocfilehash: 088c4a77cecde490c556c44c239a3496f896582e
ms.sourcegitcommit: 4ddf18d000734c1b6d0a48127bf338086fc3f2c3
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/05/2019
ms.locfileid: "73616139"
---
# <a name="types"></a><span data-ttu-id="8f078-101">Types</span><span class="sxs-lookup"><span data-stu-id="8f078-101">Types</span></span>

<span data-ttu-id="8f078-102">Les types de C# langage sont divisés en deux catégories principales : ***types valeur*** et ***types référence***.</span><span class="sxs-lookup"><span data-stu-id="8f078-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="8f078-103">Les types valeur et les types référence peuvent être des ***types génériques***, qui prennent un ou plusieurs ***paramètres de type***.</span><span class="sxs-lookup"><span data-stu-id="8f078-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="8f078-104">Les paramètres de type peuvent désigner à la fois les types valeur et les types référence.</span><span class="sxs-lookup"><span data-stu-id="8f078-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="8f078-105">La catégorie finale de types, pointeurs, est uniquement disponible dans du code unsafe.</span><span class="sxs-lookup"><span data-stu-id="8f078-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="8f078-106">Ce sujet est abordé plus en détail dans [types de pointeurs](unsafe-code.md#pointer-types).</span><span class="sxs-lookup"><span data-stu-id="8f078-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="8f078-107">Les types valeur diffèrent des types référence dans le fait que les variables des types valeur contiennent directement leurs données, alors que les variables des types référence stockent les ***références*** à leurs données, ce dernier étant appelé ***objets***.</span><span class="sxs-lookup"><span data-stu-id="8f078-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="8f078-108">Avec les types référence, deux variables peuvent faire référence au même objet et, par conséquent, les opérations sur une variable peuvent affecter l’objet référencé par l’autre variable.</span><span class="sxs-lookup"><span data-stu-id="8f078-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="8f078-109">Avec les types valeur, les variables disposent chacune de leur propre copie des données, et il n’est pas possible que les opérations sur l’une d’elles affectent l’autre.</span><span class="sxs-lookup"><span data-stu-id="8f078-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="8f078-110">C#le système de type de est unifié de telle sorte qu’une valeur de n’importe quel type peut être traitée en tant qu’objet.</span><span class="sxs-lookup"><span data-stu-id="8f078-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="8f078-111">Chaque type dans C# dérive directement ou indirectement du type `object`, et `object` est la classe de base fondamentale de tous les types.</span><span class="sxs-lookup"><span data-stu-id="8f078-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="8f078-112">Les valeurs des types référence sont considérées comme des objets simplement en affichant les valeurs en tant que type `object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="8f078-113">Les valeurs des types valeur sont traitées comme des objets en effectuant des opérations de boxing et d’unboxing ([boxing et unboxing](types.md#boxing-and-unboxing)).</span><span class="sxs-lookup"><span data-stu-id="8f078-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="8f078-114">Types de valeur</span><span class="sxs-lookup"><span data-stu-id="8f078-114">Value types</span></span>

<span data-ttu-id="8f078-115">Un type valeur est soit un type struct, soit un type énumération.</span><span class="sxs-lookup"><span data-stu-id="8f078-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="8f078-116">C#fournit un ensemble de types struct prédéfinis appelés ***types simples***.</span><span class="sxs-lookup"><span data-stu-id="8f078-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="8f078-117">Les types simples sont identifiés à l’aide de mots réservés.</span><span class="sxs-lookup"><span data-stu-id="8f078-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="8f078-118">Contrairement à une variable d’un type référence, une variable d’un type valeur peut contenir la valeur `null` uniquement si le type valeur est un type Nullable.</span><span class="sxs-lookup"><span data-stu-id="8f078-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="8f078-119">Pour chaque type valeur qui n’autorise pas les valeurs NULL, il existe un type valeur Nullable correspondant indiquant le même jeu de valeurs plus la valeur `null`.</span><span class="sxs-lookup"><span data-stu-id="8f078-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="8f078-120">L’assignation à une variable d’un type valeur crée une copie de la valeur assignée.</span><span class="sxs-lookup"><span data-stu-id="8f078-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="8f078-121">Cela diffère d’une assignation à une variable d’un type référence, qui copie la référence, mais pas l’objet identifié par la référence.</span><span class="sxs-lookup"><span data-stu-id="8f078-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="8f078-122">Type System. ValueType</span><span class="sxs-lookup"><span data-stu-id="8f078-122">The System.ValueType type</span></span>

<span data-ttu-id="8f078-123">Tous les types valeur héritent implicitement de la classe `System.ValueType`qui, à son tour, hérite de la classe `object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="8f078-124">Il n’est pas possible pour un type de dériver d’un type valeur, et les types valeur sont donc implicitement sealed ([classes sealed](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="8f078-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="8f078-125">Notez que `System.ValueType` n’est pas *Value_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="8f078-126">Au lieu de cela, il s’agit d’un *class_type* à partir duquel tous les *Value_type*sont dérivés automatiquement.</span><span class="sxs-lookup"><span data-stu-id="8f078-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="8f078-127">Constructeurs par défaut</span><span class="sxs-lookup"><span data-stu-id="8f078-127">Default constructors</span></span>

<span data-ttu-id="8f078-128">Tous les types valeur déclarent implicitement un constructeur d’instance sans paramètre public appelé le ***constructeur par défaut***.</span><span class="sxs-lookup"><span data-stu-id="8f078-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="8f078-129">Le constructeur par défaut retourne une instance initialisée à zéro appelée « ***valeur par défaut*** » pour le type de valeur :</span><span class="sxs-lookup"><span data-stu-id="8f078-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="8f078-130">Pour tous les *simple_type*s, la valeur par défaut est la valeur produite par un modèle binaire de zéros :</span><span class="sxs-lookup"><span data-stu-id="8f078-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="8f078-131">Pour `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`et `ulong`, la valeur par défaut est `0`.</span><span class="sxs-lookup"><span data-stu-id="8f078-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="8f078-132">Par `char`, la valeur par défaut est `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="8f078-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="8f078-133">Par `float`, la valeur par défaut est `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="8f078-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="8f078-134">Par `double`, la valeur par défaut est `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="8f078-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="8f078-135">Par `decimal`, la valeur par défaut est `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="8f078-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="8f078-136">Par `bool`, la valeur par défaut est `false`.</span><span class="sxs-lookup"><span data-stu-id="8f078-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="8f078-137">Pour un `E`*enum_type* , la valeur par défaut est `0`, convertie en type `E`.</span><span class="sxs-lookup"><span data-stu-id="8f078-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="8f078-138">Pour un *struct_type*, la valeur par défaut est la valeur produite en affectant à tous les champs de type valeur leur valeur par défaut et tous les champs de type référence à `null`.</span><span class="sxs-lookup"><span data-stu-id="8f078-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="8f078-139">Pour un *nullable_type* , la valeur par défaut est une instance pour laquelle la propriété `HasValue` a la valeur false et la propriété `Value` est non définie.</span><span class="sxs-lookup"><span data-stu-id="8f078-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="8f078-140">La valeur par défaut est également connue sous le nom de ***valeur null*** du type Nullable.</span><span class="sxs-lookup"><span data-stu-id="8f078-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="8f078-141">Comme tout autre constructeur d’instance, le constructeur par défaut d’un type valeur est appelé à l’aide de l’opérateur `new`.</span><span class="sxs-lookup"><span data-stu-id="8f078-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="8f078-142">Pour des raisons d’efficacité, cette exigence n’est pas destinée à faire en sorte que l’implémentation génère un appel de constructeur.</span><span class="sxs-lookup"><span data-stu-id="8f078-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="8f078-143">Dans l’exemple ci-dessous, les variables `i` et `j` sont toutes deux initialisées à zéro.</span><span class="sxs-lookup"><span data-stu-id="8f078-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="8f078-144">Étant donné que chaque type valeur a implicitement un constructeur d’instance sans paramètre public, il n’est pas possible pour un type struct de contenir une déclaration explicite d’un constructeur sans paramètre.</span><span class="sxs-lookup"><span data-stu-id="8f078-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="8f078-145">Un type struct est toutefois autorisé à déclarer des constructeurs d’instances paramétrables ([constructeurs](structs.md#constructors)).</span><span class="sxs-lookup"><span data-stu-id="8f078-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="8f078-146">Types struct</span><span class="sxs-lookup"><span data-stu-id="8f078-146">Struct types</span></span>

<span data-ttu-id="8f078-147">Un type struct est un type valeur qui peut déclarer des constantes, des champs, des méthodes, des propriétés, des indexeurs, des opérateurs, des constructeurs d’instance, des constructeurs statiques et des types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="8f078-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="8f078-148">La déclaration des types struct est décrite dans [déclarations de struct](structs.md#struct-declarations).</span><span class="sxs-lookup"><span data-stu-id="8f078-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="8f078-149">Types simples</span><span class="sxs-lookup"><span data-stu-id="8f078-149">Simple types</span></span>

<span data-ttu-id="8f078-150">C#fournit un ensemble de types struct prédéfinis appelés ***types simples***.</span><span class="sxs-lookup"><span data-stu-id="8f078-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="8f078-151">Les types simples sont identifiés par le biais de mots réservés, mais ces mots réservés sont simplement des alias pour les types struct prédéfinis dans l’espace de noms `System`, comme décrit dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="8f078-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="8f078-152">__Mot réservé__</span><span class="sxs-lookup"><span data-stu-id="8f078-152">__Reserved word__</span></span> | <span data-ttu-id="8f078-153">__Type avec alias__</span><span class="sxs-lookup"><span data-stu-id="8f078-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="8f078-154">Étant donné qu’un type simple est un alias de type struct, chaque type simple a des membres.</span><span class="sxs-lookup"><span data-stu-id="8f078-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="8f078-155">Par exemple, `int` a les membres déclarés dans `System.Int32` et les membres hérités de `System.Object`, et les instructions suivantes sont autorisées :</span><span class="sxs-lookup"><span data-stu-id="8f078-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="8f078-156">Les types simples diffèrent des autres types struct en ce qu’ils autorisent des opérations supplémentaires :</span><span class="sxs-lookup"><span data-stu-id="8f078-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="8f078-157">La plupart des types simples autorisent la création de valeurs en écrivant des *littéraux* ([littéraux](lexical-structure.md#literals)).</span><span class="sxs-lookup"><span data-stu-id="8f078-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="8f078-158">Par exemple, `123` est un littéral de type `int` et `'a'` est un littéral de type `char`.</span><span class="sxs-lookup"><span data-stu-id="8f078-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="8f078-159">C#n’offre aucune provision pour les littéraux de types struct en général, et les valeurs autres que celles par défaut des autres types struct sont finalement toujours créées via les constructeurs d’instance de ces types struct.</span><span class="sxs-lookup"><span data-stu-id="8f078-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="8f078-160">Quand les opérandes d’une expression sont toutes des constantes de type simple, il est possible que le compilateur évalue l’expression au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="8f078-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="8f078-161">Une telle expression est appelée *constant_expression* ([expressions constantes](expressions.md#constant-expressions)).</span><span class="sxs-lookup"><span data-stu-id="8f078-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="8f078-162">Les expressions qui impliquent des opérateurs définis par d’autres types struct ne sont pas considérées comme des expressions constantes.</span><span class="sxs-lookup"><span data-stu-id="8f078-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="8f078-163">Grâce aux déclarations de `const`, il est possible de déclarer des constantes des types simples ([constantes](classes.md#constants)).</span><span class="sxs-lookup"><span data-stu-id="8f078-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="8f078-164">Il n’est pas possible d’avoir des constantes d’autres types struct, mais un effet similaire est fourni par `static readonly` champs.</span><span class="sxs-lookup"><span data-stu-id="8f078-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="8f078-165">Les conversions impliquant des types simples peuvent participer à l’évaluation des opérateurs de conversion définis par d’autres types struct, mais un opérateur de conversion défini par l’utilisateur ne peut jamais participer à l’évaluation d’un autre opérateur défini par l’utilisateur ([évaluation de conversions définies par l’utilisateur](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="8f078-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="8f078-166">Types intégraux</span><span class="sxs-lookup"><span data-stu-id="8f078-166">Integral types</span></span>

<span data-ttu-id="8f078-167">C#prend en charge neuf types intégraux : `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`et `char`.</span><span class="sxs-lookup"><span data-stu-id="8f078-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="8f078-168">Les types intégraux ont les tailles et plages de valeurs suivantes :</span><span class="sxs-lookup"><span data-stu-id="8f078-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="8f078-169">Le type de `sbyte` représente des entiers 8 bits signés dont les valeurs sont comprises entre-128 et 127.</span><span class="sxs-lookup"><span data-stu-id="8f078-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="8f078-170">Le type de `byte` représente des entiers 8 bits non signés dont la valeur est comprise entre 0 et 255.</span><span class="sxs-lookup"><span data-stu-id="8f078-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="8f078-171">Le type de `short` représente des entiers 16 bits signés dont les valeurs sont comprises entre-32768 et 32767.</span><span class="sxs-lookup"><span data-stu-id="8f078-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="8f078-172">Le type de `ushort` représente des entiers 16 bits non signés dont la valeur est comprise entre 0 et 65535.</span><span class="sxs-lookup"><span data-stu-id="8f078-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="8f078-173">Le type de `int` représente des entiers 32 bits signés dont les valeurs sont comprises entre-2147483648 et 2147483647.</span><span class="sxs-lookup"><span data-stu-id="8f078-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="8f078-174">Le type de `uint` représente des entiers 32 bits non signés dont la valeur est comprise entre 0 et 4294967295.</span><span class="sxs-lookup"><span data-stu-id="8f078-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="8f078-175">Le type de `long` représente des entiers 64 bits signés dont la valeur est comprise entre-9223372036854775808 et 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="8f078-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="8f078-176">Le type de `ulong` représente des entiers 64 bits non signés dont la valeur est comprise entre 0 et 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="8f078-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="8f078-177">Le type de `char` représente des entiers 16 bits non signés dont la valeur est comprise entre 0 et 65535.</span><span class="sxs-lookup"><span data-stu-id="8f078-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="8f078-178">Le jeu de valeurs possibles pour le type de `char` correspond au jeu de caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="8f078-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="8f078-179">Bien que `char` ait la même représentation que `ushort`, les opérations autorisées sur un type ne sont pas toutes autorisées sur l’autre.</span><span class="sxs-lookup"><span data-stu-id="8f078-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="8f078-180">Les opérateurs unaires et binaires de type intégral fonctionnent toujours avec la précision 32 bits signée, la précision 32 bits non signée, la précision 64 bits signée ou la précision non signée de 64 bits :</span><span class="sxs-lookup"><span data-stu-id="8f078-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="8f078-181">Pour les opérateurs unaires `+` et `~`, l’opérande est converti en type `T`, où `T` est le premier d' `int`, `uint`, `long`et `ulong` qui peut représenter entièrement toutes les valeurs possibles de l’opérande.</span><span class="sxs-lookup"><span data-stu-id="8f078-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="8f078-182">L’opération est ensuite effectuée à l’aide de la précision de type `T`, et le type du résultat est `T`.</span><span class="sxs-lookup"><span data-stu-id="8f078-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="8f078-183">Pour l’opérateur de `-` unaire, l’opérande est converti en type `T`, où `T` est le premier d' `int` et `long` qui peut représenter entièrement toutes les valeurs possibles de l’opérande.</span><span class="sxs-lookup"><span data-stu-id="8f078-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="8f078-184">L’opération est ensuite effectuée à l’aide de la précision de type `T`, et le type du résultat est `T`.</span><span class="sxs-lookup"><span data-stu-id="8f078-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="8f078-185">L’opérateur de `-` unaire ne peut pas être appliqué aux opérandes de type `ulong`.</span><span class="sxs-lookup"><span data-stu-id="8f078-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="8f078-186">Pour les opérateurs binaires `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`et `<=` , les opérandes sont convertis en type `T`, où `T` est le premier d' `int`, `uint`, `long`et `ulong` qui peut représenter entièrement toutes les valeurs possibles des deux opérandes.</span><span class="sxs-lookup"><span data-stu-id="8f078-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="8f078-187">L’opération est ensuite effectuée à l’aide de la précision de type `T`, et le type du résultat est `T` (ou `bool` pour les opérateurs relationnels).</span><span class="sxs-lookup"><span data-stu-id="8f078-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="8f078-188">Il n’est pas autorisé qu’un opérande soit de type `long` et que l’autre soit de type `ulong` avec les opérateurs binaires.</span><span class="sxs-lookup"><span data-stu-id="8f078-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="8f078-189">Pour les opérateurs binaires `<<` et `>>`, l’opérande de gauche est converti en type `T`, où `T` est le premier d' `int`, `uint`, `long`et `ulong` qui peut représenter entièrement toutes les valeurs possibles de l’opérande.</span><span class="sxs-lookup"><span data-stu-id="8f078-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="8f078-190">L’opération est ensuite effectuée à l’aide de la précision de type `T`, et le type du résultat est `T`.</span><span class="sxs-lookup"><span data-stu-id="8f078-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="8f078-191">Le type de `char` est classé en tant que type intégral, mais il diffère des autres types intégraux de deux manières :</span><span class="sxs-lookup"><span data-stu-id="8f078-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="8f078-192">Il n’existe pas de conversion implicite d’autres types en type `char`.</span><span class="sxs-lookup"><span data-stu-id="8f078-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="8f078-193">En particulier, même si les types `sbyte`, `byte`et `ushort` ont des plages de valeurs qui sont entièrement représentables à l’aide du type `char`, les conversions implicites de `sbyte`, `byte`ou `ushort` à `char` n’existent pas.</span><span class="sxs-lookup"><span data-stu-id="8f078-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="8f078-194">Les constantes du type de `char` doivent être écrites en *character_literal*s ou en tant que *integer_literal*s en association avec un cast en type `char`.</span><span class="sxs-lookup"><span data-stu-id="8f078-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="8f078-195">Par exemple, `(char)10` est identique à `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="8f078-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="8f078-196">Les opérateurs et les instructions `checked` et `unchecked` sont utilisés pour contrôler le contrôle de dépassement pour les opérations arithmétiques de type intégral et les conversions ([opérateurs activés et désactivés](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="8f078-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="8f078-197">Dans un contexte de `checked`, un dépassement de capacité génère une erreur au moment de la compilation ou provoque la levée d’une `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="8f078-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="8f078-198">Dans un contexte de `unchecked`, les dépassements de capacité sont ignorés et tous les bits de poids fort qui ne tiennent pas dans le type de destination sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="8f078-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="8f078-199">Types à virgule flottante</span><span class="sxs-lookup"><span data-stu-id="8f078-199">Floating point types</span></span>

<span data-ttu-id="8f078-200">C#prend en charge deux types à virgule flottante : `float` et `double`.</span><span class="sxs-lookup"><span data-stu-id="8f078-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="8f078-201">Les types `float` et `double` sont représentés à l’aide des formats IEEE 754 simple précision et double précision 64 bits de 32, qui fournissent les ensembles de valeurs suivants :</span><span class="sxs-lookup"><span data-stu-id="8f078-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="8f078-202">Zéro positif et zéro négatif.</span><span class="sxs-lookup"><span data-stu-id="8f078-202">Positive zero and negative zero.</span></span> <span data-ttu-id="8f078-203">Dans la plupart des cas, le zéro positif et le zéro négatif se comportent de la même façon que la valeur simple zéro, mais certaines opérations distinguent les deux ([opérateur de division](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="8f078-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="8f078-204">Infini positif et infini négatif.</span><span class="sxs-lookup"><span data-stu-id="8f078-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="8f078-205">Les infinis sont produites par des opérations telles que la Division d’un nombre différent de zéro par zéro.</span><span class="sxs-lookup"><span data-stu-id="8f078-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="8f078-206">Par exemple, `1.0 / 0.0` produit une infinité positive et `-1.0 / 0.0` produit une infini négatif.</span><span class="sxs-lookup"><span data-stu-id="8f078-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="8f078-207">Valeur ***not-a-Number*** , souvent abrégée Nan.</span><span class="sxs-lookup"><span data-stu-id="8f078-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="8f078-208">Les valeurs NaN sont produites par des opérations à virgule flottante non valides, telles que la Division de zéro par zéro.</span><span class="sxs-lookup"><span data-stu-id="8f078-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="8f078-209">Le jeu fini de valeurs non null de la forme `s * m * 2^e`, où `s` a la valeur 1 ou-1, et `m` et `e` sont déterminés par le type à virgule flottante particulier : pour `float`, `0 < m < 2^24` et `-149 <= e <= 104`, et pour `double`, `0 < m < 2^53` et `-1075 <= e <= 970`.</span><span class="sxs-lookup"><span data-stu-id="8f078-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `-1075 <= e <= 970`.</span></span> <span data-ttu-id="8f078-210">Les nombres à virgule flottante dénormalisés sont considérés comme des valeurs non nulles valides.</span><span class="sxs-lookup"><span data-stu-id="8f078-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="8f078-211">Le type de `float` peut représenter des valeurs allant d’environ `1.5 * 10^-45` à `3.4 * 10^38` avec une précision de 7 chiffres.</span><span class="sxs-lookup"><span data-stu-id="8f078-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="8f078-212">Le type de `double` peut représenter des valeurs allant d’environ `5.0 * 10^-324` à `1.7 × 10^308` avec une précision de 15-16 chiffres.</span><span class="sxs-lookup"><span data-stu-id="8f078-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="8f078-213">Si l’un des opérandes d’un opérateur binaire est d’un type à virgule flottante, l’autre opérande doit être d’un type intégral ou d’un type à virgule flottante, et l’opération est évaluée comme suit :</span><span class="sxs-lookup"><span data-stu-id="8f078-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="8f078-214">Si l’un des opérandes est d’un type intégral, cet opérande est converti en type à virgule flottante de l’autre opérande.</span><span class="sxs-lookup"><span data-stu-id="8f078-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="8f078-215">Ensuite, si l’un des opérandes est de type `double`, l’autre opérande est converti en `double`, l’opération est effectuée à l’aide d’au moins `double` plage et précision, et le type du résultat est `double` (ou `bool` pour les opérateurs relationnels).</span><span class="sxs-lookup"><span data-stu-id="8f078-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="8f078-216">Dans le cas contraire, l’opération est effectuée à l’aide d’au moins `float` plage et précision, et le type du résultat est `float` (ou `bool` pour les opérateurs relationnels).</span><span class="sxs-lookup"><span data-stu-id="8f078-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="8f078-217">Les opérateurs à virgule flottante, y compris les opérateurs d’assignation, ne produisent jamais d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="8f078-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="8f078-218">À la place, dans des situations exceptionnelles, les opérations à virgule flottante produisent zéro, Infinity ou NaN, comme décrit ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="8f078-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="8f078-219">Si le résultat d’une opération à virgule flottante est trop petit pour le format de destination, le résultat de l’opération devient un zéro positif ou un zéro négatif.</span><span class="sxs-lookup"><span data-stu-id="8f078-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="8f078-220">Si le résultat d’une opération à virgule flottante est trop grand pour le format de destination, le résultat de l’opération devient une infini positif ou négatif.</span><span class="sxs-lookup"><span data-stu-id="8f078-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="8f078-221">Si une opération à virgule flottante n’est pas valide, le résultat de l’opération devient NaN.</span><span class="sxs-lookup"><span data-stu-id="8f078-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="8f078-222">Si l’un des opérandes ou les deux d’une opération à virgule flottante est NaN, le résultat de l’opération devient NaN.</span><span class="sxs-lookup"><span data-stu-id="8f078-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="8f078-223">Les opérations à virgule flottante peuvent être effectuées avec une précision supérieure à celle du type de résultat de l’opération.</span><span class="sxs-lookup"><span data-stu-id="8f078-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="8f078-224">Par exemple, certaines architectures matérielles prennent en charge un type à virgule flottante « étendu » ou « long double » avec une plage et une précision supérieures à celles du type de `double`, et effectuent implicitement toutes les opérations en virgule flottante à l’aide de ce type de précision plus élevée.</span><span class="sxs-lookup"><span data-stu-id="8f078-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="8f078-225">Le fait d’effectuer des opérations de calcul en virgule flottante avec moins de précision, et au lieu d’exiger une implémentation pour perdre à la fois les performances et la précision, C# offre un type de précision plus élevé. à utiliser pour toutes les opérations en virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="8f078-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="8f078-226">En dehors de la diffusion de résultats plus précis, cela a rarement des effets mesurables.</span><span class="sxs-lookup"><span data-stu-id="8f078-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="8f078-227">Toutefois, dans les expressions de la forme `x * y / z`, où la multiplication produit un résultat en dehors de la plage de `double`, mais la Division suivante ramène le résultat temporaire à la plage de `double`, le fait que l’expression soit évaluée dans une un format de plage plus élevé peut entraîner la production d’un résultat fini à la place d’une infini.</span><span class="sxs-lookup"><span data-stu-id="8f078-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="8f078-228">Type décimal</span><span class="sxs-lookup"><span data-stu-id="8f078-228">The decimal type</span></span>

<span data-ttu-id="8f078-229">Le type `decimal` est un type de données 128 bits adapté aux calculs financiers et monétaires.</span><span class="sxs-lookup"><span data-stu-id="8f078-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="8f078-230">Le type de `decimal` peut représenter des valeurs allant de `1.0 * 10^-28` à environ `7.9 * 10^28` avec 28-29 chiffres significatifs.</span><span class="sxs-lookup"><span data-stu-id="8f078-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="8f078-231">L’ensemble fini de valeurs de type `decimal` se présentent sous la forme `(-1)^s * c * 10^-e`, où le signe `s` est 0 ou 1, le coefficient `c` est donné par `0 <= *c* < 2^96`, et la `e` d’échelle est telle que `0 <= e <= 28`. Le type de `decimal` ne prend pas en charge les zéros, les infinis ou les NaN signés.</span><span class="sxs-lookup"><span data-stu-id="8f078-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="8f078-232">Un `decimal` est représenté sous la forme d’un entier 96 bits mis à l’échelle par une puissance de dix.</span><span class="sxs-lookup"><span data-stu-id="8f078-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="8f078-233">Pour `decimal`s avec une valeur absolue inférieure à `1.0m`, la valeur est exacte jusqu’au 28 décimal, mais pas plus.</span><span class="sxs-lookup"><span data-stu-id="8f078-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="8f078-234">Pour les `decimal`avec une valeur absolue supérieure ou égale à `1.0m`, la valeur est exacte à 28 ou 29 chiffres.</span><span class="sxs-lookup"><span data-stu-id="8f078-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="8f078-235">Contrairement aux types de données `float` et `double`, les nombres fractionnaires décimaux tels que 0,1 peuvent être représentés exactement dans la représentation `decimal`.</span><span class="sxs-lookup"><span data-stu-id="8f078-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="8f078-236">Dans les représentations `float` et `double`, ces nombres sont souvent des fractions infinies, ce qui rend ces représentations plus sujettes aux erreurs d’arrondi.</span><span class="sxs-lookup"><span data-stu-id="8f078-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="8f078-237">Si l’un des opérandes d’un opérateur binaire est de type `decimal`, l’autre opérande doit être de type intégral ou de type `decimal`.</span><span class="sxs-lookup"><span data-stu-id="8f078-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="8f078-238">Si un opérande de type intégral est présent, il est converti en `decimal` avant l’exécution de l’opération.</span><span class="sxs-lookup"><span data-stu-id="8f078-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="8f078-239">Le résultat d’une opération sur les valeurs de type `decimal` est que ce qui résulte du calcul d’un résultat exact (préservation de l’échelle, tel que défini pour chaque opérateur), puis à l’arrondi pour s’ajuster à la représentation.</span><span class="sxs-lookup"><span data-stu-id="8f078-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="8f078-240">Les résultats sont arrondis à la valeur représentable la plus proche et, lorsqu’un résultat est proche de deux valeurs représentables, à la valeur qui a un nombre pair dans la position de chiffre la moins significative (c’est ce qu’on appelle le « arrondi bancaire »).</span><span class="sxs-lookup"><span data-stu-id="8f078-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="8f078-241">Un résultat zéro a toujours un signe de 0 et une échelle de 0.</span><span class="sxs-lookup"><span data-stu-id="8f078-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="8f078-242">Si une opération arithmétique décimale produit une valeur inférieure ou égale à `5 * 10^-29` en valeur absolue, le résultat de l’opération devient zéro.</span><span class="sxs-lookup"><span data-stu-id="8f078-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="8f078-243">Si une `decimal` opération arithmétique produit un résultat trop grand pour le format `decimal`, une `System.OverflowException` est levée.</span><span class="sxs-lookup"><span data-stu-id="8f078-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="8f078-244">Le type de `decimal` a une plus grande précision, mais une plage plus petite que les types à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="8f078-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="8f078-245">Ainsi, les conversions des types à virgule flottante en `decimal` peuvent générer des exceptions de dépassement de capacité et les conversions de `decimal` en types virgule flottante peuvent entraîner une perte de précision.</span><span class="sxs-lookup"><span data-stu-id="8f078-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="8f078-246">Pour ces raisons, il n’existe pas de conversion implicite entre les types à virgule flottante et les `decimal`, et sans casts explicites, il n’est pas possible de mélanger des opérandes à virgule flottante et `decimal` dans la même expression.</span><span class="sxs-lookup"><span data-stu-id="8f078-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="8f078-247">Type bool</span><span class="sxs-lookup"><span data-stu-id="8f078-247">The bool type</span></span>

<span data-ttu-id="8f078-248">Le type de `bool` représente des quantités logiques booléennes.</span><span class="sxs-lookup"><span data-stu-id="8f078-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="8f078-249">Les valeurs possibles de type `bool` sont `true` et `false`.</span><span class="sxs-lookup"><span data-stu-id="8f078-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="8f078-250">Il n’existe pas de conversion standard entre `bool` et d’autres types.</span><span class="sxs-lookup"><span data-stu-id="8f078-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="8f078-251">En particulier, le type de `bool` est distinct et distinct des types intégraux, et une valeur de `bool` ne peut pas être utilisée à la place d’une valeur intégrale, et vice versa.</span><span class="sxs-lookup"><span data-stu-id="8f078-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="8f078-252">Dans les langages C++ C et, une valeur intégrale nulle ou à virgule flottante, ou un pointeur NULL peut être converti en valeur booléenne `false`, et une valeur intégrale ou à virgule flottante différente de zéro, ou un pointeur non NULL peut être converti en valeur booléenne `true`.</span><span class="sxs-lookup"><span data-stu-id="8f078-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="8f078-253">Dans C#, ces conversions sont accomplies en comparant explicitement une valeur intégrale ou à virgule flottante à zéro, ou en comparant explicitement une référence d’objet à `null`.</span><span class="sxs-lookup"><span data-stu-id="8f078-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="8f078-254">Types d'énumération</span><span class="sxs-lookup"><span data-stu-id="8f078-254">Enumeration types</span></span>

<span data-ttu-id="8f078-255">Un type énumération est un type distinct avec des constantes nommées.</span><span class="sxs-lookup"><span data-stu-id="8f078-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="8f078-256">Chaque type énumération a un type sous-jacent, qui doit être `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` ou `ulong`.</span><span class="sxs-lookup"><span data-stu-id="8f078-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="8f078-257">L’ensemble de valeurs du type énumération est le même que l’ensemble de valeurs du type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="8f078-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="8f078-258">Les valeurs du type d’énumération ne sont pas limitées aux valeurs des constantes nommées.</span><span class="sxs-lookup"><span data-stu-id="8f078-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="8f078-259">Les types énumération sont définis par le biais de déclarations d’énumération ([déclarations enum](enums.md#enum-declarations)).</span><span class="sxs-lookup"><span data-stu-id="8f078-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="8f078-260">Types Nullable</span><span class="sxs-lookup"><span data-stu-id="8f078-260">Nullable types</span></span>

<span data-ttu-id="8f078-261">Un type Nullable peut représenter toutes les valeurs de son ***type sous-jacent*** plus une valeur null supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="8f078-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="8f078-262">Un type Nullable est écrit `T?`, où `T` est le type sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="8f078-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="8f078-263">Cette syntaxe est raccourcie pour `System.Nullable<T>`, et les deux formulaires peuvent être utilisés indifféremment.</span><span class="sxs-lookup"><span data-stu-id="8f078-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="8f078-264">Un ***type valeur qui n’autorise pas*** les valeurs NULL est inversement tout type valeur autre que `System.Nullable<T>` et son raccourci `T?` (pour n’importe quel `T`), plus tout paramètre de type qui est imposé comme étant un type valeur non Nullable (autrement dit, tout paramètre de type avec une `struct` contrainte).</span><span class="sxs-lookup"><span data-stu-id="8f078-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="8f078-265">Le type de `System.Nullable<T>` spécifie la contrainte de type valeur pour `T` ([contraintes de paramètre de type](classes.md#type-parameter-constraints)), ce qui signifie que le type sous-jacent d’un type Nullable peut être n’importe quel type valeur n’acceptant pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="8f078-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="8f078-266">Le type sous-jacent d’un type Nullable ne peut pas être un type Nullable ou un type référence.</span><span class="sxs-lookup"><span data-stu-id="8f078-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="8f078-267">Par exemple, `int??` et `string?` sont des types non valides.</span><span class="sxs-lookup"><span data-stu-id="8f078-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="8f078-268">Une instance d’un type Nullable `T?` a deux propriétés publiques en lecture seule :</span><span class="sxs-lookup"><span data-stu-id="8f078-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="8f078-269">Propriété `HasValue` de type `bool`</span><span class="sxs-lookup"><span data-stu-id="8f078-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="8f078-270">Propriété `Value` de type `T`</span><span class="sxs-lookup"><span data-stu-id="8f078-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="8f078-271">Une instance pour laquelle `HasValue` a la valeur true est dite non null.</span><span class="sxs-lookup"><span data-stu-id="8f078-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="8f078-272">Une instance non null contient une valeur connue et `Value` retourne cette valeur.</span><span class="sxs-lookup"><span data-stu-id="8f078-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="8f078-273">Une instance pour laquelle `HasValue` a la valeur false est considérée comme étant null.</span><span class="sxs-lookup"><span data-stu-id="8f078-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="8f078-274">Une instance null a une valeur non définie.</span><span class="sxs-lookup"><span data-stu-id="8f078-274">A null instance has an undefined value.</span></span> <span data-ttu-id="8f078-275">Toute tentative de lecture de la `Value` d’une instance null entraîne la levée d’une `System.InvalidOperationException`.</span><span class="sxs-lookup"><span data-stu-id="8f078-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="8f078-276">Le processus d’accès à la propriété `Value` d’une instance Nullable est appelé ***désencapsulage***.</span><span class="sxs-lookup"><span data-stu-id="8f078-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="8f078-277">En plus du constructeur par défaut, chaque type Nullable `T?` a un constructeur public qui accepte un argument unique de type `T`.</span><span class="sxs-lookup"><span data-stu-id="8f078-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="8f078-278">À partir d’une valeur `x` de type `T`, un appel de constructeur au format</span><span class="sxs-lookup"><span data-stu-id="8f078-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="8f078-279">crée une instance non null de `T?` pour laquelle la propriété `Value` est `x`.</span><span class="sxs-lookup"><span data-stu-id="8f078-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="8f078-280">Le processus de création d’une instance non null d’un type Nullable pour une valeur donnée est appelé « ***Wrapping***».</span><span class="sxs-lookup"><span data-stu-id="8f078-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="8f078-281">Les conversions implicites sont disponibles à partir du littéral `null` pour `T?` ([conversions de littéraux NULL](conversions.md#null-literal-conversions)) et de `T` à `T?` ([conversions nullables implicites](conversions.md#implicit-nullable-conversions)).</span><span class="sxs-lookup"><span data-stu-id="8f078-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="8f078-282">Types référence</span><span class="sxs-lookup"><span data-stu-id="8f078-282">Reference types</span></span>

<span data-ttu-id="8f078-283">Un type référence est un type de classe, un type interface, un type tableau ou un type délégué.</span><span class="sxs-lookup"><span data-stu-id="8f078-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="8f078-284">Une valeur de type référence est une référence à une ***instance*** du type, ce dernier connu sous le nom d' ***objet***.</span><span class="sxs-lookup"><span data-stu-id="8f078-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="8f078-285">La valeur spéciale `null` est compatible avec tous les types de référence et indique l’absence d’une instance.</span><span class="sxs-lookup"><span data-stu-id="8f078-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="8f078-286">Types de classes</span><span class="sxs-lookup"><span data-stu-id="8f078-286">Class types</span></span>

<span data-ttu-id="8f078-287">Un type de classe définit une structure de données qui contient des données membres (constantes et champs), des fonctions membres (méthodes, propriétés, événements, indexeurs, opérateurs, constructeurs d’instance, destructeurs et constructeurs statiques) et des types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="8f078-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="8f078-288">Les types de classe prennent en charge l’héritage, mécanisme dans lequel les classes dérivées peuvent étendre et spécialiser les classes de base.</span><span class="sxs-lookup"><span data-stu-id="8f078-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="8f078-289">Les instances de types de classe sont créées à l’aide de *object_creation_expression*s ([expressions de création d’objet](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="8f078-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="8f078-290">Les types de classe sont décrits dans les [classes](classes.md).</span><span class="sxs-lookup"><span data-stu-id="8f078-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="8f078-291">Certains types de classe prédéfinis ont une signification particulière C# dans le langage, comme décrit dans le tableau ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="8f078-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="8f078-292">__Type de classe__</span><span class="sxs-lookup"><span data-stu-id="8f078-292">__Class type__</span></span>     | <span data-ttu-id="8f078-293">__Description__</span><span class="sxs-lookup"><span data-stu-id="8f078-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="8f078-294">Classe de base fondamentale de tous les autres types.</span><span class="sxs-lookup"><span data-stu-id="8f078-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="8f078-295">Consultez [le type d’objet](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="8f078-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="8f078-296">Type de chaîne de la C# langue.</span><span class="sxs-lookup"><span data-stu-id="8f078-296">The string type of the C# language.</span></span> <span data-ttu-id="8f078-297">Consultez [type de chaîne](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="8f078-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="8f078-298">Classe de base de tous les types valeur.</span><span class="sxs-lookup"><span data-stu-id="8f078-298">The base class of all value types.</span></span> <span data-ttu-id="8f078-299">Consultez [le type System. ValueType](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="8f078-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="8f078-300">Classe de base de tous les types ENUM.</span><span class="sxs-lookup"><span data-stu-id="8f078-300">The base class of all enum types.</span></span> <span data-ttu-id="8f078-301">Consultez [enums](enums.md).</span><span class="sxs-lookup"><span data-stu-id="8f078-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="8f078-302">Classe de base de tous les types tableau.</span><span class="sxs-lookup"><span data-stu-id="8f078-302">The base class of all array types.</span></span> <span data-ttu-id="8f078-303">Consultez [Tableaux](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="8f078-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="8f078-304">Classe de base de tous les types délégués.</span><span class="sxs-lookup"><span data-stu-id="8f078-304">The base class of all delegate types.</span></span> <span data-ttu-id="8f078-305">Consultez [délégués](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="8f078-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="8f078-306">Classe de base de tous les types d’exception.</span><span class="sxs-lookup"><span data-stu-id="8f078-306">The base class of all exception types.</span></span> <span data-ttu-id="8f078-307">Consultez [exceptions](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="8f078-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="8f078-308">Type d’objet</span><span class="sxs-lookup"><span data-stu-id="8f078-308">The object type</span></span>

<span data-ttu-id="8f078-309">Le type de classe `object` est la classe de base fondamentale de tous les autres types.</span><span class="sxs-lookup"><span data-stu-id="8f078-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="8f078-310">Chaque type dans C# directement ou indirectement dérive du type de classe `object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="8f078-311">Le mot clé `object` est simplement un alias pour la classe prédéfinie `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="8f078-312">Type dynamique</span><span class="sxs-lookup"><span data-stu-id="8f078-312">The dynamic type</span></span>

<span data-ttu-id="8f078-313">Le type de `dynamic`, comme `object`, peut faire référence à n’importe quel objet.</span><span class="sxs-lookup"><span data-stu-id="8f078-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="8f078-314">Lorsque des opérateurs sont appliqués à des expressions de type `dynamic`, leur résolution est différée jusqu’à ce que le programme soit exécuté.</span><span class="sxs-lookup"><span data-stu-id="8f078-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="8f078-315">Ainsi, si l’opérateur ne peut pas être légalement appliqué à l’objet référencé, aucune erreur n’est donnée durant la compilation.</span><span class="sxs-lookup"><span data-stu-id="8f078-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="8f078-316">Au lieu de cela, une exception est levée lorsque la résolution de l’opérateur échoue au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="8f078-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="8f078-317">Son objectif est d’autoriser la liaison dynamique, qui est décrite en détail dans [liaison dynamique](expressions.md#dynamic-binding).</span><span class="sxs-lookup"><span data-stu-id="8f078-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="8f078-318">`dynamic` est considéré comme identique à `object` à l’exception des points suivants :</span><span class="sxs-lookup"><span data-stu-id="8f078-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="8f078-319">Les opérations sur les expressions de type `dynamic` peuvent être liées dynamiquement ([liaison dynamique](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="8f078-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="8f078-320">L’inférence de type ([inférence de type](expressions.md#type-inference)) préfère `dynamic` sur `object` si les deux sont des candidats.</span><span class="sxs-lookup"><span data-stu-id="8f078-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="8f078-321">En raison de cette équivalence, les éléments suivants sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="8f078-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="8f078-322">Il existe une conversion d’identité implicite entre `object` et `dynamic`, et entre les types construits qui sont identiques lors du remplacement d' `dynamic` par `object`</span><span class="sxs-lookup"><span data-stu-id="8f078-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="8f078-323">Les conversions implicites et explicites vers et à partir de `object` s’appliquent également à et à partir de `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="8f078-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="8f078-324">Les signatures de méthode qui sont les mêmes lors du remplacement de `dynamic` par des `object` sont considérées comme la même signature</span><span class="sxs-lookup"><span data-stu-id="8f078-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="8f078-325">Le type `dynamic` ne peut pas être distingué du `object` au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="8f078-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="8f078-326">Une expression de type `dynamic` est appelée ***expression dynamique***.</span><span class="sxs-lookup"><span data-stu-id="8f078-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="8f078-327">Type de chaîne</span><span class="sxs-lookup"><span data-stu-id="8f078-327">The string type</span></span>

<span data-ttu-id="8f078-328">Le type de `string` est un type de classe sealed qui hérite directement de `object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="8f078-329">Les instances de la classe `string` représentent des chaînes de caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="8f078-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="8f078-330">Les valeurs du type de `string` peuvent être écrites sous la forme de littéraux de chaîne ([littéraux de chaîne](lexical-structure.md#string-literals)).</span><span class="sxs-lookup"><span data-stu-id="8f078-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="8f078-331">Le mot clé `string` est simplement un alias pour la classe prédéfinie `System.String`.</span><span class="sxs-lookup"><span data-stu-id="8f078-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="8f078-332">Types interface</span><span class="sxs-lookup"><span data-stu-id="8f078-332">Interface types</span></span>

<span data-ttu-id="8f078-333">Une interface définit un contrat.</span><span class="sxs-lookup"><span data-stu-id="8f078-333">An interface defines a contract.</span></span> <span data-ttu-id="8f078-334">Une classe ou un struct qui implémente une interface doit adhérer à son contrat.</span><span class="sxs-lookup"><span data-stu-id="8f078-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="8f078-335">Une interface peut hériter de plusieurs interfaces de base, et une classe ou un struct peut implémenter plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="8f078-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="8f078-336">Les types d’interface sont décrits dans [interfaces](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="8f078-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="8f078-337">Types de tableaux</span><span class="sxs-lookup"><span data-stu-id="8f078-337">Array types</span></span>

<span data-ttu-id="8f078-338">Un tableau est une structure de données qui contient zéro, une ou plusieurs variables accessibles par le biais d’index calculés.</span><span class="sxs-lookup"><span data-stu-id="8f078-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="8f078-339">Les variables contenues dans un tableau, également appelées éléments du tableau, sont toutes du même type, et ce type est appelé le type d’élément du tableau.</span><span class="sxs-lookup"><span data-stu-id="8f078-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="8f078-340">Les types tableau sont décrits dans les [tableaux](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="8f078-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="8f078-341">Types délégués</span><span class="sxs-lookup"><span data-stu-id="8f078-341">Delegate types</span></span>

<span data-ttu-id="8f078-342">Un délégué est une structure de données qui fait référence à une ou plusieurs méthodes.</span><span class="sxs-lookup"><span data-stu-id="8f078-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="8f078-343">Pour les méthodes d’instance, elle fait également référence aux instances d’objet correspondantes.</span><span class="sxs-lookup"><span data-stu-id="8f078-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="8f078-344">L’équivalent le plus proche d’un délégué en C C++ ou est un pointeur de fonction, mais alors qu’un pointeur de fonction ne peut référencer que des fonctions statiques, un délégué peut faire référence à la fois à des méthodes statiques et d’instance.</span><span class="sxs-lookup"><span data-stu-id="8f078-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="8f078-345">Dans ce dernier cas, le délégué stocke non seulement une référence au point d’entrée de la méthode, mais également une référence à l’instance d’objet sur laquelle appeler la méthode.</span><span class="sxs-lookup"><span data-stu-id="8f078-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="8f078-346">Les types délégués sont décrits dans [délégués](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="8f078-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="8f078-347">Boxing et unboxing</span><span class="sxs-lookup"><span data-stu-id="8f078-347">Boxing and unboxing</span></span>

<span data-ttu-id="8f078-348">Le concept de boxing et d’unboxing est central C#pour le système de type de.</span><span class="sxs-lookup"><span data-stu-id="8f078-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="8f078-349">Il fournit un pont entre *Value_type*s et *reference_type*s en autorisant la conversion d’une valeur d’un *Value_type* en type `object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="8f078-350">Le boxing et l’unboxing permettent une vue unifiée du système de type dans lequel une valeur de n’importe quel type peut finalement être traitée comme un objet.</span><span class="sxs-lookup"><span data-stu-id="8f078-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="8f078-351">Conversions boxing</span><span class="sxs-lookup"><span data-stu-id="8f078-351">Boxing conversions</span></span>

<span data-ttu-id="8f078-352">Une conversion boxing permet de convertir implicitement un *Value_type* en *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="8f078-353">Les conversions boxing suivantes existent :</span><span class="sxs-lookup"><span data-stu-id="8f078-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="8f078-354">De n’importe quel *Value_type* vers le type `object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="8f078-355">De n’importe quel *Value_type* vers le type `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="8f078-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="8f078-356">Depuis n’importe quel *non_nullable_value_type* vers n’importe quel *INTERFACE_TYPE* implémenté par *Value_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="8f078-357">De n’importe quel *nullable_type* à n’importe quel *INTERFACE_TYPE* implémenté par le type sous-jacent de *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="8f078-358">De n’importe quel *enum_type* vers le type `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="8f078-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="8f078-359">À partir de n’importe quel *nullable_type* avec un *enum_type* sous-jacent au type `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="8f078-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="8f078-360">Notez qu’une conversion implicite à partir d’un paramètre de type sera exécutée comme conversion boxing si, au moment de l’exécution, elle finit par convertir un type valeur en un type référence ([conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="8f078-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="8f078-361">Le boxing d’une valeur d’un *non_nullable_value_type* consiste à allouer une instance d’objet et à copier la valeur *non_nullable_value_type* dans cette instance.</span><span class="sxs-lookup"><span data-stu-id="8f078-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="8f078-362">Le boxing d’une valeur d’un *nullable_type* produit une référence null s’il s’agit de la valeur `null` (`HasValue` est `false`), ou le résultat de la désencapsulation et du boxing de la valeur sous-jacente dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="8f078-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="8f078-363">Le processus réel de boxing d’une valeur d’un *non_nullable_value_type* est mieux expliqué en imaginant l’existence d’une ***classe Boxing***générique, qui se comporte comme si elle avait été déclarée comme suit :</span><span class="sxs-lookup"><span data-stu-id="8f078-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="8f078-364">La conversion boxing d’une valeur `v` de type `T` consiste à exécuter l’expression `new Box<T>(v)`et à retourner l’instance résultante sous la forme d’une valeur de type `object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="8f078-365">Ainsi, les instructions</span><span class="sxs-lookup"><span data-stu-id="8f078-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="8f078-366">correspondent de manière conceptuelle à</span><span class="sxs-lookup"><span data-stu-id="8f078-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="8f078-367">Une classe Boxing comme `Box<T>` ci-dessus n’existe pas réellement et le type dynamique d’une valeur boxed n’est en fait pas un type de classe.</span><span class="sxs-lookup"><span data-stu-id="8f078-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="8f078-368">Au lieu de cela, une valeur boxed de type `T` a le type dynamique `T`et une vérification de type dynamique à l’aide de l’opérateur `is` peut simplement référencer le type `T`.</span><span class="sxs-lookup"><span data-stu-id="8f078-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="8f078-369">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="8f078-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="8f078-370">génère la chaîne «`Box contains an int`» sur la console.</span><span class="sxs-lookup"><span data-stu-id="8f078-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="8f078-371">Une conversion boxing implique de faire une copie de la valeur convertie.</span><span class="sxs-lookup"><span data-stu-id="8f078-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="8f078-372">Cela est différent d’une conversion d’un *reference_type* en type `object`, dans lequel la valeur continue à faire référence à la même instance et est simplement considérée comme le type moins dérivé `object`.</span><span class="sxs-lookup"><span data-stu-id="8f078-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="8f078-373">Par exemple, étant donné la déclaration</span><span class="sxs-lookup"><span data-stu-id="8f078-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="8f078-374">les instructions suivantes</span><span class="sxs-lookup"><span data-stu-id="8f078-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="8f078-375">génère la valeur 10 dans la console, car l’opération boxing implicite qui se produit lors de l’affectation de `p` à `box` entraîne la copie de la valeur de `p`.</span><span class="sxs-lookup"><span data-stu-id="8f078-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="8f078-376">A `Point` été déclarée comme `class` à la place, la valeur 20 était sortie, car `p` et `box` référençaient la même instance.</span><span class="sxs-lookup"><span data-stu-id="8f078-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="8f078-377">Conversions unboxing</span><span class="sxs-lookup"><span data-stu-id="8f078-377">Unboxing conversions</span></span>

<span data-ttu-id="8f078-378">Une conversion unboxing permet de convertir explicitement un *reference_type* en *Value_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="8f078-379">Les conversions unboxing suivantes existent :</span><span class="sxs-lookup"><span data-stu-id="8f078-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="8f078-380">Du type `object` à n’importe quel *Value_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="8f078-381">Du type `System.ValueType` à n’importe quel *Value_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="8f078-382">De n’importe quel *INTERFACE_TYPE* à n’importe quel *non_nullable_value_type* qui implémente le *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="8f078-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="8f078-383">De n’importe quel *INTERFACE_TYPE* à n’importe quel *nullable_type* dont le type sous-jacent implémente le *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="8f078-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="8f078-384">Du type `System.Enum` à n’importe quel *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="8f078-385">Du type `System.Enum` à n’importe quel *nullable_type* avec un *enum_type*sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="8f078-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="8f078-386">Notez qu’une conversion explicite en paramètre de type sera exécutée comme conversion unboxing si, au moment de l’exécution, elle finit par convertir un type référence en un type valeur ([conversions dynamiques explicites](conversions.md#explicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="8f078-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="8f078-387">Une opération d’unboxing sur un *non_nullable_value_type* consiste à vérifier en premier lieu que l’instance de l’objet est une valeur boxed du *non_nullable_value_type*donné, puis à copier la valeur hors de l’instance.</span><span class="sxs-lookup"><span data-stu-id="8f078-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="8f078-388">La conversion unboxing en *nullable_type* produit la valeur null de *nullable_type* si l’opérande source est `null`, ou le résultat encapsulé de l’unboxing de l’instance d’objet vers le type sous-jacent du *nullable_type* dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="8f078-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="8f078-389">En faisant référence à la classe de boxing imaginaire décrite dans la section précédente, une conversion unboxing d’un objet `box` en *value_type* `T` consiste à exécuter l’expression `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="8f078-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="8f078-390">Ainsi, les instructions</span><span class="sxs-lookup"><span data-stu-id="8f078-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="8f078-391">correspondent de manière conceptuelle à</span><span class="sxs-lookup"><span data-stu-id="8f078-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="8f078-392">Pour qu’une conversion unboxing vers un *non_nullable_value_type* donné aboutisse au moment de l’exécution, la valeur de l’opérande source doit être une référence à une valeur boxed de ce *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="8f078-393">Si l’opérande source est `null`, un `System.NullReferenceException` est levé.</span><span class="sxs-lookup"><span data-stu-id="8f078-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="8f078-394">Si l’opérande source est une référence à un objet incompatible, une `System.InvalidCastException` est levée.</span><span class="sxs-lookup"><span data-stu-id="8f078-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="8f078-395">Pour qu’une conversion unboxing vers un *nullable_type* donné aboutisse au moment de l’exécution, la valeur de l’opérande source doit être `null` ou une référence à une valeur boxed du *non_nullable_value_type* sous-jacent du *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="8f078-396">Si l’opérande source est une référence à un objet incompatible, une `System.InvalidCastException` est levée.</span><span class="sxs-lookup"><span data-stu-id="8f078-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="8f078-397">Types construits</span><span class="sxs-lookup"><span data-stu-id="8f078-397">Constructed types</span></span>

<span data-ttu-id="8f078-398">Une déclaration de type générique, par elle-même, dénote un ***type générique indépendant*** utilisé comme « Blueprint » pour former de nombreux types différents, en appliquant des ***arguments de type***.</span><span class="sxs-lookup"><span data-stu-id="8f078-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="8f078-399">Les arguments de type sont écrits entre crochets pointus (`<` et `>`) juste après le nom du type générique.</span><span class="sxs-lookup"><span data-stu-id="8f078-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="8f078-400">Un type qui comprend au moins un argument de type est appelé ***type construit***.</span><span class="sxs-lookup"><span data-stu-id="8f078-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="8f078-401">Un type construit peut être utilisé à la plupart des emplacements dans le langage dans lequel un nom de type peut apparaître.</span><span class="sxs-lookup"><span data-stu-id="8f078-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="8f078-402">Un type générique indépendant ne peut être utilisé que dans un *typeof_expression* ([l’opérateur typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="8f078-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="8f078-403">Les types construits peuvent également être utilisés dans les expressions en tant que noms simples ([noms simples](expressions.md#simple-names)) ou lors de l’accès à un membre ([accès aux membres](expressions.md#member-access)).</span><span class="sxs-lookup"><span data-stu-id="8f078-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="8f078-404">Quand un *namespace_or_type_name* est évalué, seuls les types génériques avec le nombre correct de paramètres de type sont pris en compte.</span><span class="sxs-lookup"><span data-stu-id="8f078-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="8f078-405">Par conséquent, il est possible d’utiliser le même identificateur pour identifier les différents types, à condition que les types aient des nombres de paramètres de type différents.</span><span class="sxs-lookup"><span data-stu-id="8f078-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="8f078-406">Cela est utile pour mélanger des classes génériques et non génériques dans le même programme :</span><span class="sxs-lookup"><span data-stu-id="8f078-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="8f078-407">Un *type_name* peut identifier un type construit bien qu’il ne spécifie pas directement les paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="8f078-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="8f078-408">Cela peut se produire lorsqu’un type est imbriqué dans une déclaration de classe générique et que le type d’instance de la déclaration conteneur est implicitement utilisé pour la recherche de nom ([types imbriqués dans les classes génériques](classes.md#nested-types-in-generic-classes)) :</span><span class="sxs-lookup"><span data-stu-id="8f078-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="8f078-409">Dans du code unsafe, un type construit ne peut pas être utilisé en tant que *unmanaged_type* ([types pointeur](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="8f078-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="8f078-410">Arguments de type</span><span class="sxs-lookup"><span data-stu-id="8f078-410">Type arguments</span></span>

<span data-ttu-id="8f078-411">Chaque argument dans une liste d’arguments de type est simplement un *type*.</span><span class="sxs-lookup"><span data-stu-id="8f078-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="8f078-412">Dans du code non sécurisé ([code non sécurisé](unsafe-code.md)), un *type_argument* ne peut pas être un type pointeur.</span><span class="sxs-lookup"><span data-stu-id="8f078-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="8f078-413">Chaque argument de type doit satisfaire toutes les contraintes sur le paramètre de type correspondant ([contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="8f078-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="8f078-414">Types ouverts et fermés</span><span class="sxs-lookup"><span data-stu-id="8f078-414">Open and closed types</span></span>

<span data-ttu-id="8f078-415">Tous les types peuvent être classés en tant que ***types ouverts*** ou ***types fermés***.</span><span class="sxs-lookup"><span data-stu-id="8f078-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="8f078-416">Un type ouvert est un type qui implique des paramètres de type.</span><span class="sxs-lookup"><span data-stu-id="8f078-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="8f078-417">Plus précisément :</span><span class="sxs-lookup"><span data-stu-id="8f078-417">More specifically:</span></span>

*  <span data-ttu-id="8f078-418">Un paramètre de type définit un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="8f078-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="8f078-419">Un type tableau est un type ouvert si et uniquement si son type d’élément est un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="8f078-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="8f078-420">Un type construit est un type ouvert si et seulement si un ou plusieurs de ses arguments de type est un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="8f078-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="8f078-421">Un type imbriqué construit est un type ouvert si et seulement si un ou plusieurs de ses arguments de type ou les arguments de type de ses types conteneur sont un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="8f078-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="8f078-422">Un type fermé est un type qui n’est pas un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="8f078-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="8f078-423">Au moment de l’exécution, tout le code au sein d’une déclaration de type générique est exécuté dans le contexte d’un type construit fermé qui a été créé en appliquant des arguments de type à la déclaration générique.</span><span class="sxs-lookup"><span data-stu-id="8f078-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="8f078-424">Chaque paramètre de type dans le type générique est lié à un type au moment de l’exécution particulier.</span><span class="sxs-lookup"><span data-stu-id="8f078-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="8f078-425">Le traitement au moment de l’exécution de toutes les instructions et expressions se produit toujours avec les types fermés, et les types ouverts se produisent uniquement pendant le traitement au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="8f078-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="8f078-426">Chaque type construit fermé a son propre ensemble de variables statiques, qui ne sont pas partagées avec d’autres types construits fermés.</span><span class="sxs-lookup"><span data-stu-id="8f078-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="8f078-427">Étant donné qu’il n’existe pas de type ouvert au moment de l’exécution, aucune variable statique n’est associée à un type ouvert.</span><span class="sxs-lookup"><span data-stu-id="8f078-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="8f078-428">Deux types construits fermés sont du même type s’ils sont construits à partir du même type générique indépendant, et que leurs arguments de type correspondants sont du même type.</span><span class="sxs-lookup"><span data-stu-id="8f078-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="8f078-429">Types liés et indépendants</span><span class="sxs-lookup"><span data-stu-id="8f078-429">Bound and unbound types</span></span>

<span data-ttu-id="8f078-430">Le terme ***type indépendant*** fait référence à un type non générique ou à un type générique indépendant.</span><span class="sxs-lookup"><span data-stu-id="8f078-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="8f078-431">Le ***type lié*** à un terme fait référence à un type non générique ou à un type construit.</span><span class="sxs-lookup"><span data-stu-id="8f078-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="8f078-432">Un type indépendant fait référence à l’entité déclarée par une déclaration de type.</span><span class="sxs-lookup"><span data-stu-id="8f078-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="8f078-433">Un type générique indépendant n’est pas lui-même un type et ne peut pas être utilisé en tant que type d’une variable, d’un argument ou d’une valeur de retour, ou en tant que type de base.</span><span class="sxs-lookup"><span data-stu-id="8f078-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="8f078-434">La seule construction dans laquelle un type générique indépendant peut être référencé est l’expression `typeof` ([opérateur typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="8f078-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="8f078-435">Contraintes de satisfaction</span><span class="sxs-lookup"><span data-stu-id="8f078-435">Satisfying constraints</span></span>

<span data-ttu-id="8f078-436">Chaque fois qu’un type construit ou une méthode générique est référencé, les arguments de type fournis sont vérifiés par rapport aux contraintes de paramètre de type déclarées sur le type ou la méthode générique ([contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="8f078-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="8f078-437">Pour chaque clause `where`, l’argument de type `A` qui correspond au paramètre de type nommé est vérifié par rapport à chaque contrainte comme suit :</span><span class="sxs-lookup"><span data-stu-id="8f078-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="8f078-438">Si la contrainte est un type de classe, un type d’interface ou un paramètre de type, laissez `C` représenter cette contrainte avec les arguments de type fournis, en remplaçant tous les paramètres de type qui apparaissent dans la contrainte.</span><span class="sxs-lookup"><span data-stu-id="8f078-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="8f078-439">Pour satisfaire la contrainte, il faut que le type `A` soit convertible en type `C` par l’un des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="8f078-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="8f078-440">Conversion d’identité ([conversion d’identité](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="8f078-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="8f078-441">Conversion de référence implicite ([conversions de référence implicites](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="8f078-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="8f078-442">Conversion boxing ([conversions boxing](conversions.md#boxing-conversions)), à condition que le type a soit un type valeur n’acceptant pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="8f078-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="8f078-443">Une référence implicite, une conversion boxing ou un paramètre de type d’un paramètre de type `A` à `C`.</span><span class="sxs-lookup"><span data-stu-id="8f078-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="8f078-444">Si la contrainte est la contrainte de type référence (`class`), le type `A` doit correspondre à l’un des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="8f078-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="8f078-445">`A` est un type d’interface, un type de classe, un type délégué ou un type tableau.</span><span class="sxs-lookup"><span data-stu-id="8f078-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="8f078-446">Notez que `System.ValueType` et `System.Enum` sont des types référence qui satisfont cette contrainte.</span><span class="sxs-lookup"><span data-stu-id="8f078-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="8f078-447">`A` est un paramètre de type qui est connu comme étant un type référence ([contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="8f078-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="8f078-448">Si la contrainte est la contrainte de type valeur (`struct`), le type `A` doit correspondre à l’un des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="8f078-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="8f078-449">`A` est un type struct ou un type enum, mais pas un type Nullable.</span><span class="sxs-lookup"><span data-stu-id="8f078-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="8f078-450">Notez que `System.ValueType` et `System.Enum` sont des types référence qui ne répondent pas à cette contrainte.</span><span class="sxs-lookup"><span data-stu-id="8f078-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="8f078-451">`A` est un paramètre de type ayant la contrainte de type valeur ([contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="8f078-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="8f078-452">Si la contrainte est la contrainte de constructeur `new()`, le `A` de type ne doit pas être `abstract` et doit avoir un constructeur sans paramètre public.</span><span class="sxs-lookup"><span data-stu-id="8f078-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="8f078-453">Cette condition est remplie si l’une des conditions suivantes est remplie :</span><span class="sxs-lookup"><span data-stu-id="8f078-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="8f078-454">`A` est un type valeur, car tous les types valeur ont un constructeur public par défaut ([constructeurs par défaut](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="8f078-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="8f078-455">`A` est un paramètre de type ayant la contrainte de constructeur ([contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="8f078-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="8f078-456">`A` est un paramètre de type ayant la contrainte de type valeur ([contraintes de paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="8f078-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="8f078-457">`A` est une classe qui n’est pas `abstract` et qui contient un constructeur `public` déclaré explicitement sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="8f078-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="8f078-458">`A` n’est pas `abstract` et a un constructeur par défaut ([constructeurs par défaut](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="8f078-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="8f078-459">Une erreur de compilation se produit si une ou plusieurs des contraintes d’un paramètre de type ne sont pas satisfaites par les arguments de type donnés.</span><span class="sxs-lookup"><span data-stu-id="8f078-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="8f078-460">Étant donné que les paramètres de type ne sont pas hérités, les contraintes ne sont jamais héritées non plus.</span><span class="sxs-lookup"><span data-stu-id="8f078-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="8f078-461">Dans l’exemple ci-dessous, `D` doit spécifier la contrainte sur son paramètre de type `T` afin que `T` satisfasse à la contrainte imposée par la classe de base `B<T>`.</span><span class="sxs-lookup"><span data-stu-id="8f078-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="8f078-462">En revanche, les `E` de classe n’ont pas besoin de spécifier de contrainte, car `List<T>` implémente `IEnumerable` pour tout `T`.</span><span class="sxs-lookup"><span data-stu-id="8f078-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="8f078-463">Paramètres de type</span><span class="sxs-lookup"><span data-stu-id="8f078-463">Type parameters</span></span>

<span data-ttu-id="8f078-464">Un paramètre de type est un identificateur désignant un type valeur ou un type référence auquel le paramètre est lié au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="8f078-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="8f078-465">Étant donné qu’un paramètre de type peut être instancié avec un grand nombre d’arguments de type réels différents, les paramètres de type ont des opérations et des restrictions légèrement différentes de celles des autres types.</span><span class="sxs-lookup"><span data-stu-id="8f078-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="8f078-466">Elles incluent notamment les suivantes :</span><span class="sxs-lookup"><span data-stu-id="8f078-466">These include:</span></span>

*  <span data-ttu-id="8f078-467">Un paramètre de type ne peut pas être utilisé directement pour déclarer une classe de base ([classe de base](classes.md#base-class)) ou une interface (listes de[paramètres de type Variant](interfaces.md#variant-type-parameter-lists)).</span><span class="sxs-lookup"><span data-stu-id="8f078-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="8f078-468">Les règles de recherche de membre sur les paramètres de type dépendent des contraintes, le cas échéant, appliquées au paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="8f078-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="8f078-469">Ils sont détaillés dans la [recherche de membres](expressions.md#member-lookup).</span><span class="sxs-lookup"><span data-stu-id="8f078-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="8f078-470">Les conversions disponibles pour un paramètre de type dépendent des contraintes, le cas échéant, appliquées au paramètre de type.</span><span class="sxs-lookup"><span data-stu-id="8f078-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="8f078-471">Ils sont détaillés dans les [conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters) et des [conversions dynamiques explicites](conversions.md#explicit-dynamic-conversions).</span><span class="sxs-lookup"><span data-stu-id="8f078-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="8f078-472">La `null` littérale ne peut pas être convertie en un type donné par un paramètre de type, sauf si le paramètre de type est connu comme étant un type référence ([conversions implicites impliquant des paramètres de type](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="8f078-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="8f078-473">Toutefois, une expression `default` ([expressions de valeur par défaut](expressions.md#default-value-expressions)) peut être utilisée à la place.</span><span class="sxs-lookup"><span data-stu-id="8f078-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="8f078-474">En outre, une valeur avec un type donné par un paramètre de type peut être comparée à `null` à l’aide de `==` et `!=` ([opérateurs d’égalité de type référence](expressions.md#reference-type-equality-operators)) à moins que le paramètre de type ait la contrainte de type valeur.</span><span class="sxs-lookup"><span data-stu-id="8f078-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="8f078-475">Une expression `new` ([expressions de création d’objet](expressions.md#object-creation-expressions)) peut uniquement être utilisée avec un paramètre de type si le paramètre de type est imposé par un *constructor_constraint* ou la contrainte de type valeur (contraintes de[paramètre de type](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="8f078-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="8f078-476">Un paramètre de type ne peut pas être utilisé n’importe où dans un attribut.</span><span class="sxs-lookup"><span data-stu-id="8f078-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="8f078-477">Un paramètre de type ne peut pas être utilisé dans un accès de membre ([accès aux membres](expressions.md#member-access)) ou un nom de type (noms d’espaces de noms[et de types](basic-concepts.md#namespace-and-type-names)) pour identifier un membre statique ou un type imbriqué.</span><span class="sxs-lookup"><span data-stu-id="8f078-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="8f078-478">Dans du code unsafe, un paramètre de type ne peut pas être utilisé en tant que *unmanaged_type* ([types pointeur](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="8f078-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="8f078-479">En tant que type, les paramètres de type sont purement une construction au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="8f078-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="8f078-480">Au moment de l’exécution, chaque paramètre de type est lié à un type au moment de l’exécution qui a été spécifié en fournissant un argument de type à la déclaration de type générique.</span><span class="sxs-lookup"><span data-stu-id="8f078-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="8f078-481">Ainsi, le type d’une variable déclarée avec un paramètre de type sera, au moment de l’exécution, un type construit fermé ([types ouverts et fermés](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="8f078-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="8f078-482">L’exécution de toutes les instructions et expressions impliquant des paramètres de type au moment de l’exécution utilise le type réel fourni comme argument de type pour ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="8f078-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="8f078-483">Types d’arborescence d’expression</span><span class="sxs-lookup"><span data-stu-id="8f078-483">Expression tree types</span></span>

<span data-ttu-id="8f078-484">Les ***arborescences d’expressions*** permettent aux expressions lambda d’être représentées en tant que structures de données au lieu du code exécutable.</span><span class="sxs-lookup"><span data-stu-id="8f078-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="8f078-485">Les arborescences d’expressions sont des valeurs des ***types d’arborescence d’expression*** de la forme `System.Linq.Expressions.Expression<D>`, où `D` est un type délégué.</span><span class="sxs-lookup"><span data-stu-id="8f078-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="8f078-486">Pour le reste de cette spécification, nous faisons référence à ces types à l’aide de la `Expression<D>`abrégée.</span><span class="sxs-lookup"><span data-stu-id="8f078-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="8f078-487">S’il existe une conversion d’une expression lambda en un type délégué `D`, une conversion existe également dans le type d’arborescence de l’expression `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="8f078-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="8f078-488">Tandis que la conversion d’une expression lambda en un type délégué génère un délégué qui fait référence à du code exécutable pour l’expression lambda, la conversion en un type d’arborescence d’expression crée une représentation d’arborescence d’expression de l’expression lambda.</span><span class="sxs-lookup"><span data-stu-id="8f078-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="8f078-489">Les arborescences d’expressions sont des représentations efficaces des données en mémoire des expressions lambda et rendent la structure de l’expression lambda transparente et explicite.</span><span class="sxs-lookup"><span data-stu-id="8f078-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="8f078-490">Tout comme un type délégué `D`, `Expression<D>` est considéré comme ayant des types de paramètres et de retour, qui sont identiques à ceux de `D`.</span><span class="sxs-lookup"><span data-stu-id="8f078-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="8f078-491">L’exemple suivant représente une expression lambda à la fois comme du code exécutable et comme une arborescence de l’expression.</span><span class="sxs-lookup"><span data-stu-id="8f078-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="8f078-492">Étant donné qu’il existe une conversion à `Func<int,int>`, une conversion existe également pour `Expression<Func<int,int>>`:</span><span class="sxs-lookup"><span data-stu-id="8f078-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="8f078-493">À la suite de ces assignations, le délégué `del` référence une méthode qui retourne `x + 1`, et l’arborescence d’expression `exp` référence une structure de données qui décrit l' `x => x + 1`d’expression.</span><span class="sxs-lookup"><span data-stu-id="8f078-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="8f078-494">La définition exacte du type générique `Expression<D>` ainsi que les règles précises pour la construction d’une arborescence d’expressions quand une expression lambda est convertie en un type d’arborescence d’expression, elles sont toutes deux en dehors de la portée de cette spécification.</span><span class="sxs-lookup"><span data-stu-id="8f078-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="8f078-495">Deux choses sont importantes pour rendre explicite :</span><span class="sxs-lookup"><span data-stu-id="8f078-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="8f078-496">Toutes les expressions lambda ne peuvent pas être converties en arborescences d’expressions.</span><span class="sxs-lookup"><span data-stu-id="8f078-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="8f078-497">Par exemple, les expressions lambda avec corps d’instruction et les expressions lambda contenant des expressions d’assignation ne peuvent pas être représentées.</span><span class="sxs-lookup"><span data-stu-id="8f078-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="8f078-498">Dans ce cas, une conversion existe toujours, mais elle échoue au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="8f078-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="8f078-499">Ces exceptions sont détaillées dans les [conversions de fonctions anonymes](conversions.md#anonymous-function-conversions).</span><span class="sxs-lookup"><span data-stu-id="8f078-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="8f078-500">`Expression<D>` offre une méthode d’instance `Compile` qui produit un délégué de type `D`:</span><span class="sxs-lookup"><span data-stu-id="8f078-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="8f078-501">L’appel de ce délégué provoque l’exécution du code représenté par l’arborescence de l’expression.</span><span class="sxs-lookup"><span data-stu-id="8f078-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="8f078-502">Par conséquent, étant donné les définitions ci-dessus, del et DEL2 sont équivalentes, et les deux instructions suivantes ont le même effet :</span><span class="sxs-lookup"><span data-stu-id="8f078-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="8f078-503">Après l’exécution de ce code, `i1` et `i2` auront tous les deux la valeur `2`.</span><span class="sxs-lookup"><span data-stu-id="8f078-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>

