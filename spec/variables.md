# <a name="variables"></a><span data-ttu-id="ce689-101">Variables</span><span class="sxs-lookup"><span data-stu-id="ce689-101">Variables</span></span>

<span data-ttu-id="ce689-102">Les variables représentent des emplacements de stockage.</span><span class="sxs-lookup"><span data-stu-id="ce689-102">Variables represent storage locations.</span></span> <span data-ttu-id="ce689-103">Chaque variable possède un type qui détermine les valeurs pouvant être stockées dans la variable.</span><span class="sxs-lookup"><span data-stu-id="ce689-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="ce689-104">C# est un langage de type sécurisé et le compilateur c# garantit que les valeurs stockées dans des variables sont toujours du type approprié.</span><span class="sxs-lookup"><span data-stu-id="ce689-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="ce689-105">La valeur d’une variable peut être modifiée par assignation ou par le biais de la `++` et `--` opérateurs.</span><span class="sxs-lookup"><span data-stu-id="ce689-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="ce689-106">Une variable doit être ***définitivement assignée*** ([assignation définie](variables.md#definite-assignment)) avant de pouvoir obtenir sa valeur.</span><span class="sxs-lookup"><span data-stu-id="ce689-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="ce689-107">Comme décrit dans les sections suivantes, les variables sont soit ***initialement attribué*** ou ***initialement non assignées***.</span><span class="sxs-lookup"><span data-stu-id="ce689-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="ce689-108">Une variable initialement assignée possède une valeur initiale bien définie et est toujours considéré comme définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="ce689-109">Il n’y a aucune valeur initiale pour une variable initialement non assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="ce689-110">Pour une variable initialement non assignée être considéré comme définitivement assignée à un emplacement donné, une affectation à la variable doit se produire dans chaque chemin d’accès d’exécution possibles menant à cet emplacement.</span><span class="sxs-lookup"><span data-stu-id="ce689-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="ce689-111">Catégories de variables</span><span class="sxs-lookup"><span data-stu-id="ce689-111">Variable categories</span></span>

<span data-ttu-id="ce689-112">C# définit sept catégories de variables : les variables statiques, variables d’instance, éléments de tableau, paramètres de valeur, paramètres de référence, paramètres de sortie et les variables locales.</span><span class="sxs-lookup"><span data-stu-id="ce689-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="ce689-113">Les sections qui suivent décrivent chacun de ces catégories.</span><span class="sxs-lookup"><span data-stu-id="ce689-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="ce689-114">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="ce689-114">In the example</span></span>
```csharp
class A
{
public static int x;
int y;

void F(int[] v, int a, ref int b, out int c) {
int i = 1;
c = a + b++;
}
}
```
<span data-ttu-id="ce689-115">`x` est une variable statique, `y` est une variable d’instance, `v[0]` est un élément de tableau, `a` est un paramètre de valeur, `b` est un paramètre de référence, `c` est un paramètre de sortie, et `i` est une variable locale.</span><span class="sxs-lookup"><span data-stu-id="ce689-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="ce689-116">Variables statiques</span><span class="sxs-lookup"><span data-stu-id="ce689-116">Static variables</span></span>

<span data-ttu-id="ce689-117">Un champ déclaré avec le `static` modificateur est appelé un ***variable statique***.</span><span class="sxs-lookup"><span data-stu-id="ce689-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="ce689-118">Une variable statique entame son existence avant l’exécution du constructeur statique ([constructeurs statiques](classes.md#static-constructors)) pour son type conteneur et cesse d’exister quand le domaine d’application associé n’existe plus.</span><span class="sxs-lookup"><span data-stu-id="ce689-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="ce689-119">La valeur initiale d’une variable statique est la valeur par défaut ([valeurs par défaut](variables.md#default-values)) de type de la variable.</span><span class="sxs-lookup"><span data-stu-id="ce689-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="ce689-120">À des fins de vérification de l’assignation définie, une variable statique est considéré comme initialement affecté.</span><span class="sxs-lookup"><span data-stu-id="ce689-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="ce689-121">Variables d’instance</span><span class="sxs-lookup"><span data-stu-id="ce689-121">Instance variables</span></span>

<span data-ttu-id="ce689-122">Un champ déclaré sans le `static` modificateur est appelé un ***variable d’instance***.</span><span class="sxs-lookup"><span data-stu-id="ce689-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="ce689-123">Variables d’instance dans les classes</span><span class="sxs-lookup"><span data-stu-id="ce689-123">Instance variables in classes</span></span>

<span data-ttu-id="ce689-124">Une variable d’instance d’une classe entame son existence lorsqu’une nouvelle instance de cette classe est créée et cesse d’exister quand il n’existe aucune référence à cette instance et le destructeur de l’instance (le cas échéant) a été exécutée.</span><span class="sxs-lookup"><span data-stu-id="ce689-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="ce689-125">La valeur initiale d’une variable d’instance d’une classe est la valeur par défaut ([valeurs par défaut](variables.md#default-values)) de type de la variable.</span><span class="sxs-lookup"><span data-stu-id="ce689-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="ce689-126">À des fins de vérification de l’assignation définie, une variable d’instance d’une classe est considérée comme initialement affecté.</span><span class="sxs-lookup"><span data-stu-id="ce689-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="ce689-127">Variables d’instance dans les structs</span><span class="sxs-lookup"><span data-stu-id="ce689-127">Instance variables in structs</span></span>

<span data-ttu-id="ce689-128">Une variable d’instance d’un struct a exactement la même durée de vie que la variable de structure à laquelle il appartient.</span><span class="sxs-lookup"><span data-stu-id="ce689-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="ce689-129">En d’autres termes, quand une variable d’un type struct naît ou cesse d’exister, faire trop les variables d’instance du struct.</span><span class="sxs-lookup"><span data-stu-id="ce689-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="ce689-130">L’état d’affectation initiale d’une variable d’instance d’un struct est identique à celui de la variable de struct qui le contient.</span><span class="sxs-lookup"><span data-stu-id="ce689-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="ce689-131">En d’autres termes, quand une variable de struct est considérée comme initialement attribuée, donc trop sont ses variables d’instance, et lorsqu’une variable de struct est considérée comme initialement non assignée, ses variables d’instance sont de même non attribués.</span><span class="sxs-lookup"><span data-stu-id="ce689-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="ce689-132">Éléments de tableau</span><span class="sxs-lookup"><span data-stu-id="ce689-132">Array elements</span></span>

<span data-ttu-id="ce689-133">Les éléments d’un tableau entrent en vigueur lorsqu’une instance de tableau est créée et cessent d’exister lorsqu’il n’existe aucune référence à cette instance de tableau.</span><span class="sxs-lookup"><span data-stu-id="ce689-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="ce689-134">La valeur initiale de chacun des éléments d’un tableau est la valeur par défaut ([valeurs par défaut](variables.md#default-values)) du type des éléments du tableau.</span><span class="sxs-lookup"><span data-stu-id="ce689-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="ce689-135">À des fins de vérification de l’assignation définie, un élément de tableau est considéré comme initialement affecté.</span><span class="sxs-lookup"><span data-stu-id="ce689-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="ce689-136">Paramètres de valeur</span><span class="sxs-lookup"><span data-stu-id="ce689-136">Value parameters</span></span>

<span data-ttu-id="ce689-137">Un paramètre déclaré sans un `ref` ou `out` modificateur est un ***paramètre de valeur***.</span><span class="sxs-lookup"><span data-stu-id="ce689-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="ce689-138">Un paramètre de valeur naît dès l’appel de la fonction membre (méthode, constructeur d’instance, accesseur ou opérateur) ou une fonction anonyme à laquelle appartient le paramètre et est initialisé avec la valeur de l’argument fourni dans l’appel.</span><span class="sxs-lookup"><span data-stu-id="ce689-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="ce689-139">Un paramètre de valeur normalement cesse d’exister dès le retour de la fonction membre ou une fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="ce689-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="ce689-140">Toutefois, si le paramètre value est capturé par une fonction anonyme ([expressions de fonction anonyme](expressions.md#anonymous-function-expressions)), sa durée de vie s’étend au moins jusqu'à ce que le délégué ou arborescence de l’expression créée à partir de cette fonction anonyme est éligible pour le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="ce689-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="ce689-141">À des fins de vérification de l’assignation définie, un paramètre de valeur est considéré comme initialement affecté.</span><span class="sxs-lookup"><span data-stu-id="ce689-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="ce689-142">Paramètres de référence</span><span class="sxs-lookup"><span data-stu-id="ce689-142">Reference parameters</span></span>

<span data-ttu-id="ce689-143">Un paramètre déclaré avec un `ref` modificateur est un ***de référencer le paramètre***.</span><span class="sxs-lookup"><span data-stu-id="ce689-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="ce689-144">Un paramètre de référence ne crée pas un nouvel emplacement de stockage.</span><span class="sxs-lookup"><span data-stu-id="ce689-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="ce689-145">Au lieu de cela, un paramètre de référence représente le même emplacement de stockage que la variable fournie comme argument dans la fonction membre ou un appel de fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="ce689-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="ce689-146">Par conséquent, la valeur d’un paramètre de référence est toujours identique à la variable sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="ce689-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="ce689-147">Les règles d’assignation définie suivantes s’appliquent aux paramètres de référence.</span><span class="sxs-lookup"><span data-stu-id="ce689-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="ce689-148">Notez les règles différentes pour les paramètres output décrits dans [paramètres de sortie](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="ce689-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="ce689-149">Une variable doit absolument être assignée ([assignation définie](variables.md#definite-assignment)) avant qu’il peut être passé comme paramètre de référence dans un appel de fonction membre ou un délégué.</span><span class="sxs-lookup"><span data-stu-id="ce689-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="ce689-150">Au sein d’une fonction membre ou une fonction anonyme, un paramètre de référence est considérée comme étant initialement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="ce689-151">Dans une méthode d’instance ou un accesseur d’instance d’un type struct, le `this` mot clé se comporte exactement comme un paramètre de référence du type struct ([cet accès](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="ce689-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="ce689-152">Paramètres de sortie</span><span class="sxs-lookup"><span data-stu-id="ce689-152">Output parameters</span></span>

<span data-ttu-id="ce689-153">Un paramètre déclaré avec un `out` modificateur est un ***paramètre de sortie***.</span><span class="sxs-lookup"><span data-stu-id="ce689-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="ce689-154">Un paramètre de sortie ne crée pas un nouvel emplacement de stockage.</span><span class="sxs-lookup"><span data-stu-id="ce689-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="ce689-155">Au lieu de cela, un paramètre de sortie représente le même emplacement de stockage que la variable fournie comme argument dans l’appel de fonction membre ou un délégué.</span><span class="sxs-lookup"><span data-stu-id="ce689-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="ce689-156">Par conséquent, la valeur d’un paramètre de sortie est toujours identique à la variable sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="ce689-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="ce689-157">Les règles d’assignation définie suivantes s’appliquent aux paramètres de sortie.</span><span class="sxs-lookup"><span data-stu-id="ce689-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="ce689-158">Notez les règles différentes pour les paramètres de référence décrits dans [paramètres de référence](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="ce689-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="ce689-159">Une variable ne doive pas être définitivement assignée avant qu’il peut être passé comme paramètre de sortie dans une fonction membre ou appel de délégué.</span><span class="sxs-lookup"><span data-stu-id="ce689-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="ce689-160">Après l’exécution normale d’un appel de fonction membre ou un délégué, chaque variable qui a été passé comme un paramètre de sortie est considérée comme assignée dans ce chemin d’exécution.</span><span class="sxs-lookup"><span data-stu-id="ce689-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="ce689-161">Au sein d’une fonction membre ou une fonction anonyme, un paramètre de sortie est considéré comme initialement non assigné.</span><span class="sxs-lookup"><span data-stu-id="ce689-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="ce689-162">Chaque paramètre de sortie d’une fonction membre ou une fonction anonyme doit absolument être assigné ([assignation définie](variables.md#definite-assignment)) avant que la fonction membre ou une fonction anonyme retourne normalement.</span><span class="sxs-lookup"><span data-stu-id="ce689-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="ce689-163">Au sein d’un constructeur d’instance d’un type struct, le `this` mot clé se comporte exactement comme un paramètre de sortie du type struct ([cet accès](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="ce689-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="ce689-164">Variables locales</span><span class="sxs-lookup"><span data-stu-id="ce689-164">Local variables</span></span>

<span data-ttu-id="ce689-165">Un ***variable locale*** est déclarée par un *local_variable_declaration*, ce qui peut se produire dans un *bloc*, un *for_statement*, un *switch_statement* ou un *using_statement*; ou par un *foreach_statement* ou un *specific_catch_clause* pour un *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="ce689-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="ce689-166">La durée de vie d’une variable locale est la partie de l’exécution du programme au cours de laquelle le stockage est garantie comme étant réservé pour celui-ci.</span><span class="sxs-lookup"><span data-stu-id="ce689-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="ce689-167">Cette durée de vie s’étend au moins à partir de l’entrée dans le *bloc*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, ou *specific_catch_clause* auquel il est associé, jusqu'à l’exécution de ce *bloc*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, ou *specific_catch_clause* se termine en aucune façon.</span><span class="sxs-lookup"><span data-stu-id="ce689-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="ce689-168">(Entrer un texte délimité *bloc* ou de l’appel d’une méthode suspend, mais ne termine pas, l’exécution de l’actuel *bloc*, *for_statement*, *switch_statement* , *using_statement*, *foreach_statement*, ou *specific_catch_clause*.) Si la variable locale est capturée par une fonction anonyme ([externes variables capturées](expressions.md#captured-outer-variables)), sa durée de vie s’étend au moins jusqu'à ce que l’arborescence de délégué ou une expression créée à partir de la fonction anonyme, ainsi que tous les autres objets qui viennent à référencez la variable capturée, sont éligibles pour le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="ce689-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="ce689-169">Si le parent *bloc*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, ou *specific_catch_clause* est entrée récursive, une nouvelle instance de la variable locale est créée chaque fois et son *local_variable_initializer*, le cas échéant, est évalué chaque fois.</span><span class="sxs-lookup"><span data-stu-id="ce689-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="ce689-170">Une variable locale introduite par un *local_variable_declaration* n’est pas initialisée automatiquement et n’a donc aucune valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="ce689-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="ce689-171">À des fins de vérification de l’assignation définie, une variable locale introduites par un *local_variable_declaration* est considéré comme initialement non assignées.</span><span class="sxs-lookup"><span data-stu-id="ce689-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="ce689-172">Un *local_variable_declaration* peut inclure un *local_variable_initializer*, auquel cas la variable est considéré comme définitivement assignée uniquement après l’expression d’initialisation ([ Les instructions de déclaration](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="ce689-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="ce689-173">Dans l’étendue d’une variable locale introduite par un *local_variable_declaration*, il s’agit d’une erreur de compilation pour faire référence à cette variable locale dans une position du texte qui précède sa *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="ce689-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="ce689-174">Si la déclaration de variable locale est implicite ([déclarations de variables locales](statements.md#local-variable-declarations)), il est également une erreur pour faire référence à la variable au sein de son *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="ce689-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="ce689-175">Une variable locale introduite par un *foreach_statement* ou un *specific_catch_clause* est considéré comme définitivement assignée dans toute sa portée.</span><span class="sxs-lookup"><span data-stu-id="ce689-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="ce689-176">La durée de vie réelle d’une variable locale est dépend de l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="ce689-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="ce689-177">Par exemple, un compilateur peut déterminer de manière statique qu’une variable locale dans un bloc est uniquement utilisée pour une petite portion de ce bloc.</span><span class="sxs-lookup"><span data-stu-id="ce689-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="ce689-178">À l’aide de cette analyse, le compilateur peut générer du code qui résulte dans le stockage de la variable ayant une durée de vie plus courte que son bloc conteneur.</span><span class="sxs-lookup"><span data-stu-id="ce689-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="ce689-179">Le stockage référencé par une variable de référence locale est récupéré indépendamment de la durée de vie de cette variable de référence locale ([gestion automatique de la mémoire](basic-concepts.md#automatic-memory-management)).</span><span class="sxs-lookup"><span data-stu-id="ce689-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="ce689-180">Valeurs par défaut</span><span class="sxs-lookup"><span data-stu-id="ce689-180">Default values</span></span>

<span data-ttu-id="ce689-181">Les catégories de variables suivantes sont automatiquement initialisés à leurs valeurs par défaut :</span><span class="sxs-lookup"><span data-stu-id="ce689-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="ce689-182">variables statiques</span><span class="sxs-lookup"><span data-stu-id="ce689-182">Static variables.</span></span>
*  <span data-ttu-id="ce689-183">Variables d’instance des instances de classe.</span><span class="sxs-lookup"><span data-stu-id="ce689-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="ce689-184">Éléments de tableau.</span><span class="sxs-lookup"><span data-stu-id="ce689-184">Array elements.</span></span>

<span data-ttu-id="ce689-185">La valeur par défaut d’une variable dépend du type de la variable et est déterminée comme suit :</span><span class="sxs-lookup"><span data-stu-id="ce689-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="ce689-186">Pour une variable d’un *value_type*, la valeur par défaut est identique à la valeur calculée par le *value_type*du constructeur par défaut ([constructeurs par défaut](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="ce689-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="ce689-187">Pour une variable d’un *reference_type*, la valeur par défaut est `null`.</span><span class="sxs-lookup"><span data-stu-id="ce689-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="ce689-188">L’initialisation de valeurs par défaut est généralement effectuée en ayant le Gestionnaire de mémoire ou du garbage collector initialiser la mémoire à tous les bits à zéro avant qu’il est alloué pour l’utilisation.</span><span class="sxs-lookup"><span data-stu-id="ce689-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="ce689-189">Pour cette raison, il est pratique d’utiliser tous les bits à zéro pour représenter la référence null.</span><span class="sxs-lookup"><span data-stu-id="ce689-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="ce689-190">Assignation définie</span><span class="sxs-lookup"><span data-stu-id="ce689-190">Definite assignment</span></span>

<span data-ttu-id="ce689-191">À un emplacement donné dans le code exécutable d’une fonction membre, une variable est dite ***définitivement assignée*** si le compilateur peut prouver, par une analyse de flux statique particulier ([règles précises de détermination définitive affectation](variables.md#precise-rules-for-determining-definite-assignment)), que la variable a été initialisée automatiquement ou a été la cible d’au moins une assignation.</span><span class="sxs-lookup"><span data-stu-id="ce689-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="ce689-192">Les règles d’assignation définie de manière informelle indiqué, sont :</span><span class="sxs-lookup"><span data-stu-id="ce689-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="ce689-193">Une variable initialement assignée ([initialement affecté variables](variables.md#initially-assigned-variables)) est toujours considéré comme définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="ce689-194">Une variable initialement non assignée ([initialement non assignées variables](variables.md#initially-unassigned-variables)) est considérée comme définitivement assignée à un emplacement donné si tous les chemins d’exécution possibles conduisant à cet emplacement contiennent au moins un des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="ce689-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="ce689-195">Une assignation simple ([assignation Simple](expressions.md#simple-assignment)) dans lequel la variable est l’opérande de gauche.</span><span class="sxs-lookup"><span data-stu-id="ce689-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="ce689-196">Une expression d’appel ([expressions d’appel](expressions.md#invocation-expressions)) ou une expression de création d’objet ([des expressions de la création d’objet](expressions.md#object-creation-expressions)) qui passe la variable comme un paramètre de sortie.</span><span class="sxs-lookup"><span data-stu-id="ce689-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="ce689-197">Pour une variable locale, une déclaration de variable locale ([déclarations de variables locales](statements.md#local-variable-declarations)) qui inclut un initialiseur de variable.</span><span class="sxs-lookup"><span data-stu-id="ce689-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="ce689-198">La spécification formelle sous-jacent informelles règles ci-dessus est décrite dans [initialement affecté variables](variables.md#initially-assigned-variables), [initialement non assignées variables](variables.md#initially-unassigned-variables), et [règles précises de détermination assignation définie](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="ce689-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="ce689-199">Les États d’assignation définie des variables d’instance d’un *struct_type* variable sont suivies individuellement, ainsi que collectivement.</span><span class="sxs-lookup"><span data-stu-id="ce689-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="ce689-200">Dans supplémentaires aux règles ci-dessus, les règles suivantes s’appliquent à *struct_type* variables et leurs variables de l’instance :</span><span class="sxs-lookup"><span data-stu-id="ce689-200">In additional to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="ce689-201">Une variable d’instance est considérée comme définitivement assignée si son contenant *struct_type* variable est considéré comme définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="ce689-202">Un *struct_type* variable est considérée comme assignée définitivement si chacune de ses variables d’instance est considérée comme définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="ce689-203">Assignation définie est obligatoire dans les contextes suivants :</span><span class="sxs-lookup"><span data-stu-id="ce689-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="ce689-204">Une variable doit être assignée de manière définitive à chaque emplacement où sa valeur est obtenue.</span><span class="sxs-lookup"><span data-stu-id="ce689-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="ce689-205">Cela garantit que les valeurs non définis se produisent pas.</span><span class="sxs-lookup"><span data-stu-id="ce689-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="ce689-206">L’occurrence d’une variable dans une expression est considérée pour obtenir la valeur de la variable, sauf quand</span><span class="sxs-lookup"><span data-stu-id="ce689-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="ce689-207">la variable est l’opérande gauche d’une assignation simple,</span><span class="sxs-lookup"><span data-stu-id="ce689-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="ce689-208">la variable est passée comme paramètre de sortie, ou</span><span class="sxs-lookup"><span data-stu-id="ce689-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="ce689-209">la variable est un *struct_type* variable et se produit comme opérande gauche d’un accès au membre.</span><span class="sxs-lookup"><span data-stu-id="ce689-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="ce689-210">Une variable doit être assignée de manière définitive à chaque emplacement où elle est transmise comme paramètre de référence.</span><span class="sxs-lookup"><span data-stu-id="ce689-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="ce689-211">Cela garantit que le membre de fonction appelé peut prendre en compte le paramètre de référence est affecté initialement.</span><span class="sxs-lookup"><span data-stu-id="ce689-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="ce689-212">Tous les paramètres de sortie d’une fonction membre doivent absolument être assignés à chaque emplacement où la fonction membre retourne (via un `return` instruction ou exécution atteint la fin du corps du membre de fonction).</span><span class="sxs-lookup"><span data-stu-id="ce689-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="ce689-213">Cela garantit que les fonctions membres ne retournent pas des valeurs non définis dans les paramètres de sortie, ce qui permet au compilateur de considérer un appel de fonction membre qui prend une variable comme paramètre de sortie équivalent à une assignation à la variable.</span><span class="sxs-lookup"><span data-stu-id="ce689-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="ce689-214">Le `this` variable d’un *struct_type* constructeur d’instance doit absolument être assigné à chaque emplacement où ce constructeur retourne.</span><span class="sxs-lookup"><span data-stu-id="ce689-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="ce689-215">Variables initialement attribuées</span><span class="sxs-lookup"><span data-stu-id="ce689-215">Initially assigned variables</span></span>

<span data-ttu-id="ce689-216">Les catégories suivantes de variables sont considérées comme initialement assignées :</span><span class="sxs-lookup"><span data-stu-id="ce689-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="ce689-217">variables statiques</span><span class="sxs-lookup"><span data-stu-id="ce689-217">Static variables.</span></span>
*  <span data-ttu-id="ce689-218">Variables d’instance des instances de classe.</span><span class="sxs-lookup"><span data-stu-id="ce689-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="ce689-219">Variables d’instance de variables struct initialement attribué.</span><span class="sxs-lookup"><span data-stu-id="ce689-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="ce689-220">Éléments de tableau.</span><span class="sxs-lookup"><span data-stu-id="ce689-220">Array elements.</span></span>
*  <span data-ttu-id="ce689-221">Paramètres de valeur.</span><span class="sxs-lookup"><span data-stu-id="ce689-221">Value parameters.</span></span>
*  <span data-ttu-id="ce689-222">Paramètres de référence.</span><span class="sxs-lookup"><span data-stu-id="ce689-222">Reference parameters.</span></span>
*  <span data-ttu-id="ce689-223">Variables déclarées dans un `catch` clause ou un `foreach` instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="ce689-224">Variables initialement non assignées</span><span class="sxs-lookup"><span data-stu-id="ce689-224">Initially unassigned variables</span></span>

<span data-ttu-id="ce689-225">Les catégories suivantes de variables sont considérées comme initialement non assignées :</span><span class="sxs-lookup"><span data-stu-id="ce689-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="ce689-226">Variables d’instance de variables struct initialement non assignées.</span><span class="sxs-lookup"><span data-stu-id="ce689-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="ce689-227">Paramètres de sortie, y compris le `this` variable struct constructeurs d’instance.</span><span class="sxs-lookup"><span data-stu-id="ce689-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="ce689-228">Les variables locales, à l’exception de ceux déclarés dans un `catch` clause ou un `foreach` instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="ce689-229">Règles précises de détermination d’assignation définie</span><span class="sxs-lookup"><span data-stu-id="ce689-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="ce689-230">Afin de déterminer que chaque variable utilisée est une assignation, le compilateur doit utiliser un processus qui est équivalent à celle décrite dans cette section.</span><span class="sxs-lookup"><span data-stu-id="ce689-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="ce689-231">Le compilateur traite le corps de chaque fonction membre qui a une ou plusieurs variables initialement non assignées.</span><span class="sxs-lookup"><span data-stu-id="ce689-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="ce689-232">Pour chaque variable initialement non assignée *v*, le compilateur détermine un ***état d’assignation définie*** pour *v* sur chacun des points suivants dans la fonction membre :</span><span class="sxs-lookup"><span data-stu-id="ce689-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="ce689-233">Au début de chaque instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="ce689-234">Au point de terminaison ([points de terminaison et accessibilité](statements.md#end-points-and-reachability)) de chaque instruction</span><span class="sxs-lookup"><span data-stu-id="ce689-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="ce689-235">Sur chaque arc qui transfère le contrôle à une autre instruction ou au point de terminaison d’une instruction</span><span class="sxs-lookup"><span data-stu-id="ce689-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="ce689-236">Au début de chaque expression</span><span class="sxs-lookup"><span data-stu-id="ce689-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="ce689-237">À la fin de chaque expression</span><span class="sxs-lookup"><span data-stu-id="ce689-237">At the end of each expression</span></span>

<span data-ttu-id="ce689-238">L’état d’assignation définie *v* peut être :</span><span class="sxs-lookup"><span data-stu-id="ce689-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="ce689-239">Une assignation.</span><span class="sxs-lookup"><span data-stu-id="ce689-239">Definitely assigned.</span></span> <span data-ttu-id="ce689-240">Cela indique que sur tous les flux de contrôle possibles à ce stade, *v* une valeur a été attribuée.</span><span class="sxs-lookup"><span data-stu-id="ce689-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="ce689-241">Pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-241">Not definitely assigned.</span></span> <span data-ttu-id="ce689-242">Pour l’état d’une variable à la fin d’une expression de type `bool`, l’état d’une variable qui n’est pas définitivement assignée mai (mais n’est pas nécessairement) appartiennent à un des états secondaires suivants :</span><span class="sxs-lookup"><span data-stu-id="ce689-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="ce689-243">Définitivement assignée après une expression true.</span><span class="sxs-lookup"><span data-stu-id="ce689-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="ce689-244">Cet état indique que *v* est définitivement assignée si l’expression booléenne évaluée comme vraie, mais n’est pas forcément assignée si l’expression booléenne évaluée comme false.</span><span class="sxs-lookup"><span data-stu-id="ce689-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="ce689-245">Définitivement assignée après une expression false.</span><span class="sxs-lookup"><span data-stu-id="ce689-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="ce689-246">Cet état indique que *v* est définitivement assignée si l’expression booléenne évaluée comme false, mais n’est pas forcément assignée si l’expression booléenne évaluée comme vraie.</span><span class="sxs-lookup"><span data-stu-id="ce689-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="ce689-247">Les règles suivantes régissent comment l’état d’une variable *v* est déterminé à chaque emplacement.</span><span class="sxs-lookup"><span data-stu-id="ce689-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="ce689-248">Règles générales pour les instructions</span><span class="sxs-lookup"><span data-stu-id="ce689-248">General rules for statements</span></span>

*  <span data-ttu-id="ce689-249">*v* n’est pas définitivement assignée au début du corps d’un membre de fonction.</span><span class="sxs-lookup"><span data-stu-id="ce689-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="ce689-250">*v* est définitivement assignée au début de n’importe quelle instruction inaccessible.</span><span class="sxs-lookup"><span data-stu-id="ce689-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="ce689-251">L’état d’assignation définie *v* au début de toute autre instruction est déterminée en vérifiant l’état d’assignation définie *v* sur tous les transferts de flux de contrôle qui ciblent le début de ce instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="ce689-252">Si (et seulement si) *v* est définitivement assignée sur tous ces transferts de flux de contrôle, puis *v* est définitivement assignée au début de l’instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="ce689-253">L’ensemble des transferts de flux de contrôle possibles est déterminé de la même façon que la vérification de l’accessibilité d’instruction ([points de terminaison et accessibilité](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="ce689-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="ce689-254">L’état d’assignation définie *v* au point de fin d’un bloc, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, ou `switch` est déterminé par la vérification de l’état d’assignation définie *v* sur tous les transferts de flux de contrôle qui ciblent le point de terminaison de cette instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="ce689-255">Si *v* est définitivement assignée sur tous ces transferts de flux de contrôle, puis *v* est définitivement assignée à la fin de l’instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="ce689-256">Sinon, *v* n’est pas définitivement assignée à la fin de l’instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="ce689-257">L’ensemble des transferts de flux de contrôle possibles est déterminé de la même façon que la vérification de l’accessibilité d’instruction ([points de terminaison et accessibilité](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="ce689-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="ce689-258">Instructions de bloc, activées et elle est désactivée</span><span class="sxs-lookup"><span data-stu-id="ce689-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="ce689-259">L’état d’assignation définie *v* sur le contrôle de transfert à la première instruction de la liste d’instructions dans le bloc (ou au point de terminaison du bloc, si la liste d’instructions est vide) est identique à l’instruction d’assignation définie de *v* avant le bloc, `checked`, ou `unchecked` instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="ce689-260">Instructions d’expression</span><span class="sxs-lookup"><span data-stu-id="ce689-260">Expression statements</span></span>

<span data-ttu-id="ce689-261">Pour une instruction d’expression *stmt* qui se compose de l’expression *expr*:</span><span class="sxs-lookup"><span data-stu-id="ce689-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="ce689-262">*v* a le même état d’assignation définie au début de *expr* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-263">Si *v* si définitivement assignée à la fin de *expr*, il est définitivement assignée à la fin de *stmt*; sinon, elle n’est pas définitivement assignée à la fin de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="ce689-264">Instructions de déclaration</span><span class="sxs-lookup"><span data-stu-id="ce689-264">Declaration statements</span></span>

*  <span data-ttu-id="ce689-265">Si *stmt* est une instruction de déclaration sans initialiseurs, puis *v* a le même état d’assignation définie à la fin de *stmt* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-266">Si *stmt* est une instruction de déclaration avec initialiseurs, puis l’état d’assignation définie pour *v* est déterminé comme si *stmt* ont été une liste d’instructions, avec une assignation instruction pour chaque déclaration avec un initialiseur (dans l’ordre de déclaration).</span><span class="sxs-lookup"><span data-stu-id="ce689-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="ce689-267">Si les instructions</span><span class="sxs-lookup"><span data-stu-id="ce689-267">If statements</span></span>

<span data-ttu-id="ce689-268">Pour un `if` instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="ce689-269">*v* a le même état d’assignation définie au début de *expr* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-270">Si *v* est définitivement assignée à la fin de *expr*, puis elle est définitivement assignée lors du transfert de flux de contrôle vers *then_stmt* et à *else_stmt*  ou au point de terminaison de *stmt* s’il n’existe aucune clause else.</span><span class="sxs-lookup"><span data-stu-id="ce689-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="ce689-271">Si *v* a l’état « définitivement assignée après une expression true » à la fin de *expr*, puis elle est définitivement assignée lors du transfert de flux de contrôle vers *then_stmt*et non définitivement assignée lors du transfert de flux de contrôle soit *else_stmt* ou au point de terminaison de *stmt* s’il n’existe aucune clause else.</span><span class="sxs-lookup"><span data-stu-id="ce689-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="ce689-272">Si *v* a l’état « définitivement assignée après une expression false » à la fin de *expr*, puis elle est définitivement assignée lors du transfert de flux de contrôle vers *else_stmt*et non définitivement assignée lors du transfert de flux de contrôle à *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="ce689-273">Il est définitivement assignée à la fin de *stmt* si et seulement si elle est définitivement assignée à la fin de *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="ce689-274">Sinon, *v* est considérée comme non assignée lors du transfert de flux de contrôle soit le *then_stmt* ou *else_stmt*, ou au point de terminaison de  *stmt* s’il n’existe aucune clause else.</span><span class="sxs-lookup"><span data-stu-id="ce689-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="ce689-275">Instructions switch</span><span class="sxs-lookup"><span data-stu-id="ce689-275">Switch statements</span></span>

<span data-ttu-id="ce689-276">Dans un `switch` instruction *stmt* avec une expression de contrôle *expr*:</span><span class="sxs-lookup"><span data-stu-id="ce689-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="ce689-277">L’état d’assignation définie *v* au début de *expr* est identique à l’état de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-278">L’état d’assignation définie *v* sur le flux de contrôle transfert vers une liste d’instructions de bloc switch accessible est identique à l’état d’assignation définie *v* à la fin de *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="ce689-279">Tandis que les instructions</span><span class="sxs-lookup"><span data-stu-id="ce689-279">While statements</span></span>

<span data-ttu-id="ce689-280">Pour un `while` instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="ce689-281">*v* a le même état d’assignation définie au début de *expr* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-282">Si *v* est définitivement assignée à la fin de *expr*, puis elle est définitivement assignée lors du transfert de flux de contrôle vers *while_body* et au point de terminaison de  *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="ce689-283">Si *v* a l’état « définitivement assignée après une expression true » à la fin de *expr*, puis elle est définitivement assignée lors du transfert de flux de contrôle vers *while_body*, mais pas définitivement assignée à la fin de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="ce689-284">Si *v* a l’état « définitivement assignée après une expression false » à la fin de *expr*, puis elle est définitivement assignée lors du transfert de flux de contrôle vers le point de terminaison de *stmt* , mais pas définitivement assignée lors du transfert de flux de contrôle à *while_body*.</span><span class="sxs-lookup"><span data-stu-id="ce689-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="ce689-285">Les instructions</span><span class="sxs-lookup"><span data-stu-id="ce689-285">Do statements</span></span>

<span data-ttu-id="ce689-286">Pour un `do` instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="ce689-287">*v* a le même état d’assignation définie lors du transfert de flux de contrôle à partir du début de *stmt* à *do_body* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-288">*v* a le même état d’assignation définie au début de *expr* au point de terminaison de *do_body*.</span><span class="sxs-lookup"><span data-stu-id="ce689-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="ce689-289">Si *v* est définitivement assignée à la fin de *expr*, puis elle est définitivement assignée lors du transfert de flux de contrôle vers le point de terminaison de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="ce689-290">Si *v* a l’état « définitivement assignée après une expression false » à la fin de *expr*, puis elle est définitivement assignée lors du transfert de flux de contrôle vers le point de terminaison de *stmt* .</span><span class="sxs-lookup"><span data-stu-id="ce689-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="ce689-291">Pour les instructions</span><span class="sxs-lookup"><span data-stu-id="ce689-291">For statements</span></span>

<span data-ttu-id="ce689-292">État d’assignation pour un `for` instruction du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="ce689-293">est effectué comme si l’instruction était écrite :</span><span class="sxs-lookup"><span data-stu-id="ce689-293">is done as if the statement were written:</span></span>
```csharp
{
for_initializer ;
while ( for_condition ) {
embedded_statement ;
for_iterator ;
}
}
```

<span data-ttu-id="ce689-294">Si le *for_condition* est omis à partir de la `for` instruction, puis d’évaluation de revenu de l’assignation définie comme si *for_condition* ont été remplacés par `true` dans l’expansion ci-dessus .</span><span class="sxs-lookup"><span data-stu-id="ce689-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="ce689-295">Interrompre, continuer et les instructions goto</span><span class="sxs-lookup"><span data-stu-id="ce689-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="ce689-296">L’état d’assignation définie *v* lors du transfert de flux de contrôle a provoqué par un `break`, `continue`, ou `goto` instruction est identique à l’état d’assignation définie *v* à la début de l’instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="ce689-297">Instructions throw</span><span class="sxs-lookup"><span data-stu-id="ce689-297">Throw statements</span></span>

<span data-ttu-id="ce689-298">Pour une instruction *stmt* du formulaire</span><span class="sxs-lookup"><span data-stu-id="ce689-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="ce689-299">L’état d’assignation définie *v* au début de *expr* est identique à l’état d’assignation définie *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="ce689-300">Instructions return</span><span class="sxs-lookup"><span data-stu-id="ce689-300">Return statements</span></span>

<span data-ttu-id="ce689-301">Pour une instruction *stmt* du formulaire</span><span class="sxs-lookup"><span data-stu-id="ce689-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="ce689-302">L’état d’assignation définie *v* au début de *expr* est identique à l’état d’assignation définie *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-303">Si *v* est un paramètre de sortie, puis il doit absolument être assigné soit :</span><span class="sxs-lookup"><span data-stu-id="ce689-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="ce689-304">une fois *expr*</span><span class="sxs-lookup"><span data-stu-id="ce689-304">after *expr*</span></span>
    * <span data-ttu-id="ce689-305">ou à la fin de la `finally` de blocs à un `try` - `finally` ou `try` - `catch` - `finally` qui englobe la `return` instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="ce689-306">Une instruction stmt a la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="ce689-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="ce689-307">Si *v* est un paramètre de sortie, puis il doit absolument être assigné soit :</span><span class="sxs-lookup"><span data-stu-id="ce689-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="ce689-308">avant de *stmt*</span><span class="sxs-lookup"><span data-stu-id="ce689-308">before *stmt*</span></span>
    * <span data-ttu-id="ce689-309">ou à la fin de la `finally` de blocs à un `try` - `finally` ou `try` - `catch` - `finally` qui englobe la `return` instruction.</span><span class="sxs-lookup"><span data-stu-id="ce689-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="ce689-310">Instructions try-catch</span><span class="sxs-lookup"><span data-stu-id="ce689-310">Try-catch statements</span></span>

<span data-ttu-id="ce689-311">Pour une instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="ce689-312">L’état d’assignation définie *v* au début de *try_block* est identique à l’état d’assignation définie *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-313">L’état d’assignation définie *v* au début de *catch_block_i* (pour tout *je*) est identique à l’état d’assignation définie *v*au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-314">L’état d’assignation définie *v* à la fin de *stmt* est sans aucun doute si (et seulement si) *v* est définitivement assignée à la fin de  *try_block* et chaque *catch_block_i* (pour chaque *je* comprise entre 1 et *n*).</span><span class="sxs-lookup"><span data-stu-id="ce689-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="ce689-315">Instructions try-finally</span><span class="sxs-lookup"><span data-stu-id="ce689-315">Try-finally statements</span></span>

<span data-ttu-id="ce689-316">Pour un `try` instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="ce689-317">L’état d’assignation définie *v* au début de *try_block* est identique à l’état d’assignation définie *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-318">L’état d’assignation définie *v* au début de *finally_block* est identique à l’état d’assignation définie *v* au début de *stmt* .</span><span class="sxs-lookup"><span data-stu-id="ce689-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-319">L’état d’assignation définie *v* à la fin de *stmt* est sans aucun doute si (et seulement si) au moins une des opérations suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="ce689-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="ce689-320">*v* est définitivement assignée à la fin de *try_block*</span><span class="sxs-lookup"><span data-stu-id="ce689-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="ce689-321">*v* est définitivement assignée à la fin de *finally_block*</span><span class="sxs-lookup"><span data-stu-id="ce689-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="ce689-322">Si un transfert de flux de contrôle (par exemple, un `goto` instruction) est effectuée en ce commence dans *try_block*et se termine en dehors de *try_block*, puis *v* est également considérés comme définitivement assignée sur ce transfert si *v* est définitivement assignée à la fin de *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="ce689-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="ce689-323">(Ce n’est pas un uniquement si — si *v* est définitivement assignée pour une autre raison sur ce transfert de flux de contrôle, il est toujours considéré comme définitivement assignée.)</span><span class="sxs-lookup"><span data-stu-id="ce689-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="ce689-324">Instructions try-catch-finally</span><span class="sxs-lookup"><span data-stu-id="ce689-324">Try-catch-finally statements</span></span>

<span data-ttu-id="ce689-325">L’analyse d’assignation pour un `try` - `catch` - `finally` instruction du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="ce689-326">est effectué comme si l’instruction ont été une `try` - `finally` instruction englobante un `try` - `catch` instruction :</span><span class="sxs-lookup"><span data-stu-id="ce689-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="ce689-327">L’exemple suivant montre comment les différents blocs d’un `try` instruction ([l’instruction try](statements.md#the-try-statement)) affectent une assignation.</span><span class="sxs-lookup"><span data-stu-id="ce689-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
static void F() {
int i, j;
try {
goto LABEL;
// neither i nor j definitely assigned
i = 1;
// i definitely assigned
}

catch {
// neither i nor j definitely assigned
i = 3;
// i definitely assigned
}

finally {
// neither i nor j definitely assigned
j = 5;
// j definitely assigned
}
// i and j definitely assigned
LABEL:;
// j definitely assigned

}
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="ce689-328">Instructions foreach</span><span class="sxs-lookup"><span data-stu-id="ce689-328">Foreach statements</span></span>

<span data-ttu-id="ce689-329">Pour un `foreach` instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="ce689-330">L’état d’assignation définie *v* au début de *expr* est identique à l’état de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-331">L’état d’assignation définie *v* lors du transfert de flux de contrôle à *embedded_statement* ou au point de terminaison de *stmt* est identique à l’état de *v* à la fin de *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="ce689-332">À l’aide d’instructions</span><span class="sxs-lookup"><span data-stu-id="ce689-332">Using statements</span></span>

<span data-ttu-id="ce689-333">Pour un `using` instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="ce689-334">L’état d’assignation définie *v* au début de *resource_acquisition* est identique à l’état de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-335">L’état d’assignation définie *v* lors du transfert de flux de contrôle à *embedded_statement* est identique à l’état de *v* à la fin de *resource_ acquisition*.</span><span class="sxs-lookup"><span data-stu-id="ce689-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="ce689-336">Instructions Lock</span><span class="sxs-lookup"><span data-stu-id="ce689-336">Lock statements</span></span>

<span data-ttu-id="ce689-337">Pour un `lock` instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="ce689-338">L’état d’assignation définie *v* au début de *expr* est identique à l’état de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-339">L’état d’assignation définie *v* lors du transfert de flux de contrôle à *embedded_statement* est identique à l’état de *v* à la fin de *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="ce689-340">Instructions yield</span><span class="sxs-lookup"><span data-stu-id="ce689-340">Yield statements</span></span>

<span data-ttu-id="ce689-341">Pour un `yield return` instruction *stmt* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="ce689-342">L’état d’assignation définie *v* au début de *expr* est identique à l’état de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="ce689-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="ce689-343">L’état d’assignation définie *v* à la fin de *stmt* est identique à l’état de *v* à la fin de *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="ce689-344">Un `yield break` instruction n’a aucun effet sur l’état d’assignation définie.</span><span class="sxs-lookup"><span data-stu-id="ce689-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="ce689-345">Règles générales pour les expressions simples</span><span class="sxs-lookup"><span data-stu-id="ce689-345">General rules for simple expressions</span></span>

<span data-ttu-id="ce689-346">La règle suivante s’applique à ces types d’expressions : littéraux ([littéraux](expressions.md#literals)), des noms simples ([noms simples](expressions.md#simple-names)), les expressions d’accès au membre ([l’accès au membre](expressions.md#member-access)), expressions d’accès de base non indexées ([accès de Base](expressions.md#base-access)), `typeof` expressions ([l’opérateur typeof](expressions.md#the-typeof-operator)), les expressions de valeur par défaut ([expressions de valeur par défaut ](expressions.md#default-value-expressions)) et `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="ce689-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="ce689-347">L’état d’assignation définie *v* à la fin d’une telle expression est identique à l’état d’assignation définie *v* au début de l’expression.</span><span class="sxs-lookup"><span data-stu-id="ce689-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="ce689-348">Règles générales pour les expressions avec des expressions incorporées</span><span class="sxs-lookup"><span data-stu-id="ce689-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="ce689-349">Les règles suivantes s’appliquent à ces types d’expressions : expressions entre parenthèses ([expressions entre parenthèses](expressions.md#parenthesized-expressions)), les expressions d’accès élément ([accès à un élément](expressions.md#element-access)), base accéder aux expressions avec l’indexation ([accès de Base](expressions.md#base-access)), incrémenter et décrémenter des expressions ([d’incrémentation et décrémentation opérateurs](expressions.md#postfix-increment-and-decrement-operators), [Incrément préfixé opérateurs et de décrémentation](expressions.md#prefix-increment-and-decrement-operators)), les expressions de cast ([les expressions de Cast](expressions.md#cast-expressions)), unaire `+`, `-`, `~`, `*` expressions, binaire `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([opérateurs arithmétiques](expressions.md#arithmetic-operators), [opérateurs de décalage](expressions.md#shift-operators), [relationnels et opérateurs de test de type](expressions.md#relational-and-type-testing-operators) [Opérateurs logiques](expressions.md#logical-operators)), composée d’expressions d’assignation ([assignation composée](expressions.md#compound-assignment)), `checked` et `unchecked` expressions ([checked et unchecked opérateurs](expressions.md#the-checked-and-unchecked-operators)), ainsi que les expressions de création de tableau et le délégué ([l’opérateur new](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="ce689-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="ce689-350">Chacune de ces expressions a un ou plusieurs sous-expressions qui sont évaluées de manière inconditionnelle dans un ordre fixe.</span><span class="sxs-lookup"><span data-stu-id="ce689-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="ce689-351">Par exemple, le fichier binaire `%` opérateur évalue la partie gauche de l’opérateur, puis la partie droite.</span><span class="sxs-lookup"><span data-stu-id="ce689-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="ce689-352">Une opération d’indexation évalue l’expression indexée, puis évalue chaque expression d’index, dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="ce689-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="ce689-353">Pour une expression *expr*, qui a des sous-expressions *e1, e2,..., eN*, évaluée dans cet ordre :</span><span class="sxs-lookup"><span data-stu-id="ce689-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="ce689-354">L’état d’assignation définie *v* au début de *e1* est identique à l’état d’assignation définie au début de *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="ce689-355">L’état d’assignation définie *v* au début de *ei* (*je* supérieure à 1) est le même que l’état d’assignation définie à la fin de la sous-expression précédente.</span><span class="sxs-lookup"><span data-stu-id="ce689-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="ce689-356">L’état d’assignation définie *v* à la fin de *expr* est identique à l’état d’assignation définie à la fin de *fr*</span><span class="sxs-lookup"><span data-stu-id="ce689-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="ce689-357">Expressions d’appel et les expressions de la création d’objet</span><span class="sxs-lookup"><span data-stu-id="ce689-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="ce689-358">Pour une expression d’appel *expr* du formulaire :</span><span class="sxs-lookup"><span data-stu-id="ce689-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="ce689-359">ou une expression de création d’objet sous la forme :</span><span class="sxs-lookup"><span data-stu-id="ce689-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="ce689-360">Pour une expression d’appel, l’état d’assignation définie *v* avant *primary_expression* est identique à l’état de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="ce689-361">Pour une expression d’appel, l’état d’assignation définie *v* avant *arg1* est identique à l’état de *v* après *primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="ce689-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="ce689-362">Pour une expression de création d’objet, l’état d’assignation définie *v* avant *arg1* est identique à l’état de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="ce689-363">Pour chaque argument *argi*, l’état d’assignation définie *v* après *argi* est déterminée par les règles de l’expression normale, en ignorant les `ref` ou `out`modificateurs.</span><span class="sxs-lookup"><span data-stu-id="ce689-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="ce689-364">Pour chaque argument *argi* pour toute *je* supérieur à un, l’état d’assignation définie *v* avant *argi* est identique à l’état de *v* après la précédente *arg*.</span><span class="sxs-lookup"><span data-stu-id="ce689-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="ce689-365">Si la variable *v* est passée comme un `out` argument (par exemple, un argument de la forme `out v`) dans un des arguments, puis l’état de *v* après *expr* est une assignation.</span><span class="sxs-lookup"><span data-stu-id="ce689-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="ce689-366">Sinon, l’état de *v* après *expr* est identique à l’état de *v* après *argN*.</span><span class="sxs-lookup"><span data-stu-id="ce689-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="ce689-367">Pour les initialiseurs de tableau ([expressions de création de tableau](expressions.md#array-creation-expressions)), initialiseurs d’objets ([initialiseurs d’objets](expressions.md#object-initializers)), les initialiseurs de collection ([initialiseurs de collections](expressions.md#collection-initializers)) et initialiseurs d’objet ([expressions de création d’objet anonyme](expressions.md#anonymous-object-creation-expressions)), l’état d’assignation définie est déterminé par l’expansion de ces constructions sont définies en termes de.</span><span class="sxs-lookup"><span data-stu-id="ce689-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="ce689-368">Expressions d’assignation simple</span><span class="sxs-lookup"><span data-stu-id="ce689-368">Simple assignment expressions</span></span>

<span data-ttu-id="ce689-369">Pour une expression *expr* du formulaire `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="ce689-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="ce689-370">L’état d’assignation définie *v* avant *expr_rhs* est identique à l’état d’assignation définie *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="ce689-371">L’état d’assignation définie *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="ce689-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="ce689-372">Si *w* est la même variable en tant que *v*, puis l’état d’assignation définie *v* après *expr* est définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="ce689-373">Sinon, si l’affectation se produit dans le constructeur d’instance d’un type struct, si *w* est un accès à la propriété qui désigne une propriété implémentée automatiquement *P* sur l’instance en cours de construction et *v* est le champ de stockage masqué de *P*, puis l’état d’assignation définie *v* après *expr* est sans aucun doute attribué.</span><span class="sxs-lookup"><span data-stu-id="ce689-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="ce689-374">Sinon, l’état d’assignation définie *v* après *expr* est identique à l’état d’assignation définie *v* après *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="ce689-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="ce689-375">& & (opérateur AND conditionnel) des expressions</span><span class="sxs-lookup"><span data-stu-id="ce689-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="ce689-376">Pour une expression *expr* du formulaire `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="ce689-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="ce689-377">L’état d’assignation définie *v* avant *expr_first* est identique à l’état d’assignation définie *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="ce689-378">L’état d’assignation définie *v* avant *expr_second* est définitivement assignée si l’état de *v* après *expr_first* est définitivement assignée ou « définitivement assignée après une expression true ».</span><span class="sxs-lookup"><span data-stu-id="ce689-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="ce689-379">Sinon, elle n’est pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="ce689-380">L’état d’assignation définie *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="ce689-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="ce689-381">Si *expr_first* est une expression constante ayant la valeur `false`, puis l’état d’assignation définie *v* après *expr* est identique à l’assignation définie état de *v* après *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="ce689-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="ce689-382">Sinon, si l’état de *v* après *expr_first* est définitivement assignée, puis l’état de *v* après *expr* est définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="ce689-383">Sinon, si l’état de *v* après *expr_second* est définitivement assignée et l’état de *v* après *expr_first* est « sans aucun doute affectés après une expression false », puis l’état de *v* après *expr* est définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="ce689-384">Sinon, si l’état de *v* après *expr_second* est définitivement assignée ou « définitivement assignée après une expression true », puis l’état de *v* après  *Expr* est « définitivement assignée après une expression true ».</span><span class="sxs-lookup"><span data-stu-id="ce689-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="ce689-385">Sinon, si l’état de *v* après *expr_first* est « définitivement assignée après une expression false » et l’état de *v* après *expr_second* est « définitivement assignée après une expression false », l’état de *v* après *expr* est « définitivement assignée après une expression false ».</span><span class="sxs-lookup"><span data-stu-id="ce689-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="ce689-386">Sinon, l’état de *v* après *expr* n’est pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="ce689-387">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="ce689-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="ce689-388">la variable `i` est considéré comme définitivement assignée dans une des instructions incorporées d’une `if` instruction, mais pas dans l’autre.</span><span class="sxs-lookup"><span data-stu-id="ce689-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="ce689-389">Dans le `if` instruction dans la méthode `F`, la variable `i` est définitivement assignée dans la première instruction incorporée, car l’exécution de l’expression `(i = y)` précède toujours l’exécution de cette instruction incorporée.</span><span class="sxs-lookup"><span data-stu-id="ce689-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="ce689-390">En revanche, la variable `i` n'est pas définitivement assignée dans la deuxième instruction incorporée, étant donné que `x >= 0` peut avoir été vérifié false, ce qui entraîne la variable `i` ne sont pas attribuées.</span><span class="sxs-lookup"><span data-stu-id="ce689-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="ce689-391">|| (opérateur OR conditionnel) des expressions</span><span class="sxs-lookup"><span data-stu-id="ce689-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="ce689-392">Pour une expression *expr* du formulaire `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="ce689-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="ce689-393">L’état d’assignation définie *v* avant *expr_first* est identique à l’état d’assignation définie *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="ce689-394">L’état d’assignation définie *v* avant *expr_second* est définitivement assignée si l’état de *v* après *expr_first* est définitivement assignée ou « définitivement assignée après une expression false ».</span><span class="sxs-lookup"><span data-stu-id="ce689-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="ce689-395">Sinon, elle n’est pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="ce689-396">L’instruction d’assignation définie de *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="ce689-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="ce689-397">Si *expr_first* est une expression constante ayant la valeur `true`, puis l’état d’assignation définie *v* après *expr* est identique à l’assignation définie état de *v* après *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="ce689-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="ce689-398">Sinon, si l’état de *v* après *expr_first* est définitivement assignée, puis l’état de *v* après *expr* est définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="ce689-399">Sinon, si l’état de *v* après *expr_second* est définitivement assignée et l’état de *v* après *expr_first* est « sans aucun doute affectés après une expression true », puis l’état de *v* après *expr* est définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="ce689-400">Sinon, si l’état de *v* après *expr_second* est définitivement assignée ou « définitivement assignée après une expression false », puis l’état de *v* après *expr* est « définitivement assignée après une expression false ».</span><span class="sxs-lookup"><span data-stu-id="ce689-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="ce689-401">Sinon, si l’état de *v* après *expr_first* est « définitivement assignée après une expression true » et l’état de *v* après *expr_second*est « définitivement assignée après une expression true », l’état de *v* après *expr* est « définitivement assignée après une expression true ».</span><span class="sxs-lookup"><span data-stu-id="ce689-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="ce689-402">Sinon, l’état de *v* après *expr* n’est pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="ce689-403">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="ce689-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="ce689-404">la variable `i` est considéré comme définitivement assignée dans une des instructions incorporées d’une `if` instruction, mais pas dans l’autre.</span><span class="sxs-lookup"><span data-stu-id="ce689-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="ce689-405">Dans le `if` instruction dans la méthode `G`, la variable `i` est définitivement assignée dans la deuxième instruction incorporée, car l’exécution de l’expression `(i = y)` précède toujours l’exécution de cette instruction incorporée.</span><span class="sxs-lookup"><span data-stu-id="ce689-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="ce689-406">En revanche, la variable `i` n'est pas définitivement assignée dans la première instruction incorporée, étant donné que `x >= 0` peut avoir été vérifié true, auquel cas la variable `i` ne sont pas attribuées.</span><span class="sxs-lookup"><span data-stu-id="ce689-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="ce689-407">!</span><span class="sxs-lookup"><span data-stu-id="ce689-407">!</span></span> <span data-ttu-id="ce689-408">expressions (négation logique)</span><span class="sxs-lookup"><span data-stu-id="ce689-408">(logical negation) expressions</span></span>

<span data-ttu-id="ce689-409">Pour une expression *expr* du formulaire `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="ce689-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="ce689-410">L’état d’assignation définie *v* avant *expr_operand* est identique à l’état d’assignation définie *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="ce689-411">L’état d’assignation définie *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="ce689-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="ce689-412">Si l’état de *v* après \* expr_operand \* est définitivement assignée, puis l’état de *v* après *expr* est définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="ce689-413">Si l’état de *v* après \* expr_operand \* n'est pas définitivement assignée, puis l’état de *v* après *expr* n’est pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="ce689-414">Si l’état de *v* après \* expr_operand \* est « définitivement assignée après une expression false », l’état de *v* après *expr* est « définitivement assignée après la valeur true expression ».</span><span class="sxs-lookup"><span data-stu-id="ce689-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="ce689-415">Si l’état de *v* après \* expr_operand \* est « définitivement assignée après une expression true », l’état de *v* après *expr* est « définitivement assignée après false expression ».</span><span class="sxs-lookup"><span data-stu-id="ce689-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="ce689-416">??</span><span class="sxs-lookup"><span data-stu-id="ce689-416">??</span></span> <span data-ttu-id="ce689-417">expressions (fusion de null)</span><span class="sxs-lookup"><span data-stu-id="ce689-417">(null coalescing) expressions</span></span>

<span data-ttu-id="ce689-418">Pour une expression *expr* du formulaire `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="ce689-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="ce689-419">L’état d’assignation définie *v* avant *expr_first* est identique à l’état d’assignation définie *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="ce689-420">L’état d’assignation définie *v* avant *expr_second* est identique à l’état d’assignation définie *v* après *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="ce689-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="ce689-421">L’instruction d’assignation définie de *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="ce689-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="ce689-422">Si *expr_first* est une expression constante ([expressions constantes](expressions.md#constant-expressions)) avec la valeur null, alors la l’état de *v* après *expr* est le même en tant que l’état de *v* après *expr_second*.</span><span class="sxs-lookup"><span data-stu-id="ce689-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="ce689-423">Sinon, l’état de *v* après *expr* est identique à l’état d’assignation définie *v* après *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="ce689-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="ce689-424">? : (conditionnelles) expressions</span><span class="sxs-lookup"><span data-stu-id="ce689-424">?: (conditional) expressions</span></span>

<span data-ttu-id="ce689-425">Pour une expression *expr* du formulaire `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="ce689-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="ce689-426">L’état d’assignation définie *v* avant *expr_cond* est identique à l’état de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="ce689-427">L’état d’assignation définie *v* avant *expr_true* est définitivement assignée si et seulement si une des opérations suivantes conserve :</span><span class="sxs-lookup"><span data-stu-id="ce689-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="ce689-428">*expr_cond* est une expression constante ayant la valeur `false`</span><span class="sxs-lookup"><span data-stu-id="ce689-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="ce689-429">l’état de *v* après *expr_cond* est définitivement assignée ou « définitivement assignée après une expression true ».</span><span class="sxs-lookup"><span data-stu-id="ce689-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="ce689-430">L’état d’assignation définie *v* avant *expr_false* est définitivement assignée si et seulement si une des opérations suivantes conserve :</span><span class="sxs-lookup"><span data-stu-id="ce689-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="ce689-431">*expr_cond* est une expression constante ayant la valeur `true`</span><span class="sxs-lookup"><span data-stu-id="ce689-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="ce689-432">l’état de *v* après *expr_cond* est définitivement assignée ou « définitivement assignée après une expression false ».</span><span class="sxs-lookup"><span data-stu-id="ce689-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="ce689-433">L’état d’assignation définie *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="ce689-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="ce689-434">Si *expr_cond* est une expression constante ([expressions constantes](expressions.md#constant-expressions)) avec la valeur `true` ensuite l’état de *v* après *expr* est le même que l’état de *v* après *expr_true*.</span><span class="sxs-lookup"><span data-stu-id="ce689-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="ce689-435">Sinon, si *expr_cond* est une expression constante ([expressions constantes](expressions.md#constant-expressions)) avec la valeur `false` ensuite l’état de *v* après *expr* est identique à l’état de *v* après *expr_false*.</span><span class="sxs-lookup"><span data-stu-id="ce689-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="ce689-436">Sinon, si l’état de *v* après *expr_true* est définitivement assigné et l’état de *v* après *expr_false* est sans aucun doute reçu, puis l’état de *v* après *expr* est définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="ce689-437">Sinon, l’état de *v* après *expr* n’est pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="ce689-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="ce689-438">Fonctions anonymes</span><span class="sxs-lookup"><span data-stu-id="ce689-438">Anonymous functions</span></span>

<span data-ttu-id="ce689-439">Pour un *lambda_expression* ou *anonymous_method_expression* *expr* avec un corps (soit *bloc* ou *expression* ) *corps*:</span><span class="sxs-lookup"><span data-stu-id="ce689-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="ce689-440">L’état d’assignation définie d’une variable externe *v* avant *corps* est identique à l’état de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="ce689-441">Autrement dit, état d’assignation définie des variables externes est hérité à partir du contexte de la fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="ce689-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="ce689-442">L’état d’assignation définie d’une variable externe *v* après *expr* est identique à l’état de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="ce689-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="ce689-443">L’exemple</span><span class="sxs-lookup"><span data-stu-id="ce689-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="ce689-444">génère une erreur de compilation depuis `max` n'est pas définitivement assignée où la fonction anonyme est déclarée.</span><span class="sxs-lookup"><span data-stu-id="ce689-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="ce689-445">L’exemple</span><span class="sxs-lookup"><span data-stu-id="ce689-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="ce689-446">génère également une erreur de compilation depuis l’assignation à `n` dans la fonction anonyme n’a aucun effet sur l’état d’assignation définie `n` en dehors de la fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="ce689-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="ce689-447">Références de variable</span><span class="sxs-lookup"><span data-stu-id="ce689-447">Variable references</span></span>

<span data-ttu-id="ce689-448">Un *variable_reference* est un *expression* qui est classé en tant que variable.</span><span class="sxs-lookup"><span data-stu-id="ce689-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="ce689-449">Un *variable_reference* désigne un emplacement de stockage qui est accessible à la fois pour extraire la valeur actuelle et pour stocker une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="ce689-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="ce689-450">En C et C++, un *variable_reference* est appelé un *lvalue*.</span><span class="sxs-lookup"><span data-stu-id="ce689-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="ce689-451">Atomicité des références de variable</span><span class="sxs-lookup"><span data-stu-id="ce689-451">Atomicity of variable references</span></span>

<span data-ttu-id="ce689-452">Lectures et écritures de types de données suivants sont atomiques : `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`et les types référence.</span><span class="sxs-lookup"><span data-stu-id="ce689-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="ce689-453">En outre, lectures et écritures de types enum avec un type sous-jacent de la liste précédente sont également atomiques.</span><span class="sxs-lookup"><span data-stu-id="ce689-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="ce689-454">Lit et écrit des autres types, y compris `long`, `ulong`, `double`, et `decimal`, ainsi que les types définis par l’utilisateur, n’est pas garanti pour être atomiques.</span><span class="sxs-lookup"><span data-stu-id="ce689-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="ce689-455">Outre les fonctions de bibliothèque conçues à cet effet, aucun des est garantie atomique en lecture-modification-écriture, comme dans le cas d’incrémentation ou de décrémentation.</span><span class="sxs-lookup"><span data-stu-id="ce689-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>

