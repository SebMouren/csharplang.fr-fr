---
ms.openlocfilehash: a01cf9387b8dc47de036bf0bd1496c19a441d81c
ms.sourcegitcommit: 7f7fc6e9e195e51b7ff8229aeaa70aa9fbbb63cb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/10/2019
ms.locfileid: "70876796"
---
# <a name="variables"></a><span data-ttu-id="0c7fc-101">Variables</span><span class="sxs-lookup"><span data-stu-id="0c7fc-101">Variables</span></span>

<span data-ttu-id="0c7fc-102">Les variables représentent des emplacements de stockage.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-102">Variables represent storage locations.</span></span> <span data-ttu-id="0c7fc-103">Chaque variable a un type qui détermine les valeurs qui peuvent être stockées dans la variable.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="0c7fc-104">C#est un langage de type sécurisé, et le C# compilateur garantit que les valeurs stockées dans les variables sont toujours du type approprié.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="0c7fc-105">La valeur d’une variable peut être modifiée par le biais de l’assignation ou `++` par `--` le biais de l’utilisation des opérateurs et.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="0c7fc-106">Une variable doit être ***assignée définitivement*** ([assignation définie](variables.md#definite-assignment)) avant que sa valeur puisse être obtenue.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="0c7fc-107">Comme décrit dans les sections suivantes, les variables sont ***initialement assignées*** ou ***initialement non assignées***.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="0c7fc-108">Une variable initialement assignée a une valeur initiale bien définie et est toujours considérée comme assignée définitivement.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="0c7fc-109">Une variable initialement non assignée n’a pas de valeur initiale.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="0c7fc-110">Pour qu’une variable initialement non assignée soit considérée comme définitivement assignée à un certain emplacement, une assignation à la variable doit se produire dans chaque chemin d’exécution possible menant à cet emplacement.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="0c7fc-111">Catégories de variables</span><span class="sxs-lookup"><span data-stu-id="0c7fc-111">Variable categories</span></span>

<span data-ttu-id="0c7fc-112">C#définit sept catégories de variables : les variables statiques, les variables d’instance, les éléments de tableau, les paramètres de valeur, les paramètres de référence, les paramètres de sortie et les variables locales.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="0c7fc-113">Les sections qui suivent décrivent chacune de ces catégories.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="0c7fc-114">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="0c7fc-114">In the example</span></span>
```csharp
class A
{
    public static int x;
    int y;

    void F(int[] v, int a, ref int b, out int c) {
        int i = 1;
        c = a + b++;
    }
}
```
<span data-ttu-id="0c7fc-115">`x`est une variable statique, `y` est une variable d’instance `v[0]` , est un élément de `a` tableau, est un paramètre `b` de valeur, est un `c` paramètre de référence, est un `i` paramètre de sortie et est une variable locale .</span><span class="sxs-lookup"><span data-stu-id="0c7fc-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="0c7fc-116">Variables statiques</span><span class="sxs-lookup"><span data-stu-id="0c7fc-116">Static variables</span></span>

<span data-ttu-id="0c7fc-117">Un champ déclaré avec le `static` modificateur est appelé une ***variable statique***.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="0c7fc-118">Une variable statique est entamée avant l’exécution du constructeur statique ([constructeurs statiques](classes.md#static-constructors)) pour son type conteneur et cesse d’exister lorsque le domaine d’application associé cesse d’exister.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="0c7fc-119">La valeur initiale d’une variable statique est la valeur par défaut ([valeurs par défaut](variables.md#default-values)) du type de la variable.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="0c7fc-120">À des fins de vérification de l’attribution définie, une variable statique est considérée comme initialement assignée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="0c7fc-121">Variables d’instance</span><span class="sxs-lookup"><span data-stu-id="0c7fc-121">Instance variables</span></span>

<span data-ttu-id="0c7fc-122">Un champ déclaré sans le `static` modificateur est appelé une ***variable d’instance***.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="0c7fc-123">Variables d’instance dans les classes</span><span class="sxs-lookup"><span data-stu-id="0c7fc-123">Instance variables in classes</span></span>

<span data-ttu-id="0c7fc-124">Une variable d’instance d’une classe intervient lorsqu’une nouvelle instance de cette classe est créée et cesse d’exister lorsqu’il n’existe aucune référence à cette instance et que le destructeur de l’instance (le cas échéant) a été exécuté.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="0c7fc-125">La valeur initiale d’une variable d’instance d’une classe est la valeur par défaut ([valeurs par défaut](variables.md#default-values)) du type de la variable.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="0c7fc-126">Dans le cadre de la vérification de l’assignation définie, une variable d’instance d’une classe est considérée comme initialement assignée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="0c7fc-127">Variables d’instance dans les structs</span><span class="sxs-lookup"><span data-stu-id="0c7fc-127">Instance variables in structs</span></span>

<span data-ttu-id="0c7fc-128">Une variable d’instance d’un struct a exactement la même durée de vie que la variable struct à laquelle elle appartient.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="0c7fc-129">En d’autres termes, lorsqu’une variable d’un type struct entre en existence ou cesse d’exister, il en est de même pour les variables d’instance du struct.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="0c7fc-130">L’état d’assignation initial d’une variable d’instance d’un struct est le même que celui de la variable de struct conteneur.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="0c7fc-131">En d’autres termes, lorsqu’une variable de struct est considérée comme initialement assignée, il s’agit également de ses variables d’instance, et lorsqu’une variable de struct est considérée comme initialement non assignée, ses variables d’instance ne sont pas assignées de la même façon.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="0c7fc-132">Éléments de tableau</span><span class="sxs-lookup"><span data-stu-id="0c7fc-132">Array elements</span></span>

<span data-ttu-id="0c7fc-133">Les éléments d’un tableau existent lorsqu’une instance de tableau est créée et cessent d’exister lorsqu’il n’existe aucune référence à cette instance de tableau.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="0c7fc-134">La valeur initiale de chacun des éléments d’un tableau est la valeur par défaut ([valeurs par défaut](variables.md#default-values)) du type des éléments du tableau.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="0c7fc-135">Dans le cadre de la vérification de l’assignation définie, un élément de tableau est considéré comme initialement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="0c7fc-136">Paramètres de valeur</span><span class="sxs-lookup"><span data-stu-id="0c7fc-136">Value parameters</span></span>

<span data-ttu-id="0c7fc-137">Un paramètre déclaré sans `ref` modificateur ou `out` est un paramètre de ***valeur***.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="0c7fc-138">Un paramètre de valeur intervient lors de l’appel de la fonction membre (méthode, constructeur d’instance, accesseur ou opérateur) ou de la fonction anonyme à laquelle le paramètre appartient, et est initialisée avec la valeur de l’argument fourni dans l’appel.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="0c7fc-139">Un paramètre de valeur cesse normalement d’exister lors du retour de la fonction membre ou de la fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="0c7fc-140">Toutefois, si le paramètre de valeur est capturé par une fonction anonyme ([expressions de fonction anonymes](expressions.md#anonymous-function-expressions)), sa durée de vie s’étend au moins jusqu’à ce que le délégué ou l’arborescence d’expression créé à partir de cette fonction anonyme soit éligible pour garbage collection.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="0c7fc-141">Dans le cadre de la vérification de l’attribution définie, un paramètre de valeur est considéré comme initialement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="0c7fc-142">Paramètres de référence</span><span class="sxs-lookup"><span data-stu-id="0c7fc-142">Reference parameters</span></span>

<span data-ttu-id="0c7fc-143">Un paramètre déclaré avec un `ref` modificateur est un ***paramètre de référence***.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="0c7fc-144">Un paramètre de référence ne crée pas un nouvel emplacement de stockage.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="0c7fc-145">Au lieu de cela, un paramètre de référence représente le même emplacement de stockage que la variable donnée comme argument dans le membre de fonction ou l’appel de fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="0c7fc-146">Ainsi, la valeur d’un paramètre de référence est toujours la même que la variable sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="0c7fc-147">Les règles d’assignation définie suivantes s’appliquent aux paramètres de référence.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="0c7fc-148">Notez les différentes règles pour les paramètres de sortie décrits dans [paramètres de sortie](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="0c7fc-149">Une variable doit être assignée de manière définitive ([assignation définie](variables.md#definite-assignment)) avant de pouvoir être passée en tant que paramètre de référence dans un membre de fonction ou un appel de délégué.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="0c7fc-150">Dans un membre de fonction ou une fonction anonyme, un paramètre de référence est considéré comme initialement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="0c7fc-151">Dans une méthode d’instance ou un accesseur d’instance d’un `this` type struct, le mot clé se comporte exactement comme un paramètre de référence du type struct ([cet accès](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="0c7fc-152">Paramètres de sortie</span><span class="sxs-lookup"><span data-stu-id="0c7fc-152">Output parameters</span></span>

<span data-ttu-id="0c7fc-153">Un paramètre déclaré avec un `out` modificateur est un ***paramètre de sortie***.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="0c7fc-154">Un paramètre de sortie ne crée pas un nouvel emplacement de stockage.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="0c7fc-155">Au lieu de cela, un paramètre de sortie représente le même emplacement de stockage que la variable donnée comme argument dans le membre de fonction ou l’appel de délégué.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="0c7fc-156">Ainsi, la valeur d’un paramètre de sortie est toujours la même que la variable sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="0c7fc-157">Les règles d’assignation définie suivantes s’appliquent aux paramètres de sortie.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="0c7fc-158">Notez les différentes règles pour les paramètres de référence décrites dans [paramètres de référence](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="0c7fc-159">Une variable n’a pas besoin d’être définitivement assignée avant de pouvoir être passée en tant que paramètre de sortie dans un membre de fonction ou un appel de délégué.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="0c7fc-160">Après l’achèvement normal d’un membre de fonction ou d’un appel de délégué, chaque variable qui a été passée comme paramètre de sortie est considérée comme affectée dans ce chemin d’exécution.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="0c7fc-161">Dans un membre de fonction ou une fonction anonyme, un paramètre de sortie est considéré comme initialement non assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="0c7fc-162">Chaque paramètre de sortie d’un membre de fonction ou d’une fonction anonyme doit être assignée définitivement ([assignation définie](variables.md#definite-assignment)) avant que la fonction membre ou la fonction anonyme retourne normalement.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="0c7fc-163">Dans un constructeur d’instance d’un type struct, `this` le mot clé se comporte exactement comme un paramètre de sortie du type struct ([cet accès](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="0c7fc-164">Variables locales</span><span class="sxs-lookup"><span data-stu-id="0c7fc-164">Local variables</span></span>

<span data-ttu-id="0c7fc-165">Une ***variable locale*** est déclarée par un *local_variable_declaration*, qui peut se produire dans un *bloc*, un *for_Statement*, un *switch_Statement* ou un *using_statement*; ou par un *foreach_statement* ou un *specific_catch_clause* pour un *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="0c7fc-166">La durée de vie d’une variable locale correspond à la partie de l’exécution du programme pendant laquelle le stockage est garanti comme étant réservé.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="0c7fc-167">Cette durée de vie étend au moins l’entrée dans le *bloc*, *for_Statement*, *switch_Statement*, *using_statement*, *foreach_statement*ou *specific_catch_clause* auquel elle est associée, jusqu’à ce que l’exécution de ce *bloc*, *for_Statement*, *switch_Statement*, *using_statement*, *foreach_statement*ou *specific_catch_clause* se termine de quelque manière que ce soit.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="0c7fc-168">(L’entrée d’un *bloc* délimité ou l’appel d’une méthode interrompt, mais ne termine pas, l’exécution du *bloc*en cours, *for_Statement*, *switch_Statement*, *using_statement*, *foreach_statement*ou *specific_ catch_clause*.) Si la variable locale est capturée par une fonction anonyme ([variables externes capturées](expressions.md#captured-outer-variables)), sa durée de vie s’étend au moins jusqu’à ce que le délégué ou l’arborescence de l’expression soit créée à partir de la fonction anonyme, avec tous les autres objets qui font référence à l’objet variable capturée, pouvant être garbage collection.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="0c7fc-169">Si le *bloc*parent, *for_Statement*, *switch_Statement*, *using_statement*, *foreach_statement*ou *specific_catch_clause* est entré de manière récursive, une nouvelle instance de la variable locale est créée chaque Time, et son *local_variable_initializer*, le cas échéant, est évalué à chaque fois.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="0c7fc-170">Une variable locale introduite par un *local_variable_declaration* n’est pas initialisée automatiquement et n’a donc pas de valeur par défaut.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="0c7fc-171">Dans le cadre de la vérification de l’attribution définie, une variable locale introduite par un *local_variable_declaration* est considérée comme initialement non assignée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="0c7fc-172">Un *local_variable_declaration* peut inclure un *local_variable_initializer*, auquel cas la variable est considérée comme définitivement assignée uniquement après l’expression d’initialisation ([instructions de déclaration](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="0c7fc-173">Dans l’étendue d’une variable locale introduite par un *local_variable_declaration*, il s’agit d’une erreur de compilation pour faire référence à cette variable locale dans une position textuelle qui précède son *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="0c7fc-174">Si la déclaration de variable locale est implicite ([déclarations de variables locales](statements.md#local-variable-declarations)), il s’agit également d’une erreur qui fait référence à la variable dans son *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="0c7fc-175">Une variable locale introduite par un *foreach_statement* ou un *specific_catch_clause* est considérée comme assignée de manière définitive dans sa portée entière.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="0c7fc-176">La durée de vie réelle d’une variable locale dépend de l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="0c7fc-177">Par exemple, un compilateur peut déterminer statiquement qu’une variable locale dans un bloc est utilisée uniquement pour une petite partie de ce bloc.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="0c7fc-178">À l’aide de cette analyse, le compilateur peut générer du code qui donne au stockage de la variable une durée de vie plus faible que le bloc qui le contient.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="0c7fc-179">Le stockage référencé par une variable de référence locale est récupéré indépendamment de la durée de vie de cette variable de référence locale ([gestion automatique](basic-concepts.md#automatic-memory-management)de la mémoire).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="0c7fc-180">Valeurs par défaut</span><span class="sxs-lookup"><span data-stu-id="0c7fc-180">Default values</span></span>

<span data-ttu-id="0c7fc-181">Les catégories de variables suivantes sont automatiquement initialisées à leurs valeurs par défaut :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="0c7fc-182">variables statiques</span><span class="sxs-lookup"><span data-stu-id="0c7fc-182">Static variables.</span></span>
*  <span data-ttu-id="0c7fc-183">Variables d’instance des instances de classe.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="0c7fc-184">Éléments du tableau.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-184">Array elements.</span></span>

<span data-ttu-id="0c7fc-185">La valeur par défaut d’une variable dépend du type de la variable et est déterminée comme suit :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="0c7fc-186">Pour une variable d’un *Value_type*, la valeur par défaut est la même que la valeur calculée par le constructeur par défaut de *Value_type*([constructeurs par défaut](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="0c7fc-187">Pour une variable d’un *reference_type*, la valeur par défaut `null`est.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="0c7fc-188">L’initialisation aux valeurs par défaut est généralement effectuée en faisant en sorte que le gestionnaire de mémoire ou le garbage collector initialise la mémoire à tous les bits-zéro avant qu’il ne soit alloué pour utilisation.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="0c7fc-189">Pour cette raison, il est pratique d’utiliser All-bits-Zero pour représenter la référence null.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="0c7fc-190">Assignation définie</span><span class="sxs-lookup"><span data-stu-id="0c7fc-190">Definite assignment</span></span>

<span data-ttu-id="0c7fc-191">À un emplacement donné dans le code exécutable d’un membre de fonction, une variable est dite ***assignée*** de manière définitive si le compilateur peut prouver, par une analyse de workflow statique particulière ([règles précises pour déterminer l’assignation définie](variables.md#precise-rules-for-determining-definite-assignment)), que la variable a été initialisé automatiquement ou a été la cible d’au moins une attribution.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="0c7fc-192">Comme indiqué de façon informelle, les règles d’attribution définie sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="0c7fc-193">Une variable initialement assignée ([variables initialement affectées](variables.md#initially-assigned-variables)) est toujours considérée comme assignée définitivement.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="0c7fc-194">Une variable initialement non assignée ([variables initialement non assignées](variables.md#initially-unassigned-variables)) est considérée comme définitivement assignée à un emplacement donné si tous les chemins d’exécution possibles conduisant à cet emplacement contiennent au moins l’un des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="0c7fc-195">Assignation simple ([assignation simple](expressions.md#simple-assignment)) dans laquelle la variable est l’opérande de gauche.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="0c7fc-196">Une expression d’appel ([expressions d’appel](expressions.md#invocation-expressions)) ou une expression de création d’objet ([expressions de création d’objet](expressions.md#object-creation-expressions)) qui passe la variable en tant que paramètre de sortie.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="0c7fc-197">Pour une variable locale, déclaration de variable locale ([déclarations de variable locale](statements.md#local-variable-declarations)) qui comprend un initialiseur de variable.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="0c7fc-198">La spécification formelle sous-jacente aux règles informelles ci-dessus est décrite dans [variables initialement attribuées](variables.md#initially-assigned-variables), [variables initialement non assignées](variables.md#initially-unassigned-variables)et [règles précises pour déterminer l’assignation définie](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="0c7fc-199">Les États d’assignation définie des variables d’instance d’une variable *struct_type* sont suivis individuellement et collectivement.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="0c7fc-200">Outre les règles ci-dessus, les règles suivantes s’appliquent aux variables *struct_type* et à leurs variables d’instance :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-200">In addition to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="0c7fc-201">Une variable d’instance est considérée comme assignée définitivement si sa variable *struct_type* conteneur est considérée comme assignée de manière définitive.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="0c7fc-202">Une variable *struct_type* est considérée comme assignée définitivement si chacune de ses variables d’instance est considérée comme assignée de manière définitive.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="0c7fc-203">L’assignation définie est une exigence dans les contextes suivants :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="0c7fc-204">Une variable doit être assignée de manière définitive à chaque emplacement où sa valeur est obtenue.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="0c7fc-205">Cela permet de s’assurer que les valeurs non définies ne se produisent jamais.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="0c7fc-206">L’occurrence d’une variable dans une expression est considérée pour obtenir la valeur de la variable, sauf lorsque</span><span class="sxs-lookup"><span data-stu-id="0c7fc-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="0c7fc-207">la variable est l’opérande gauche d’une assignation simple.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="0c7fc-208">la variable est transmise en tant que paramètre de sortie, ou</span><span class="sxs-lookup"><span data-stu-id="0c7fc-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="0c7fc-209">la variable est une variable *struct_type* et se produit comme opérande gauche d’un accès au membre.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="0c7fc-210">Une variable doit être assignée de manière définitive à chaque emplacement où elle est passée en tant que paramètre de référence.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="0c7fc-211">Cela garantit que le membre de fonction appelé peut prendre en compte le paramètre de référence initialement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="0c7fc-212">Tous les paramètres de sortie d’un membre de fonction doivent être assignés définitivement à chaque emplacement où le membre `return` de fonction retourne (via une instruction ou l’exécution atteint la fin du corps du membre de la fonction).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="0c7fc-213">Cela garantit que les fonctions membres ne retournent pas de valeurs non définies dans les paramètres de sortie, ce qui permet au compilateur de considérer un appel de membre de fonction qui prend une variable comme paramètre de sortie équivalent à une assignation à la variable.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="0c7fc-214">La `this` variable d’un constructeur d’instance *struct_type* doit être assignée de manière définitive à chaque emplacement que le constructeur d’instance retourne.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="0c7fc-215">Variables initialement attribuées</span><span class="sxs-lookup"><span data-stu-id="0c7fc-215">Initially assigned variables</span></span>

<span data-ttu-id="0c7fc-216">Les catégories de variables suivantes sont classées comme initialement attribuées :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="0c7fc-217">variables statiques</span><span class="sxs-lookup"><span data-stu-id="0c7fc-217">Static variables.</span></span>
*  <span data-ttu-id="0c7fc-218">Variables d’instance des instances de classe.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="0c7fc-219">Variables d’instance de variables de struct initialement attribuées.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="0c7fc-220">Éléments du tableau.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-220">Array elements.</span></span>
*  <span data-ttu-id="0c7fc-221">Paramètres de valeur.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-221">Value parameters.</span></span>
*  <span data-ttu-id="0c7fc-222">Paramètres de référence.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-222">Reference parameters.</span></span>
*  <span data-ttu-id="0c7fc-223">Variables déclarées dans `catch` une clause ou `foreach` une instruction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="0c7fc-224">Variables initialement non assignées</span><span class="sxs-lookup"><span data-stu-id="0c7fc-224">Initially unassigned variables</span></span>

<span data-ttu-id="0c7fc-225">Les catégories de variables suivantes sont classées comme étant initialement non assignées :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="0c7fc-226">Variables d’instance de variables de struct initialement non assignées.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="0c7fc-227">Paramètres de sortie, y `this` compris la variable des constructeurs d’instance de struct.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="0c7fc-228">Les variables locales, à l’exception de `catch` celles déclarées `foreach` dans une clause ou une instruction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="0c7fc-229">Règles précises pour déterminer l’assignation définie</span><span class="sxs-lookup"><span data-stu-id="0c7fc-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="0c7fc-230">Pour déterminer que chaque variable utilisée est assignée de manière définitive, le compilateur doit utiliser un processus qui est équivalent à celui décrit dans cette section.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="0c7fc-231">Le compilateur traite le corps de chaque membre de fonction qui a une ou plusieurs variables initialement non assignées.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="0c7fc-232">Pour chaque variable *v*non assignée initialement, le compilateur détermine un ***État d’assignation définie*** pour *v* à chacun des points suivants dans le membre de fonction :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="0c7fc-233">Au début de chaque instruction</span><span class="sxs-lookup"><span data-stu-id="0c7fc-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="0c7fc-234">Au point de terminaison ([points de terminaison et accessibilité](statements.md#end-points-and-reachability)) de chaque instruction</span><span class="sxs-lookup"><span data-stu-id="0c7fc-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="0c7fc-235">Sur chaque arc qui transfère le contrôle à une autre instruction ou jusqu’au point de terminaison d’une instruction</span><span class="sxs-lookup"><span data-stu-id="0c7fc-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="0c7fc-236">Au début de chaque expression</span><span class="sxs-lookup"><span data-stu-id="0c7fc-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="0c7fc-237">À la fin de chaque expression</span><span class="sxs-lookup"><span data-stu-id="0c7fc-237">At the end of each expression</span></span>

<span data-ttu-id="0c7fc-238">L’état d’assignation définie de *v* peut être :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="0c7fc-239">Assigné de manière définitive.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-239">Definitely assigned.</span></span> <span data-ttu-id="0c7fc-240">Cela indique qu’une valeur a été assignée à *v* pour tous les flux de contrôle possibles à ce stade.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="0c7fc-241">Pas définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-241">Not definitely assigned.</span></span> <span data-ttu-id="0c7fc-242">Pour l’état d’une variable à la fin d’une expression de type `bool`, l’état d’une variable qui n’est pas définitivement assignée peut (mais n’est pas nécessairement) appartenir à l’un des sous-États suivants :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="0c7fc-243">Assigné définitivement après une expression true.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="0c7fc-244">Cet état indique que *v* est définitivement affecté si l’expression booléenne est évaluée comme true, mais n’est pas nécessairement affectée si l’expression booléenne est évaluée comme false.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="0c7fc-245">Assigné définitivement après une expression false.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="0c7fc-246">Cet état indique que *v* est définitivement affecté si l’expression booléenne est évaluée comme false, mais n’est pas nécessairement affectée si l’expression booléenne est évaluée comme true.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="0c7fc-247">Les règles suivantes régissent la façon dont l’état d’une variable *v* est déterminé à chaque emplacement.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="0c7fc-248">Règles générales pour les instructions</span><span class="sxs-lookup"><span data-stu-id="0c7fc-248">General rules for statements</span></span>

*  <span data-ttu-id="0c7fc-249">*v* n’est pas définitivement assignée au début d’un corps de membre de fonction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="0c7fc-250">*v* est définitivement assignée au début de toute instruction inaccessible.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="0c7fc-251">L’état d’assignation définie de *v* au début d’une autre instruction est déterminé en vérifiant l’état d’assignation définie de *v* sur tous les transferts de workflow de contrôle qui ciblent le début de cette instruction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="0c7fc-252">Si (et seulement si) *v* est définitivement assigné sur tous les transferts de ce type de contrôle, *v* est définitivement assigné au début de l’instruction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="0c7fc-253">L’ensemble des transferts de workflow possibles est déterminé de la même façon que pour la vérification de l’accessibilité des instructions ([points de terminaison et accessibilité](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="0c7fc-254">État d’assignation définie de *v* au point de terminaison d’un bloc, `checked` `do`, `foreach` `unchecked` `if` `while`,,,, `for`,, `lock` `using`, ou `switch`l’instruction est déterminée en vérifiant l’état d’assignation définie de *v* sur tous les transferts de workflow de contrôle qui ciblent le point de terminaison de cette instruction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="0c7fc-255">Si *v* est définitivement assignée à tous les transferts de ce type de contrôle, *v* est définitivement assigné au point de terminaison de l’instruction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="0c7fc-256">Dispose *v* n’est pas définitivement assigné au point de terminaison de l’instruction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="0c7fc-257">L’ensemble des transferts de workflow possibles est déterminé de la même façon que pour la vérification de l’accessibilité des instructions ([points de terminaison et accessibilité](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="0c7fc-258">Instructions de bloc, instructions vérifiées et non vérifiées</span><span class="sxs-lookup"><span data-stu-id="0c7fc-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="0c7fc-259">L’état d’assignation définie de *v* sur le transfert de contrôle vers la première instruction de la liste d’instructions dans le bloc (ou jusqu’au point de terminaison du bloc, si la liste d’instructions est vide) est le même que l’instruction d’assignation définie de *v* avant le bloc instruction `checked`, ou `unchecked` .</span><span class="sxs-lookup"><span data-stu-id="0c7fc-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="0c7fc-260">Instructions d’expression</span><span class="sxs-lookup"><span data-stu-id="0c7fc-260">Expression statements</span></span>

<span data-ttu-id="0c7fc-261">Pour une instruction d’expression *stmt* qui se compose de l’expression *expr*:</span><span class="sxs-lookup"><span data-stu-id="0c7fc-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="0c7fc-262">*v* a le même état d’assignation définie au début de *expr* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-263">Si *v* est assignée de manière définitive à la fin de *expr*, elle est définitivement assignée au point de terminaison de *stmt*; dispose elle n’est pas définitivement assignée au point de terminaison de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="0c7fc-264">Instructions de déclaration</span><span class="sxs-lookup"><span data-stu-id="0c7fc-264">Declaration statements</span></span>

*  <span data-ttu-id="0c7fc-265">Si *stmt* est une instruction de déclaration sans initialiseurs, alors *v* a le même état d’assignation définie au point de terminaison de *stmt* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-266">Si *stmt* est une instruction de déclaration avec des initialiseurs, l’état d’assignation définie pour *v* est déterminé comme si *stmt* était une liste d’instructions, avec une instruction d’assignation pour chaque déclaration avec un initialiseur (dans l’ordre de déclaration).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="0c7fc-267">Instructions If</span><span class="sxs-lookup"><span data-stu-id="0c7fc-267">If statements</span></span>

<span data-ttu-id="0c7fc-268">Pour une `if` instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="0c7fc-269">*v* a le même état d’assignation définie au début de *expr* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-270">Si *v* est définitivement assignée à la fin de *expr*, il est définitivement assigné sur le transfert du workflow de contrôle à *then_stmt* et *else_stmt* ou sur le point de terminaison de *stmt* s’il n’y a aucune clause Else.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="0c7fc-271">Si *v* a l’état « définitivement assigné après une expression true » à la fin de *expr*, il est définitivement affecté sur le transfert du workflow de contrôle à *then_stmt*et n’est pas définitivement assigné sur le transfert de workflow à *else_ stmt* ou jusqu’au point de terminaison de *stmt* s’il n’y a aucune clause Else.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="0c7fc-272">Si *v* a l’état « définitivement assigné après une expression false » à la fin de *expr*, il est définitivement assigné sur le transfert du workflow de contrôle à *else_stmt*et n’est pas définitivement assigné sur le transfert du workflow de contrôle à *then_stmt* .</span><span class="sxs-lookup"><span data-stu-id="0c7fc-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="0c7fc-273">Elle est définitivement assignée au point de terminaison de *stmt* si et seulement si elle est définitivement assignée au point de terminaison de *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="0c7fc-274">Dans le cas contraire, *v* est considéré comme n’étant pas définitivement affecté sur le transfert du workflow de contrôle vers *then_stmt* ou *else_stmt*, ou vers le point de terminaison de *stmt* s’il n’y a aucune clause Else.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="0c7fc-275">Instructions Switch</span><span class="sxs-lookup"><span data-stu-id="0c7fc-275">Switch statements</span></span>

<span data-ttu-id="0c7fc-276">Dans une `switch` instruction *stmt* avec une expression de contrôle *expr*:</span><span class="sxs-lookup"><span data-stu-id="0c7fc-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="0c7fc-277">L’état d’assignation définie de *v* au début de *expr* est identique à l’état *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-278">L’état d’assignation définie de *v* sur le transfert du workflow de contrôle vers une liste d’instructions de bloc switch accessible est le même que l’état d’assignation définie de *v* à la fin de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="0c7fc-279">Instructions while</span><span class="sxs-lookup"><span data-stu-id="0c7fc-279">While statements</span></span>

<span data-ttu-id="0c7fc-280">Pour une `while` instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="0c7fc-281">*v* a le même état d’assignation définie au début de *expr* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-282">Si *v* est définitivement assignée à la fin de *expr*, il est définitivement affecté sur le transfert du workflow de contrôle à *while_body* et jusqu’au point de terminaison de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-283">Si *v* a l’état « définitivement assigné après une expression true » à la fin de *expr*, il est définitivement affecté au transfert du workflow de contrôle à *while_body*, mais il n’est pas définitivement assigné au point de terminaison de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-284">Si *v* a l’état « définitivement assigné après une expression false » à la fin de *expr*, il est définitivement affecté sur le transfert du workflow de contrôle au point de terminaison de *stmt*, mais pas définitivement assigné sur le transfert du workflow de contrôle à *quand _body*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="0c7fc-285">Instructions do</span><span class="sxs-lookup"><span data-stu-id="0c7fc-285">Do statements</span></span>

<span data-ttu-id="0c7fc-286">Pour une `do` instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="0c7fc-287">*v* a le même état d’assignation définie sur le transfert du workflow de contrôle entre le début de *stmt* et *do_body* qu’au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-288">*v* a le même état d’assignation définie au début de *expr* comme au point de terminaison de *do_body*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="0c7fc-289">Si *v* est définitivement assignée à la fin de *expr*, elle est définitivement assignée sur le transfert du workflow de contrôle vers le point de terminaison de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-290">Si *v* a l’état « définitivement assigné après une expression false » à la fin de *expr*, il est définitivement affecté sur le transfert du workflow de contrôle au point de terminaison de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="0c7fc-291">Pour les instructions</span><span class="sxs-lookup"><span data-stu-id="0c7fc-291">For statements</span></span>

<span data-ttu-id="0c7fc-292">Vérification de l’assignation définie pour `for` une instruction de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="0c7fc-293">est effectué comme si l’instruction était écrite :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-293">is done as if the statement were written:</span></span>
```csharp
{
    for_initializer ;
    while ( for_condition ) {
        embedded_statement ;
        for_iterator ;
    }
}
```

<span data-ttu-id="0c7fc-294">Si le *for_condition* est omis de l' `for` instruction, l’évaluation de l’assignation définie se poursuit comme si *for_condition* était remplacé par `true` dans l’expansion ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="0c7fc-295">Instructions break, continue et GOTO</span><span class="sxs-lookup"><span data-stu-id="0c7fc-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="0c7fc-296">L’état d’assignation définie de *v* sur le transfert de workflow de contrôle provoqué `break`par `continue`une instruction `goto` , ou est le même que l’état d’assignation définie de *v* au début de l’instruction.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="0c7fc-297">Instructions throw</span><span class="sxs-lookup"><span data-stu-id="0c7fc-297">Throw statements</span></span>

<span data-ttu-id="0c7fc-298">Pour une instruction *stmt* au format</span><span class="sxs-lookup"><span data-stu-id="0c7fc-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="0c7fc-299">L’état d’assignation définie de *v* au début de *expr* est le même que l’état d’assignation définie de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="0c7fc-300">Instructions Return</span><span class="sxs-lookup"><span data-stu-id="0c7fc-300">Return statements</span></span>

<span data-ttu-id="0c7fc-301">Pour une instruction *stmt* au format</span><span class="sxs-lookup"><span data-stu-id="0c7fc-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="0c7fc-302">L’état d’assignation définie de *v* au début de *expr* est le même que l’état d’assignation définie de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-303">Si *v* est un paramètre de sortie, il doit être affecté définitivement :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="0c7fc-304">après *expr*</span><span class="sxs-lookup"><span data-stu-id="0c7fc-304">after *expr*</span></span>
    * <span data-ttu-id="0c7fc-305">ou `finally` à la fin du bloc d’un `try` - ou`return` qui englobe l’instruction. `catch` `try` - `finally` - `finally`</span><span class="sxs-lookup"><span data-stu-id="0c7fc-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="0c7fc-306">Pour une instruction stmt de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="0c7fc-307">Si *v* est un paramètre de sortie, il doit être affecté définitivement :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="0c7fc-308">avant *stmt*</span><span class="sxs-lookup"><span data-stu-id="0c7fc-308">before *stmt*</span></span>
    * <span data-ttu-id="0c7fc-309">ou `finally` à la fin du bloc d’un `try` - ou`return` qui englobe l’instruction. `catch` `try` - `finally` - `finally`</span><span class="sxs-lookup"><span data-stu-id="0c7fc-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="0c7fc-310">Instructions Try-Catch</span><span class="sxs-lookup"><span data-stu-id="0c7fc-310">Try-catch statements</span></span>

<span data-ttu-id="0c7fc-311">Pour une instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="0c7fc-312">L’état d’assignation définie de *v* au début de *try_block* est identique à l’état d’assignation définie de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-313">L’état d’assignation définie de *v* au début de *catch_block_i* (pour Any *i*) est identique à l’état d’assignation définie de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-314">L’état d’assignation définie de *v* à l’extrémité de *stmt* est définitivement affecté si (et seulement si) *v* est définitivement assigné au point de terminaison de *try_block* et chaque *catch_block_i* (pour chaque *i* de 1 à *n* ).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="0c7fc-315">Instructions try-finally</span><span class="sxs-lookup"><span data-stu-id="0c7fc-315">Try-finally statements</span></span>

<span data-ttu-id="0c7fc-316">Pour une `try` instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="0c7fc-317">L’état d’assignation définie de *v* au début de *try_block* est identique à l’état d’assignation définie de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-318">L’état d’assignation définie de *v* au début de *finally_block* est identique à l’état d’assignation définie de *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-319">L’état d’assignation définie de *v* à l’extrémité de *stmt* est définitivement affecté si (et seulement si) au moins l’une des conditions suivantes est vraie :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="0c7fc-320">*v* est définitivement assignée au point de terminaison de *try_block*</span><span class="sxs-lookup"><span data-stu-id="0c7fc-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="0c7fc-321">*v* est définitivement assignée au point de terminaison de *finally_block*</span><span class="sxs-lookup"><span data-stu-id="0c7fc-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="0c7fc-322">Si un transfert de workflow de contrôle (par exemple `goto` , une instruction) commence dans *try_block*et se termine en dehors de *try_block*, *v* est également considéré comme définitivement assigné sur ce transfert de workflow si *v* est assigné de manière définitive au point de terminaison de *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="0c7fc-323">(Il ne s’agit pas d’un seul si, si *v* est définitivement affecté pour une autre raison sur ce transfert de workflow, il est toujours considéré comme définitivement affecté.)</span><span class="sxs-lookup"><span data-stu-id="0c7fc-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="0c7fc-324">Instructions try-catch-finally</span><span class="sxs-lookup"><span data-stu-id="0c7fc-324">Try-catch-finally statements</span></span>

<span data-ttu-id="0c7fc-325">Analyse d’assignation définie pour une `try` - `catch` - instruction delaforme:`finally`</span><span class="sxs-lookup"><span data-stu-id="0c7fc-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="0c7fc-326">est effectué comme si l’instruction était une `try` - `try` - `finally` instruction englobant une `catch` instruction :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
    try try_block
    catch(...) catch_block_1
    ...
    catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="0c7fc-327">L’exemple suivant montre comment les différents blocs d’une `try` instruction ([instruction try](statements.md#the-try-statement)) affectent l’assignation définie.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
    static void F() {
        int i, j;
        try {
            goto LABEL;
            // neither i nor j definitely assigned
            i = 1;
            // i definitely assigned
        }

        catch {
            // neither i nor j definitely assigned
            i = 3;
            // i definitely assigned
        }

        finally {
            // neither i nor j definitely assigned
            j = 5;
            // j definitely assigned
            }
        // i and j definitely assigned
        LABEL:;
        // j definitely assigned

    }
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="0c7fc-328">Instructions foreach</span><span class="sxs-lookup"><span data-stu-id="0c7fc-328">Foreach statements</span></span>

<span data-ttu-id="0c7fc-329">Pour une `foreach` instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="0c7fc-330">L’état d’assignation définie de *v* au début de *expr* est identique à l’état *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-331">L’état d’assignation définie de *v* sur le transfert du workflow de contrôle vers *embedded_statement* ou vers le point de terminaison de *stmt* est le même que l’état de *v* à la fin de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="0c7fc-332">Instructions using</span><span class="sxs-lookup"><span data-stu-id="0c7fc-332">Using statements</span></span>

<span data-ttu-id="0c7fc-333">Pour une `using` instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="0c7fc-334">L’état d’assignation définie de *v* au début de *resource_acquisition* est identique à l’état *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-335">L’état d’assignation définie de *v* sur le transfert du workflow de contrôle vers *embedded_statement* est identique à l’état *v* à la fin de *resource_acquisition*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="0c7fc-336">Instructions Lock</span><span class="sxs-lookup"><span data-stu-id="0c7fc-336">Lock statements</span></span>

<span data-ttu-id="0c7fc-337">Pour une `lock` instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="0c7fc-338">L’état d’assignation définie de *v* au début de *expr* est identique à l’état *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-339">L’état d’assignation définie de *v* sur le transfert du workflow de contrôle vers *embedded_statement* est identique à l’état *v* à la fin de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="0c7fc-340">Instructions yield</span><span class="sxs-lookup"><span data-stu-id="0c7fc-340">Yield statements</span></span>

<span data-ttu-id="0c7fc-341">Pour une `yield return` instruction *stmt* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="0c7fc-342">L’état d’assignation définie de *v* au début de *expr* est identique à l’état *v* au début de *stmt*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="0c7fc-343">L’état d’assignation définie de *v* à la fin de *stmt* est identique à l’état *v* à la fin de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="0c7fc-344">Une `yield break` instruction n’a aucun effet sur l’état d’assignation définie.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="0c7fc-345">Règles générales pour les expressions simples</span><span class="sxs-lookup"><span data-stu-id="0c7fc-345">General rules for simple expressions</span></span>

<span data-ttu-id="0c7fc-346">La règle suivante s’applique à ces types d’expressions : les littéraux ([littéraux](expressions.md#literals)), les noms simples ([noms simples](expressions.md#simple-names)), les expressions d’accès au membre ([accès aux membres](expressions.md#member-access)), les expressions d’accès de base non indexées ([accès de base](expressions.md#base-access)) `typeof`.expressions ([opérateur typeof](expressions.md#the-typeof-operator)), expressions de valeur par défaut ([expressions de valeur par défaut](expressions.md#default-value-expressions)) et `nameof` expressions ([expressions Nameof](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="0c7fc-347">L’état d’assignation définie de *v* à la fin d’une telle expression est le même que l’état d’assignation définie de *v* au début de l’expression.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="0c7fc-348">Règles générales pour les expressions avec des expressions incorporées</span><span class="sxs-lookup"><span data-stu-id="0c7fc-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="0c7fc-349">Les règles suivantes s’appliquent à ces types d’expressions : expressions entre parenthèses ([expressions entre parenthèses](expressions.md#parenthesized-expressions)), expressions d’accès aux éléments ([accès aux éléments](expressions.md#element-access)), expressions d’accès de base avec indexation ([accès de base](expressions.md#base-access)), incrémentation et expressions de décrémentation ([opérateurs d’incrémentation et de décrémentation suffixés](expressions.md#postfix-increment-and-decrement-operators), [opérateurs de préfixe d’incrémentation et de décrémentation](expressions.md#prefix-increment-and-decrement-operators)), `~`expressions de cast (expressions de[Cast](expressions.md#cast-expressions)), unaire `+` `-`,, `*`,expressions, Binary `+` `-` ,`*`,, ,`%`, ,`>>`,, ,,`>`, `<<` `<` `/` `<=` `>=` `==`, `!=`, ,`is`,, ,`^`expressions ([opérateurs arithmétiques](expressions.md#arithmetic-operators), [opérateurs de décalage](expressions.md#shift-operators), relationnel et test de type `|` `as` `&` [ opérateurs](expressions.md#relational-and-type-testing-operators), [opérateurs logiques](expressions.md#logical-operators)), expressions d’assignation composée ( `checked` [assignation composée](expressions.md#compound-assignment)) `unchecked` et expressions ([opérateurs activés et désactivés](expressions.md#the-checked-and-unchecked-operators)), plus un tableau et un délégué expressions de création ([opérateur New](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="0c7fc-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="0c7fc-350">Chacune de ces expressions a une ou plusieurs sous-expressions qui sont évaluées de manière non conditionnelle dans un ordre fixe.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="0c7fc-351">Par exemple, l’opérateur `%` binaire évalue le côté gauche de l’opérateur, puis le côté droit.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="0c7fc-352">Une opération d’indexation évalue l’expression indexée, puis évalue chacune des expressions d’index, dans l’ordre, de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="0c7fc-353">Pour une expression *expr*, qui contient des sous-expressions *E1, E2,...,* en, évaluées dans cet ordre :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="0c7fc-354">L’état d’assignation définie de *v* au début de *E1* est le même que l’état d’assignation définie au début de *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="0c7fc-355">L’état d’assignation définie de *v* au début de l' *AE* (*i* supérieur à un) est identique à l’état d’assignation définie à la fin de la sous-expression précédente.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="0c7fc-356">L’état d’assignation définie de *v* à la fin de *expr* est identique à l’état d’assignation définie à la *fin de la*</span><span class="sxs-lookup"><span data-stu-id="0c7fc-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="0c7fc-357">Expressions d’appel et expressions de création d’objet</span><span class="sxs-lookup"><span data-stu-id="0c7fc-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="0c7fc-358">Pour une expression d’appel *expr* de la forme :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="0c7fc-359">ou une expression de création d’objet de la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="0c7fc-360">Pour une expression d’appel, l’état d’assignation définie de *v* avant *primary_expression* est identique à l’état *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0c7fc-361">Pour une expression d’appel, l’état d’assignation définie de *v* avant *Arg1* est le même que l’état de *v* après *primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="0c7fc-362">Pour une expression de création d’objet, l’état d’assignation définie de *v* avant *Arg1* est le même que l’état de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0c7fc-363">Pour chaque argument *Argi*, l’état d’assignation définie de *v* après *Argi* est déterminé par les règles d’expression normales, en ignorant `ref` les `out` modificateurs ou.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="0c7fc-364">Pour chaque argument *Argi* pour un *i* supérieur à un, l’état d’assignation définie de *v* avant *Argi* est identique à l’état *v* après l' *argument précédent.*</span><span class="sxs-lookup"><span data-stu-id="0c7fc-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="0c7fc-365">Si la variable *v* est `out` passée comme argument (c’est-à-dire un argument du `out v`formulaire) dans l’un des arguments, l’état *v* après *expr* est définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="0c7fc-366">Dispose l’état de *v* après *expr* est identique à l’état *v* après *argN*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="0c7fc-367">Pour les initialiseurs de tableau ([expressions de création de tableau](expressions.md#array-creation-expressions)), les initialiseurs d’objets ([initialiseurs d’objets](expressions.md#object-initializers)), les initialiseurs de collection ([initialiseurs de collection](expressions.md#collection-initializers)) et les initialiseurs d’objets anonymes (création d'[objets anonymes expressions](expressions.md#anonymous-object-creation-expressions)), l’état d’assignation défini est déterminé par l’expansion que ces constructions sont définies en termes de.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="0c7fc-368">Expressions d’assignation simples</span><span class="sxs-lookup"><span data-stu-id="0c7fc-368">Simple assignment expressions</span></span>

<span data-ttu-id="0c7fc-369">Pour une expression *expr* de la forme `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="0c7fc-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="0c7fc-370">L’état d’assignation définie de *v* avant *expr_rhs* est identique à l’état d’assignation définie de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0c7fc-371">L’état d’assignation définie de *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="0c7fc-372">Si *w* est la même variable que *v*, l’état d’assignation définie de *v* après *expr* est définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="0c7fc-373">Sinon, si l’assignation se produit dans le constructeur d’instance d’un type struct, si *w* est un accès à la propriété désignant une propriété implémentée automatiquement *P* sur l’instance en cours de construction et que *v* est le champ de stockage masqué de *P*, puis l’état d’assignation définie de *v* après *expr* est définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="0c7fc-374">Dans le cas contraire, l’état d’assignation définie de *v* après *expr* est le même que l’état d’assignation définie de *v* après *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="0c7fc-375">& les expressions & (conditionnelles et)</span><span class="sxs-lookup"><span data-stu-id="0c7fc-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="0c7fc-376">Pour une expression *expr* de la forme `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="0c7fc-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="0c7fc-377">L’état d’assignation définie de *v* avant *expr_first* est identique à l’état d’assignation définie de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0c7fc-378">L’état d’assignation définie de *v* avant *expr_second* est définitivement assigné si l’état de *v* après *expr_first* est défini de manière définitive ou « définitivement assigné après l’expression true ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="0c7fc-379">Dans le cas contraire, elle n’est pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="0c7fc-380">L’état d’assignation définie de *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0c7fc-381">Si *expr_first* est une expression constante avec la valeur `false`, l’état d’assignation définie de *v* après *expr* est le même que l’état d’assignation définie de *v* après *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="0c7fc-382">Sinon, si l’état de *v* après *expr_first* est définitivement assigné, l’état *v* après *expr* est définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0c7fc-383">Sinon, si l’état de *v* après *expr_second* est assignée définitivement, et que l’état de *v* après *expr_first* est « définitivement assigné après false expression », alors l’état de *v* après *expr* est définitivement ont.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0c7fc-384">Dans le cas contraire, si l’état de *v* après *expr_second* est définitivement assigné ou « définitivement assigné après une expression true », l’état *v* après *expr* est « définitivement assigné après une expression true ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="0c7fc-385">Sinon, si l’état de *v* après *expr_first* est « définitivement assigné après une expression false » et que l’état de *v* après *expr_second* est « définitivement assigné après une expression false », alors l’état de *v* après  *Expr* est « définitivement assigné après false expression ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="0c7fc-386">Dans le cas contraire, l’état de *v* après *expr* n’est pas définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="0c7fc-387">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="0c7fc-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="0c7fc-388">la variable `i` est considérée comme définitivement assignée dans l’une des instructions `if` incorporées d’une instruction, mais pas dans l’autre.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="0c7fc-389">Dans l' `if` instruction de la `F`méthode, la `i` variable est définitivement assignée dans la première instruction incorporée, `(i = y)` car l’exécution de l’expression précède toujours l’exécution de cette instruction incorporée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="0c7fc-390">En revanche, la variable `i` n’est pas définitivement assignée dans la deuxième instruction `x >= 0` incorporée, car peut avoir testé false `i` , ce qui entraîne la non-attribution de la variable.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="0c7fc-391">|| expressions (conditionnelles ou)</span><span class="sxs-lookup"><span data-stu-id="0c7fc-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="0c7fc-392">Pour une expression *expr* de la forme `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="0c7fc-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="0c7fc-393">L’état d’assignation définie de *v* avant *expr_first* est identique à l’état d’assignation définie de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0c7fc-394">L’état d’assignation définie de *v* avant *expr_second* est définitivement assigné si l’état de *v* après *expr_first* est défini de manière définitive ou « définitivement assigné après une expression false ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="0c7fc-395">Dans le cas contraire, elle n’est pas définitivement assignée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="0c7fc-396">L’instruction d’assignation définie de *v* après *expr* est déterminée par :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0c7fc-397">Si *expr_first* est une expression constante avec la valeur `true`, l’état d’assignation définie de *v* après *expr* est le même que l’état d’assignation définie de *v* après *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="0c7fc-398">Sinon, si l’état de *v* après *expr_first* est définitivement assigné, l’état *v* après *expr* est définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0c7fc-399">Dans le cas contraire, si l’état de *v* après *expr_second* est assignée définitivement, et que l’état de *v* après *expr_first* est « définitivement assigné après true expression », alors l’état de *v* après *expr* est définitivement ont.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0c7fc-400">Sinon, si l’état de *v* après *expr_second* est définitivement assigné ou « définitivement assigné après false expression », alors l’état de *v* après *expr* est « définitivement assigné après une expression false ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="0c7fc-401">Sinon, si l’état de *v* après *expr_first* est « définitivement assigné après une expression true », et que l’état *v* après *expr_second* est « définitivement assigné après l’expression true », alors l’état de *v* après *expr* est « définitivement assigné après l’expression true ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="0c7fc-402">Dans le cas contraire, l’état de *v* après *expr* n’est pas définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="0c7fc-403">Dans l’exemple</span><span class="sxs-lookup"><span data-stu-id="0c7fc-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="0c7fc-404">la variable `i` est considérée comme définitivement assignée dans l’une des instructions `if` incorporées d’une instruction, mais pas dans l’autre.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="0c7fc-405">Dans l' `if` instruction de la `G`méthode, la `i` variable est définitivement assignée dans la deuxième instruction incorporée, `(i = y)` car l’exécution de l’expression précède toujours l’exécution de cette instruction incorporée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="0c7fc-406">En revanche, la variable `i` n’est pas définitivement assignée dans la première instruction `x >= 0` incorporée, car peut avoir testé la valeur `i` true, ce qui a pour effet que la variable n’est pas assignée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="0c7fc-407">!</span><span class="sxs-lookup"><span data-stu-id="0c7fc-407">!</span></span> <span data-ttu-id="0c7fc-408">expressions (négation logique)</span><span class="sxs-lookup"><span data-stu-id="0c7fc-408">(logical negation) expressions</span></span>

<span data-ttu-id="0c7fc-409">Pour une expression *expr* de la forme `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="0c7fc-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="0c7fc-410">L’état d’assignation définie de *v* avant *expr_operand* est identique à l’état d’assignation définie de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0c7fc-411">L’état d’assignation définie de *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0c7fc-412">Si l’état *v* après \* expr_operand \* est définitivement affecté, l’état *v* après *expr* est définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0c7fc-413">Si l’état de *v* après \* expr_operand \* n’est pas définitivement assigné, l’état de *v* après *expr* n’est pas définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="0c7fc-414">Si l’état *v* après \* expr_operand \* est « définitivement assigné après une expression false », alors l’état de *v* après *expr* est « définitivement assigné après l’expression true ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="0c7fc-415">Si l’état de *v* après \* expr_operand \* est « définitivement assigné après l’expression true », alors l’état de *v* après *expr* est « définitivement assigné après une expression false ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="0c7fc-416">??</span><span class="sxs-lookup"><span data-stu-id="0c7fc-416">??</span></span> <span data-ttu-id="0c7fc-417">expressions (fusion de valeurs null)</span><span class="sxs-lookup"><span data-stu-id="0c7fc-417">(null coalescing) expressions</span></span>

<span data-ttu-id="0c7fc-418">Pour une expression *expr* de la forme `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="0c7fc-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="0c7fc-419">L’état d’assignation définie de *v* avant *expr_first* est identique à l’état d’assignation définie de *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0c7fc-420">L’état d’assignation définie de *v* avant *expr_second* est identique à l’état d’assignation définie de *v* après *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="0c7fc-421">L’instruction d’assignation définie de *v* après *expr* est déterminée par :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0c7fc-422">Si *expr_first* est une expression constante ([expressions constantes](expressions.md#constant-expressions)) avec la valeur null, l’état de *v* après *expr* est identique à l’état *v* après *expr_second*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="0c7fc-423">Dans le cas contraire, l’état de *v* après *expr* est le même que l’état d’assignation définie de *v* après *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="0c7fc-424">?: (conditionnel), expressions</span><span class="sxs-lookup"><span data-stu-id="0c7fc-424">?: (conditional) expressions</span></span>

<span data-ttu-id="0c7fc-425">Pour une expression *expr* de la forme `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="0c7fc-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="0c7fc-426">L’état d’assignation définie de *v* avant *expr_cond* est identique à l’état *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="0c7fc-427">L’état d’assignation définie de *v* avant *expr_true* est définitivement affecté si et seulement si l’un des éléments suivants est présent :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="0c7fc-428">*expr_cond* est une expression constante avec la valeur`false`</span><span class="sxs-lookup"><span data-stu-id="0c7fc-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="0c7fc-429">État de *v* après que *expr_cond* a été assigné définitivement ou « définitivement assigné après l’expression true ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="0c7fc-430">L’état d’assignation définie de *v* avant *expr_false* est définitivement affecté si et seulement si l’un des éléments suivants est présent :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="0c7fc-431">*expr_cond* est une expression constante avec la valeur`true`</span><span class="sxs-lookup"><span data-stu-id="0c7fc-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="0c7fc-432">État de *v* après que *expr_cond* a été assigné définitivement ou « définitivement assigné après une expression false ».</span><span class="sxs-lookup"><span data-stu-id="0c7fc-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="0c7fc-433">L’état d’assignation définie de *v* après *expr* est déterminé par :</span><span class="sxs-lookup"><span data-stu-id="0c7fc-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="0c7fc-434">Si *expr_cond* est une expression constante ([expressions constantes](expressions.md#constant-expressions)) avec `true` la valeur, l’état de *v* après *expr* est identique à l’état *v* après *expr_true*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="0c7fc-435">Sinon, si *expr_cond* est une expression constante ([expressions constantes](expressions.md#constant-expressions)) avec `false` la valeur, l’état de *v* après *expr* est identique à l’état *v* après *expr_false*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="0c7fc-436">Sinon, si l’état de *v* après *expr_true* est assignée définitivement et que l’état de *v* après l’assignation définitive de *expr_false* , l’état *v* après *expr* est définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="0c7fc-437">Dans le cas contraire, l’état de *v* après *expr* n’est pas définitivement assigné.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="0c7fc-438">Fonctions anonymes</span><span class="sxs-lookup"><span data-stu-id="0c7fc-438">Anonymous functions</span></span>

<span data-ttu-id="0c7fc-439">Pour un *expr* *lambda_expression* ou *anonymous_method_expression* avec un corps (de type *bloc* ou expression *) :*</span><span class="sxs-lookup"><span data-stu-id="0c7fc-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="0c7fc-440">L’état d’assignation définie d’une variable externe *v* avant le *corps* est identique à l’état *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="0c7fc-441">Autrement dit, l’état d’assignation définie des variables externes est hérité du contexte de la fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="0c7fc-442">L’état d’assignation définie d’une variable externe *v* après *expr* est identique à l’état *v* avant *expr*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="0c7fc-443">L’exemple</span><span class="sxs-lookup"><span data-stu-id="0c7fc-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="0c7fc-444">génère une erreur au moment de la `max` compilation, car n’est pas définitivement assignée où la fonction anonyme est déclarée.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="0c7fc-445">L’exemple</span><span class="sxs-lookup"><span data-stu-id="0c7fc-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="0c7fc-446">génère également une erreur au moment de la compilation, car `n` l’assignation à dans la fonction anonyme n’a aucun effet sur l’état `n` d’assignation définie de l’extérieur de la fonction anonyme.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="0c7fc-447">Références de variables</span><span class="sxs-lookup"><span data-stu-id="0c7fc-447">Variable references</span></span>

<span data-ttu-id="0c7fc-448">Un *variable_reference* est une *expression* classée en tant que variable.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="0c7fc-449">Un *variable_reference* désigne un emplacement de stockage qui est accessible à la fois pour extraire la valeur actuelle et pour stocker une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="0c7fc-450">En C et C++, un *variable_reference* est appelé *lvalue*.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="0c7fc-451">Atomicité des références de variable</span><span class="sxs-lookup"><span data-stu-id="0c7fc-451">Atomicity of variable references</span></span>

<span data-ttu-id="0c7fc-452">Les lectures et les écritures des types de données suivants sont `bool`des `char`types de référence Atomic : `uint`, `int`, `float` `short` `byte` `sbyte`,,, `ushort`,,, et.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="0c7fc-453">En outre, les lectures et écritures de types ENUM avec un type sous-jacent dans la liste précédente sont également atomiques.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="0c7fc-454">Les lectures et écritures d’autres types, `long`notamment `ulong` `double`,,, `decimal`et, ainsi que les types définis par l’utilisateur, ne sont pas nécessairement atomiques.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="0c7fc-455">Outre les fonctions de bibliothèque conçues à cet effet, il n’existe aucune garantie de lecture-modification/écriture atomique, comme dans le cas de l’incrémentation ou de la décrémentation.</span><span class="sxs-lookup"><span data-stu-id="0c7fc-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>

