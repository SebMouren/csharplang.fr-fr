---
ms.openlocfilehash: ecdad8c863d0695bc901e4d96d9ca3decbc248eb
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/25/2019
ms.locfileid: "79484614"
---
# <a name="nullable-reference-types-in-c"></a><span data-ttu-id="bc2a5-101">Types référence Nullable dansC#</span><span class="sxs-lookup"><span data-stu-id="bc2a5-101">Nullable reference types in C#</span></span> #

<span data-ttu-id="bc2a5-102">L’objectif de cette fonctionnalité est de :</span><span class="sxs-lookup"><span data-stu-id="bc2a5-102">The goal of this feature is to:</span></span>

* <span data-ttu-id="bc2a5-103">Permet aux développeurs d’exprimer si une variable, un paramètre ou un résultat d’un type référence est destiné à être null ou non.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-103">Allow developers to express whether a variable, parameter or result of a reference type is intended to be null or not.</span></span>
* <span data-ttu-id="bc2a5-104">Fournissez des avertissements lorsque ces variables, paramètres et résultats ne sont pas utilisés conformément à cet objectif.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-104">Provide warnings when such variables, parameters and results are not used according to that intent.</span></span>

## <a name="expression-of-intent"></a><span data-ttu-id="bc2a5-105">Expression de l’intention</span><span class="sxs-lookup"><span data-stu-id="bc2a5-105">Expression of intent</span></span>

<span data-ttu-id="bc2a5-106">La langue contient déjà la syntaxe `T?` pour les types valeur.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-106">The language already contains the `T?` syntax for value types.</span></span> <span data-ttu-id="bc2a5-107">Il est facile d’étendre cette syntaxe aux types référence.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-107">It is straightforward to extend this syntax to reference types.</span></span>

<span data-ttu-id="bc2a5-108">Il est supposé que l’objectif d’un type de référence sans ornement `T` est qu’il doit être non null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-108">It is assumed that the intent of an unadorned reference type `T` is for it to be non-null.</span></span>

## <a name="checking-of-nullable-references"></a><span data-ttu-id="bc2a5-109">Vérification des références Nullable</span><span class="sxs-lookup"><span data-stu-id="bc2a5-109">Checking of nullable references</span></span>

<span data-ttu-id="bc2a5-110">Une analyse de fluide effectue le suivi des variables de référence Nullable.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-110">A flow analysis tracks nullable reference variables.</span></span> <span data-ttu-id="bc2a5-111">Lorsque l’analyse estime qu’elles ne sont pas nulles (par exemple, après une vérification ou une affectation), leur valeur est considérée comme une référence non null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-111">Where the analysis deems that they would not be null (e.g. after a check or an assignment), their value will be considered a non-null reference.</span></span>

<span data-ttu-id="bc2a5-112">Une référence Nullable peut également être traitée explicitement comme non null avec l’opérateur de suffixe `x!` (opérateur « Dammit »), lorsque l’analyse du workflow ne peut pas établir une situation non null que le développeur connaît.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-112">A nullable reference can also explicitly be treated as non-null with the postfix `x!` operator (the "dammit" operator), for when flow analysis cannot establish a non-null situation that the developer knows is there.</span></span>

<span data-ttu-id="bc2a5-113">Dans le cas contraire, un avertissement est fourni si une référence Nullable est déréférencée ou est convertie en un type non null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-113">Otherwise, a warning is given if a nullable reference is dereferenced, or is converted to a non-null type.</span></span>

<span data-ttu-id="bc2a5-114">Un avertissement est fourni lors de la conversion de `S[]` en `T?[]` et de `S?[]` à `T[]`.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-114">A warning is given when converting from `S[]` to `T?[]` and from `S?[]` to `T[]`.</span></span>

<span data-ttu-id="bc2a5-115">Un avertissement est fourni lors de la conversion de `C<S>` en `C<T?>` sauf lorsque le paramètre de type est covariant (`out`), et lors de la conversion de `C<S?>` en `C<T>`, sauf lorsque le paramètre de type est contravariant (`in`).</span><span class="sxs-lookup"><span data-stu-id="bc2a5-115">A warning is given when converting from `C<S>` to `C<T?>` except when the type parameter is covariant (`out`), and when converting from `C<S?>` to `C<T>` except when the type parameter is contravariant (`in`).</span></span>

<span data-ttu-id="bc2a5-116">Un avertissement est fourni sur `C<T?>` si le paramètre de type a des contraintes non null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-116">A warning is given on `C<T?>` if the type parameter has non-null constraints.</span></span> 

## <a name="checking-of-non-null-references"></a><span data-ttu-id="bc2a5-117">Vérification des références non null</span><span class="sxs-lookup"><span data-stu-id="bc2a5-117">Checking of non-null references</span></span>

<span data-ttu-id="bc2a5-118">Un avertissement est fourni si un littéral null est assigné à une variable non null ou passé comme paramètre non null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-118">A warning is given if a null literal is assigned to a non-null variable or passed as a non-null parameter.</span></span>

<span data-ttu-id="bc2a5-119">Un avertissement est également fourni si un constructeur n’initialise pas explicitement les champs de référence non null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-119">A warning is also given if a constructor does not explicitly initialize non-null reference fields.</span></span>

<span data-ttu-id="bc2a5-120">Nous ne pouvons pas suivre correctement l’initialisation de tous les éléments d’un tableau de références non null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-120">We cannot adequately track that all elements of an array of non-null references are initialized.</span></span> <span data-ttu-id="bc2a5-121">Toutefois, nous pouvons émettre un avertissement si aucun élément d’un tableau nouvellement créé n’est assigné avant que le tableau soit lu ou passé.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-121">However, we could issue a warning if no element of a newly created array is assigned to before the array is read from or passed on.</span></span> <span data-ttu-id="bc2a5-122">Cela peut gérer le cas courant sans trop bruyant.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-122">That might handle the common case without being too noisy.</span></span>

<span data-ttu-id="bc2a5-123">Nous devons décider si `default(T)` génère un avertissement ou si elle est simplement traitée comme étant du type `T?`.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-123">We need to decide whether `default(T)` generates a warning, or is simply treated as being of the type `T?`.</span></span>

## <a name="metadata-representation"></a><span data-ttu-id="bc2a5-124">Représentation des métadonnées</span><span class="sxs-lookup"><span data-stu-id="bc2a5-124">Metadata representation</span></span>

<span data-ttu-id="bc2a5-125">Les ornements de possibilité de valeur NULL doivent être représentés dans les métadonnées en tant qu’attributs.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-125">Nullability adornments should be represented in metadata as attributes.</span></span> <span data-ttu-id="bc2a5-126">Cela signifie que les compilateurs de niveau inférieur les ignorent.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-126">This means that downlevel compilers will ignore them.</span></span>

<span data-ttu-id="bc2a5-127">Nous devons décider si seules les annotations Nullable sont incluses, ou il existe également une indication précisant si la valeur non null était « on » dans l’assembly.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-127">We need to decide if only nullable annotations are included, or there's also some indication of whether non-null was "on" in the assembly.</span></span>

## <a name="generics"></a><span data-ttu-id="bc2a5-128">Génériques</span><span class="sxs-lookup"><span data-stu-id="bc2a5-128">Generics</span></span>

<span data-ttu-id="bc2a5-129">Si un paramètre de type `T` a des contraintes n’acceptant pas les valeurs NULL, il est traité comme n’acceptant pas les valeurs NULL dans sa portée.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-129">If a type parameter `T` has non-nullable constraints, it is treated as non-nullable within its scope.</span></span>

<span data-ttu-id="bc2a5-130">Si un paramètre de type est sans contrainte ou n’a que des contraintes Nullable, la situation est un peu plus complexe : cela signifie que l’argument de type correspondant peut avoir la *valeur* null ou n’accepte pas les valeurs NULL.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-130">If a type parameter is unconstrained or has only nullable constraints, the situation is a little more complex: this means that the corresponding type argument could be *either* nullable or non-nullable.</span></span> <span data-ttu-id="bc2a5-131">La seule chose à faire dans cette situation est de traiter le paramètre de type comme Nullable et non Nullable, en donnant *des* avertissements quand l’un ou l’autre est violé.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-131">The safe thing to do in that situation is to treat the type parameter as *both* nullable and non-nullable, giving warnings when either is violated.</span></span> 

<span data-ttu-id="bc2a5-132">Il est important de considérer si les contraintes de référence Nullable explicites doivent être autorisées.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-132">It is worth considering whether explicit nullable reference constraints should be allowed.</span></span> <span data-ttu-id="bc2a5-133">Notez, toutefois, que nous ne pouvons pas éviter que les types de référence Nullable soient *implicitement* des contraintes dans certains cas (contraintes héritées).</span><span class="sxs-lookup"><span data-stu-id="bc2a5-133">Note, however, that we cannot avoid having nullable reference types *implicitly* be constraints in certain cases (inherited constraints).</span></span>

<span data-ttu-id="bc2a5-134">La contrainte de `class` est non null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-134">The `class` constraint is non-null.</span></span> <span data-ttu-id="bc2a5-135">Nous pouvons déterminer si `class?` doit être une contrainte Nullable valide qui désigne « type de référence Nullable ».</span><span class="sxs-lookup"><span data-stu-id="bc2a5-135">We can consider whether `class?` should be a valid nullable constraint denoting "nullable reference type".</span></span>

## <a name="type-inference"></a><span data-ttu-id="bc2a5-136">Inférence de type</span><span class="sxs-lookup"><span data-stu-id="bc2a5-136">Type inference</span></span>

<span data-ttu-id="bc2a5-137">Dans l’inférence de type, si un type contributeur est un type référence Nullable, le type résultant doit être Nullable.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-137">In type inference, if a contributing type is a nullable reference type, the resulting type should be nullable.</span></span> <span data-ttu-id="bc2a5-138">En d’autres termes, la valeur null est propagée.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-138">In other words, nullness is propagated.</span></span>

<span data-ttu-id="bc2a5-139">Nous devons déterminer si le littéral `null` en tant qu’expression participante doit contribuer à la valeur null.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-139">We should consider whether the `null` literal as a participating expression should contribute nullness.</span></span> <span data-ttu-id="bc2a5-140">Ce n’est pas aujourd’hui le cas : pour les types de valeur, il génère une erreur, tandis que pour les types de référence, la valeur null est convertie avec succès en type brut.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-140">It doesn't today: for value types it leads to an error, whereas for reference types the null successfully converts to the plain type.</span></span> 

```csharp
string? n = "world";
var x = b ? "Hello" : n; // string?
var y = b ? "Hello" : null; // string? or error
var z = b ? 7 : null; // Error today, could be int?
```

## <a name="breaking-changes"></a><span data-ttu-id="bc2a5-141">Changements cassants</span><span class="sxs-lookup"><span data-stu-id="bc2a5-141">Breaking changes</span></span>

<span data-ttu-id="bc2a5-142">Les avertissements non NULL sont une modification avec rupture évidente sur le code existant et doivent être accompagnés d’un mécanisme d’abonnement.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-142">Non-null warnings are an obvious breaking change on existing code, and should be accompanied with an opt-in mechanism.</span></span>

<span data-ttu-id="bc2a5-143">Moins évidemment, les avertissements des types Nullable (comme décrit ci-dessus) sont une modification avec rupture sur le code existant dans certains scénarios où la possibilité de valeur null est implicite :</span><span class="sxs-lookup"><span data-stu-id="bc2a5-143">Less obviously, warnings from nullable types (as described above) are a breaking change on existing code in certain scenarios where the nullability is implicit:</span></span>

* <span data-ttu-id="bc2a5-144">Les paramètres de type sans contrainte sont traités comme des valeurs NULL implicites, de sorte que leur affectation à `object` ou l’accès à, par exemple, `ToString` généreront des avertissements.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-144">Unconstrained type parameters will be treated as implicitly nullable, so assigning them to `object` or accessing e.g. `ToString` will yield warnings.</span></span>
* <span data-ttu-id="bc2a5-145">Si l’inférence de type déduit la valeur null des expressions `null`, le code existant peut parfois générer des valeurs NULL plutôt que des types non Nullable, ce qui peut entraîner de nouveaux avertissements.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-145">if type inference infers nullness from `null` expressions, then existing code will sometimes yield nullable rather than non-nullable types, which can lead to new warnings.</span></span>

<span data-ttu-id="bc2a5-146">Les avertissements Nullable doivent également être facultatifs</span><span class="sxs-lookup"><span data-stu-id="bc2a5-146">So nullable warnings also need to be optional</span></span>

<span data-ttu-id="bc2a5-147">Enfin, l’ajout d’annotations à une API existante sera une modification avec rupture pour les utilisateurs qui ont opté pour les avertissements lorsqu’ils effectuent la mise à niveau de la bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-147">Finally, adding annotations to an existing API will be a breaking change to users who have opted in to warnings, when they upgrade the library.</span></span> <span data-ttu-id="bc2a5-148">Cela vous permet également d’accepter ou de refuser l’inscription. « Je veux les correctifs de bogues, mais je ne suis pas prêt à gérer leurs nouvelles annotations »</span><span class="sxs-lookup"><span data-stu-id="bc2a5-148">This, too, merits the ability to opt in or out. "I want the bug fixes, but I am not ready to deal with their new annotations"</span></span>

<span data-ttu-id="bc2a5-149">En résumé, vous devez être en mesure d’accepter/de refuser :</span><span class="sxs-lookup"><span data-stu-id="bc2a5-149">In summary, you need to be able to opt in/out of:</span></span>
* <span data-ttu-id="bc2a5-150">Avertissements Nullable</span><span class="sxs-lookup"><span data-stu-id="bc2a5-150">Nullable warnings</span></span>
* <span data-ttu-id="bc2a5-151">Avertissements non null</span><span class="sxs-lookup"><span data-stu-id="bc2a5-151">Non-null warnings</span></span>
* <span data-ttu-id="bc2a5-152">Avertissements d’annotations dans d’autres fichiers</span><span class="sxs-lookup"><span data-stu-id="bc2a5-152">Warnings from annotations in other files</span></span>

<span data-ttu-id="bc2a5-153">La granularité de l’abonnement suggère un modèle de type analyseur, où les quantités de code peuvent s’inscrire et sortir avec des pragmas et des niveaux de gravité peuvent être choisis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-153">The granularity of the opt-in suggests an analyzer-like model, where swaths of code can opt in and out with pragmas and severity levels can be chosen by the user.</span></span> <span data-ttu-id="bc2a5-154">En outre, les options par bibliothèque (« ignorer les annotations de JSON.NET jusqu’à ce que je suis prêt à gérer le passage ») peuvent être exprimables dans le code en tant qu’attributs.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-154">Additionally, per-library options ("ignore the annotations from JSON.NET until I'm ready to deal with the fall out") may be expressible in code as attributes.</span></span>

<span data-ttu-id="bc2a5-155">La conception de l’expérience d’abonnement/transition est cruciale pour la réussite et l’utilité de cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-155">The design of the opt-in/transition experience is crucial to the success and usefulness of this feature.</span></span> <span data-ttu-id="bc2a5-156">Nous devons nous assurer que :</span><span class="sxs-lookup"><span data-stu-id="bc2a5-156">We need to make sure that:</span></span>

* <span data-ttu-id="bc2a5-157">Les utilisateurs peuvent adopter une vérification de la possibilité de valeur NULL comme ils le souhaitent</span><span class="sxs-lookup"><span data-stu-id="bc2a5-157">Users can adopt nullability checking gradually as they want to</span></span>
* <span data-ttu-id="bc2a5-158">Les auteurs de bibliothèques peuvent ajouter des annotations de possibilité de valeur null sans craindre de perturber les clients</span><span class="sxs-lookup"><span data-stu-id="bc2a5-158">Library authors can add nullability annotations without fear of breaking customers</span></span>
* <span data-ttu-id="bc2a5-159">En dépit de ceux-ci, il n’y a pas de sens de « cauchemar de la configuration »</span><span class="sxs-lookup"><span data-stu-id="bc2a5-159">Despite these, there is not a sense of "configuration nightmare"</span></span>

## <a name="tweaks"></a><span data-ttu-id="bc2a5-160">Ajustements</span><span class="sxs-lookup"><span data-stu-id="bc2a5-160">Tweaks</span></span>

<span data-ttu-id="bc2a5-161">Nous pourrions envisager de ne pas utiliser les annotations `?` sur les variables locales, mais simplement d’observer s’ils sont utilisés conformément à ce qui leur est assigné.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-161">We could consider not using the `?` annotations on locals, but just observing whether they are used in accordance with what gets assigned to them.</span></span> <span data-ttu-id="bc2a5-162">Je ne préfère pas cela. Je pense que nous devrions permettre aux utilisateurs d’exprimer leur intention de manière uniforme.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-162">I don't favor this; I think we should uniformly let people express their intent.</span></span>

<span data-ttu-id="bc2a5-163">Nous pourrions envisager une `T! x` abrégée sur les paramètres, qui génère automatiquement une vérification de la valeur null au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-163">We could consider a shorthand `T! x` on parameters, that auto-generates a runtime null check.</span></span>

<span data-ttu-id="bc2a5-164">Certains modèles sur des types génériques, tels que `FirstOrDefault` ou `TryGet`, ont un comportement légèrement étrange avec les arguments de type non Nullable, car ils génèrent explicitement des valeurs par défaut dans certaines situations.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-164">Certain patterns on generic types, such as `FirstOrDefault` or `TryGet`, have slightly weird behavior with non-nullable type arguments, because they explicitly yield default values in certain situations.</span></span> <span data-ttu-id="bc2a5-165">Nous pourrions essayer de nuancer le système de type pour s’adapter à ces améliorations.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-165">We could try to nuance the type system to accommodate these better.</span></span> <span data-ttu-id="bc2a5-166">Par exemple, nous pourrions autoriser `?` sur des paramètres de type sans contrainte, même si l’argument de type peut déjà être Nullable.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-166">For instance, we could allow `?` on unconstrained type parameters, even though the type argument could already be nullable.</span></span> <span data-ttu-id="bc2a5-167">Je n’ai pas de doute qu’il en mérite, et cela a pour conséquence l’étrange liée à l’interaction avec les types *valeur* Nullable.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-167">I doubt that it is worth it, and it leads to weirdness related to interaction with nullable *value* types.</span></span> 

## <a name="nullable-value-types"></a><span data-ttu-id="bc2a5-168">Types valeur Nullable</span><span class="sxs-lookup"><span data-stu-id="bc2a5-168">Nullable value types</span></span>

<span data-ttu-id="bc2a5-169">Nous pourrions envisager d’adopter également une partie de la sémantique ci-dessus pour les types valeur Nullable.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-169">We could consider adopting some of the above semantics for nullable value types as well.</span></span>

<span data-ttu-id="bc2a5-170">Nous avons déjà mentionné l’inférence de type, où nous pourrions déduire `int?` à partir de `(7, null)`, au lieu de donner simplement une erreur.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-170">We already mentioned type inference, where we could infer `int?` from `(7, null)`, instead of just giving an error.</span></span>

<span data-ttu-id="bc2a5-171">Une autre possibilité consiste à appliquer l’analyse du workflow à des types valeur Nullable.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-171">Another opportunity is to apply the flow analysis to nullable value types.</span></span> <span data-ttu-id="bc2a5-172">Lorsqu’ils sont considérés comme non null, nous pourrions réellement autoriser l’utilisation de comme type non Nullable de certaines façons (par exemple, l’accès aux membres).</span><span class="sxs-lookup"><span data-stu-id="bc2a5-172">When they are deemed non-null, we could actually allow using as the non-nullable type in certain ways (e.g. member access).</span></span> <span data-ttu-id="bc2a5-173">Nous devons simplement veiller à ce que les choses que vous puissiez *déjà* faire sur un type de valeur Nullable soient préférées, pour des raisons de compatibilité de retour.</span><span class="sxs-lookup"><span data-stu-id="bc2a5-173">We just have to be careful that the things that you can *already* do on a nullable value type will be preferred, for back compat reasons.</span></span>
