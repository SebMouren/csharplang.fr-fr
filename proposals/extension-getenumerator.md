---
ms.openlocfilehash: a774e370a14373ccf308c2cba9944305c0053c05
ms.sourcegitcommit: aa2ff4d18a54d3999b7d014fcae38b2435e15510
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/18/2020
ms.locfileid: "84978645"
---
# <a name="extension-getenumerator-support-for-foreach-loops"></a><span data-ttu-id="7ffb7-101">`GetEnumerator`Prise en charge des extensions pour les `foreach` boucles.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-101">Extension `GetEnumerator` support for `foreach` loops.</span></span>

## <a name="summary"></a><span data-ttu-id="7ffb7-102">Résumé</span><span class="sxs-lookup"><span data-stu-id="7ffb7-102">Summary</span></span>
[summary]: #summary

<span data-ttu-id="7ffb7-103">Autoriser les boucles Foreach à reconnaître une méthode d’extension GetEnumerator qui, sinon, répond au modèle foreach, et effectue une boucle sur l’expression lorsqu’il s’agit d’une erreur.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-103">Allow foreach loops to recognize an extension method GetEnumerator method that otherwise satisfies the foreach pattern, and loop over the expression when it would otherwise be an error.</span></span>

## <a name="motivation"></a><span data-ttu-id="7ffb7-104">Motivation</span><span class="sxs-lookup"><span data-stu-id="7ffb7-104">Motivation</span></span>
[motivation]: #motivation

<span data-ttu-id="7ffb7-105">Foreach sera incorporé avec la manière dont les autres fonctionnalités en C# sont implémentées, notamment Async et la déconstruction basée sur des modèles.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-105">This will bring foreach inline with how other features in C# are implemented, including async and pattern-based deconstruction.</span></span>

## <a name="detailed-design"></a><span data-ttu-id="7ffb7-106">Conception détaillée</span><span class="sxs-lookup"><span data-stu-id="7ffb7-106">Detailed design</span></span>
[design]: #detailed-design

<span data-ttu-id="7ffb7-107">La modification des spécifications est relativement simple.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-107">The spec change is relatively straightforward.</span></span> <span data-ttu-id="7ffb7-108">Nous modifions `The foreach statement` la section à ce texte :</span><span class="sxs-lookup"><span data-stu-id="7ffb7-108">We modify `The foreach statement` section to this text:</span></span>

><span data-ttu-id="7ffb7-109">Le traitement au moment de la compilation d’une instruction foreach détermine d’abord le type de ***collection***, le type d' ***énumérateur*** et le ***type d’élément*** de l’expression.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-109">The compile-time processing of a foreach statement first determines the ***collection type***, ***enumerator type*** and ***element type*** of the expression.</span></span> <span data-ttu-id="7ffb7-110">Cette détermination se déroule comme suit :</span><span class="sxs-lookup"><span data-stu-id="7ffb7-110">This determination proceeds as follows:</span></span>
>
>*  <span data-ttu-id="7ffb7-111">Si le type `X` d' *expression* est un type tableau, il existe une conversion de référence implicite de `X` en `IEnumerable` interface (puisque `System.Array` implémente cette interface).</span><span class="sxs-lookup"><span data-stu-id="7ffb7-111">If the type `X` of *expression* is an array type then there is an implicit reference conversion from `X` to the `IEnumerable` interface (since `System.Array` implements this interface).</span></span> <span data-ttu-id="7ffb7-112">Le ***type de collection*** est l' `IEnumerable` interface, le ***type d’énumérateur*** est l' `IEnumerator` interface et le ***type d’élément*** est le type d’élément du type tableau `X` .</span><span class="sxs-lookup"><span data-stu-id="7ffb7-112">The ***collection type*** is the `IEnumerable` interface, the ***enumerator type*** is the `IEnumerator` interface and the ***element type*** is the element type of the array type `X`.</span></span>
>*  <span data-ttu-id="7ffb7-113">Si le type `X` d' *expression* est `dynamic` , il y a une conversion implicite d' *expression* en `IEnumerable` interface ([conversions dynamiques implicites](conversions.md#implicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="7ffb7-113">If the type `X` of *expression* is `dynamic` then there is an implicit conversion from *expression* to the `IEnumerable` interface ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions)).</span></span> <span data-ttu-id="7ffb7-114">Le ***type de collection*** est l' `IEnumerable` interface et le ***type d’énumérateur*** est l' `IEnumerator` interface.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-114">The ***collection type*** is the `IEnumerable` interface and the ***enumerator type*** is the `IEnumerator` interface.</span></span> <span data-ttu-id="7ffb7-115">Si l' `var` identificateur est donné comme *local_variable_type* , le type d' ***élément*** est `dynamic` , sinon, `object` .</span><span class="sxs-lookup"><span data-stu-id="7ffb7-115">If the `var` identifier is given as the *local_variable_type* then the ***element type*** is `dynamic`, otherwise it is `object`.</span></span>
>*  <span data-ttu-id="7ffb7-116">Sinon, déterminez si le type `X` a une `GetEnumerator` méthode appropriée :</span><span class="sxs-lookup"><span data-stu-id="7ffb7-116">Otherwise, determine whether the type `X` has an appropriate `GetEnumerator` method:</span></span>
>    * <span data-ttu-id="7ffb7-117">Effectuez une recherche de membre sur le type `X` avec l’identificateur `GetEnumerator` et aucun argument de type.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-117">Perform member lookup on the type `X` with identifier `GetEnumerator` and no type arguments.</span></span> <span data-ttu-id="7ffb7-118">Si la recherche de membre ne produit pas de correspondance, si elle génère une ambiguïté ou si elle produit une correspondance qui n’est pas un groupe de méthodes, recherchez une interface énumérable comme décrit ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-118">If the member lookup does not produce a match, or it produces an ambiguity, or produces a match that is not a method group, check for an enumerable interface as described below.</span></span> <span data-ttu-id="7ffb7-119">Il est recommandé d’émettre un avertissement si la recherche de membres produit tout sauf un groupe de méthodes ou aucune correspondance.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-119">It is recommended that a warning be issued if member lookup produces anything except a method group or no match.</span></span>
>    * <span data-ttu-id="7ffb7-120">Exécutez la résolution de surcharge à l’aide du groupe de méthodes résultant et d’une liste d’arguments vide.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-120">Perform overload resolution using the resulting method group and an empty argument list.</span></span> <span data-ttu-id="7ffb7-121">Si la résolution de surcharge entraîne l’absence de méthodes applicables, provoque une ambiguïté ou produit une seule meilleure méthode, mais que cette méthode est statique ou non publique, recherchez une interface énumérable comme décrit ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-121">If overload resolution results in no applicable methods, results in an ambiguity, or results in a single best method but that method is either static or not public, check for an enumerable interface as described below.</span></span> <span data-ttu-id="7ffb7-122">Il est recommandé d’émettre un avertissement si la résolution de surcharge produit tout sauf une méthode d’instance publique non ambiguë ou aucune méthode applicable.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-122">It is recommended that a warning be issued if overload resolution produces anything except an unambiguous public instance method or no applicable methods.</span></span>
>    * <span data-ttu-id="7ffb7-123">Si le type `E` de retour de la `GetEnumerator` méthode n’est pas un type de classe, de struct ou d’interface, une erreur est générée et aucune autre étape n’est prise.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-123">If the return type `E` of the `GetEnumerator` method is not a class, struct or interface type, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-124">La recherche de membres est effectuée sur `E` avec l’identificateur `Current` et aucun argument de type.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-124">Member lookup is performed on `E` with the identifier `Current` and no type arguments.</span></span> <span data-ttu-id="7ffb7-125">Si la recherche de membre ne produit aucune correspondance, le résultat est une erreur, ou le résultat est tout sauf une propriété d’instance publique qui autorise la lecture, une erreur est générée et aucune autre étape n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-125">If the member lookup produces no match, the result is an error, or the result is anything except a public instance property that permits reading, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-126">La recherche de membres est effectuée sur `E` avec l’identificateur `MoveNext` et aucun argument de type.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-126">Member lookup is performed on `E` with the identifier `MoveNext` and no type arguments.</span></span> <span data-ttu-id="7ffb7-127">Si la recherche de membre ne produit aucune correspondance, le résultat est une erreur, ou le résultat est tout sauf un groupe de méthodes, une erreur est générée et aucune autre étape n’est prise.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-127">If the member lookup produces no match, the result is an error, or the result is anything except a method group, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-128">La résolution de surcharge est effectuée sur le groupe de méthodes avec une liste d’arguments vide.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-128">Overload resolution is performed on the method group with an empty argument list.</span></span> <span data-ttu-id="7ffb7-129">Si la résolution de surcharge entraîne l’absence de méthodes applicables, entraîne une ambiguïté ou produit une seule meilleure méthode, mais cette méthode est statique ou non publique, ou son type de retour n’est pas `bool` , une erreur est générée et aucune autre étape n’est prise.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-129">If overload resolution results in no applicable methods, results in an ambiguity, or results in a single best method but that method is either static or not public, or its return type is not `bool`, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-130">Le ***type de collection*** est `X` , le ***type d’énumérateur*** est `E` , et le type d' ***élément*** est le type de la `Current` propriété.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-130">The ***collection type*** is `X`, the ***enumerator type*** is `E`, and the ***element type*** is the type of the `Current` property.</span></span>
>
>*  <span data-ttu-id="7ffb7-131">Sinon, recherchez une interface énumérable :</span><span class="sxs-lookup"><span data-stu-id="7ffb7-131">Otherwise, check for an enumerable interface:</span></span>
>    * <span data-ttu-id="7ffb7-132">Si parmi tous les types `Ti` pour lesquels il existe une conversion implicite de `X` en `IEnumerable<Ti>` , il existe un type unique `T` , qui `T` n’est pas `dynamic` et pour tout l’autre, `Ti` il existe une conversion implicite de `IEnumerable<T>` en `IEnumerable<Ti>` , le type de ***collection*** est l’interface `IEnumerable<T>` , le type d' ***énumérateur*** est l’interface `IEnumerator<T>` et le type d' ***élément*** est `T` .</span><span class="sxs-lookup"><span data-stu-id="7ffb7-132">If among all the types `Ti` for which there is an implicit conversion from `X` to `IEnumerable<Ti>`, there is a unique type `T` such that `T` is not `dynamic` and for all the other `Ti` there is an implicit conversion from `IEnumerable<T>` to `IEnumerable<Ti>`, then the ***collection type*** is the interface `IEnumerable<T>`, the ***enumerator type*** is the interface `IEnumerator<T>`, and the ***element type*** is `T`.</span></span>
>    * <span data-ttu-id="7ffb7-133">Sinon, s’il existe plusieurs types de ce type `T` , une erreur est générée et aucune autre étape n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-133">Otherwise, if there is more than one such type `T`, then an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-134">Sinon, s’il existe une conversion implicite de `X` en `System.Collections.IEnumerable` interface, le ***type de collection*** est cette interface, le ***type d’énumérateur*** est l’interface `System.Collections.IEnumerator` et le ***type d’élément*** est `object` .</span><span class="sxs-lookup"><span data-stu-id="7ffb7-134">Otherwise, if there is an implicit conversion from `X` to the `System.Collections.IEnumerable` interface, then the ***collection type*** is this interface, the ***enumerator type*** is the interface `System.Collections.IEnumerator`, and the ***element type*** is `object`.</span></span>
>*  <span data-ttu-id="7ffb7-135">Sinon, déterminez si le type’X’a une `GetEnumerator` méthode d’extension appropriée :</span><span class="sxs-lookup"><span data-stu-id="7ffb7-135">Otherwise, determine whether the type 'X' has an appropriate `GetEnumerator` extension method:</span></span>
>    * <span data-ttu-id="7ffb7-136">Effectue une recherche de méthode d’extension sur le type `X` avec l’identificateur `GetEnumerator` .</span><span class="sxs-lookup"><span data-stu-id="7ffb7-136">Perform extension method lookup on the type `X` with identifier `GetEnumerator`.</span></span> <span data-ttu-id="7ffb7-137">Si la recherche de membre ne produit pas de correspondance, si elle génère une ambiguïté ou si elle produit une correspondance qui n’est pas un groupe de méthodes, une erreur est générée et aucune autre étape n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-137">If the member lookup does not produce a match, or it produces an ambiguity, or produces a match which is not a method group, an error is produced and no further steps are taken.</span></span> <span data-ttu-id="7ffb7-138">Il est recommandé qu’un avertissement soit émis si la recherche de membres produit n’importe quoi, sauf un groupe de méthodes ou aucune correspondance.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-138">It is recommended that a warning be issues if member lookup produces anything except a method group or no match.</span></span>
>    * <span data-ttu-id="7ffb7-139">Exécutez la résolution de surcharge à l’aide du groupe de méthodes résultant et d’un argument unique de type `X` .</span><span class="sxs-lookup"><span data-stu-id="7ffb7-139">Perform overload resolution using the resulting method group and a single argument of type `X`.</span></span> <span data-ttu-id="7ffb7-140">Si la résolution de surcharge ne produit aucune méthode applicable, provoque une ambiguïté ou produit une seule meilleure méthode mais que cette méthode n’est pas accessible, une erreur est générée. aucune autre étape n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-140">If overload resolution produces no applicable methods, results in an ambiguity, or results in a single best method but that method is not accessible, an error is produced an no further steps are taken.</span></span>
>        * <span data-ttu-id="7ffb7-141">Cette résolution permet au premier argument d’être passé par Ref si `X` est un type struct et le genre Ref est `in` .</span><span class="sxs-lookup"><span data-stu-id="7ffb7-141">This resolution permits the first argument to be passed by ref if `X` is a struct type, and the ref kind is `in`.</span></span>
>    * <span data-ttu-id="7ffb7-142">Si le type `E` de retour de la `GetEnumerator` méthode n’est pas un type de classe, de struct ou d’interface, une erreur est générée et aucune autre étape n’est prise.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-142">If the return type `E` of the `GetEnumerator` method is not a class, struct or interface type, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-143">La recherche de membres est effectuée sur `E` avec l’identificateur `Current` et aucun argument de type.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-143">Member lookup is performed on `E` with the identifier `Current` and no type arguments.</span></span> <span data-ttu-id="7ffb7-144">Si la recherche de membre ne produit aucune correspondance, le résultat est une erreur, ou le résultat est tout sauf une propriété d’instance publique qui autorise la lecture, une erreur est générée et aucune autre étape n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-144">If the member lookup produces no match, the result is an error, or the result is anything except a public instance property that permits reading, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-145">La recherche de membres est effectuée sur `E` avec l’identificateur `MoveNext` et aucun argument de type.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-145">Member lookup is performed on `E` with the identifier `MoveNext` and no type arguments.</span></span> <span data-ttu-id="7ffb7-146">Si la recherche de membre ne produit aucune correspondance, le résultat est une erreur, ou le résultat est tout sauf un groupe de méthodes, une erreur est générée et aucune autre étape n’est prise.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-146">If the member lookup produces no match, the result is an error, or the result is anything except a method group, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-147">La résolution de surcharge est effectuée sur le groupe de méthodes avec une liste d’arguments vide.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-147">Overload resolution is performed on the method group with an empty argument list.</span></span> <span data-ttu-id="7ffb7-148">Si la résolution de surcharge entraîne l’absence de méthodes applicables, entraîne une ambiguïté ou produit une seule meilleure méthode, mais cette méthode est statique ou non publique, ou son type de retour n’est pas `bool` , une erreur est générée et aucune autre étape n’est prise.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-148">If overload resolution results in no applicable methods, results in an ambiguity, or results in a single best method but that method is either static or not public, or its return type is not `bool`, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="7ffb7-149">Le ***type de collection*** est `X` , le ***type d’énumérateur*** est `E` , et le type d' ***élément*** est le type de la `Current` propriété.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-149">The ***collection type*** is `X`, the ***enumerator type*** is `E`, and the ***element type*** is the type of the `Current` property.</span></span>
>*  <span data-ttu-id="7ffb7-150">Dans le cas contraire, une erreur est générée et aucune autre étape n’est prise.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-150">Otherwise, an error is produced and no further steps are taken.</span></span>

<span data-ttu-id="7ffb7-151">Pour `await foreach` , les règles sont modifiées de façon similaire.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-151">For `await foreach`, the rules are similarly modified.</span></span> <span data-ttu-id="7ffb7-152">La seule modification requise pour cette spécification consiste à supprimer la `Extension methods do not contribute.` ligne de la description, car le reste de cette spécification est basé sur les règles ci-dessus avec des noms différents substitués pour les méthodes de modèle.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-152">The only change that is required to that spec is removing the `Extension methods do not contribute.` line from the description, as the rest of that spec is based on the above rules with different names substituted for the pattern methods.</span></span>

## <a name="drawbacks"></a><span data-ttu-id="7ffb7-153">Inconvénients</span><span class="sxs-lookup"><span data-stu-id="7ffb7-153">Drawbacks</span></span>
[drawbacks]: #drawbacks

<span data-ttu-id="7ffb7-154">Chaque modification ajoute une complexité supplémentaire à la langue, ce qui peut permettre d’effectuer des tâches qui n’ont pas été conçues pour être `foreach` `foreach` Ed, comme `Range` .</span><span class="sxs-lookup"><span data-stu-id="7ffb7-154">Every change adds additional complexity to the language, and this potentially allows things that weren't designed to be `foreach`ed to be `foreach`ed, like `Range`.</span></span>

## <a name="alternatives"></a><span data-ttu-id="7ffb7-155">Autres solutions</span><span class="sxs-lookup"><span data-stu-id="7ffb7-155">Alternatives</span></span>
[alternatives]: #alternatives

<span data-ttu-id="7ffb7-156">Ne rien faire.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-156">Doing nothing.</span></span>

## <a name="unresolved-questions"></a><span data-ttu-id="7ffb7-157">Questions non résolues</span><span class="sxs-lookup"><span data-stu-id="7ffb7-157">Unresolved questions</span></span>
[unresolved]: #unresolved-questions

<span data-ttu-id="7ffb7-158">Aucun à ce stade.</span><span class="sxs-lookup"><span data-stu-id="7ffb7-158">None at this point.</span></span>
