---
ms.openlocfilehash: f238a711e710bbac7f5b7400fa938bd85dec00c6
ms.sourcegitcommit: 5278336b61519956240a6f7d83bcb4322019e032
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/10/2020
ms.locfileid: "79485251"
---
# <a name="support-for--and--on-tuple-types"></a><span data-ttu-id="49035-101">Prise en charge de = = et ! = sur les types de Tuple</span><span class="sxs-lookup"><span data-stu-id="49035-101">Support for == and != on tuple types</span></span>

<span data-ttu-id="49035-102">Autorisez les expressions `t1 == t2` où `t1` et `t2` sont des types de tuple tuple ou Nullable de même cardinalité, et évaluez-les approximativement comme `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` (en supposant `var temp1 = t1; var temp2 = t2;`).</span><span class="sxs-lookup"><span data-stu-id="49035-102">Allow expressions `t1 == t2` where `t1` and `t2` are tuple or nullable tuple types of same cardinality, and evaluate them roughly as `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` (assuming `var temp1 = t1; var temp2 = t2;`).</span></span>

<span data-ttu-id="49035-103">À l’inverse, cela permettrait `t1 != t2` et de l’évaluer comme `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`.</span><span class="sxs-lookup"><span data-stu-id="49035-103">Conversely it would allow `t1 != t2` and evaluate it as `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`.</span></span>

<span data-ttu-id="49035-104">Dans le cas Nullable, des vérifications supplémentaires pour `temp1.HasValue` et `temp2.HasValue` sont utilisées.</span><span class="sxs-lookup"><span data-stu-id="49035-104">In the nullable case, additional checks for `temp1.HasValue` and `temp2.HasValue` are used.</span></span> <span data-ttu-id="49035-105">Par exemple, `nullableT1 == nullableT2` est évalué comme `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`.</span><span class="sxs-lookup"><span data-stu-id="49035-105">For instance, `nullableT1 == nullableT2` evaluates as `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`.</span></span>

<span data-ttu-id="49035-106">Quand une comparaison d’éléments retourne un résultat non bool (par exemple, lorsqu’un `operator ==` ou `operator !=` non booléen défini par l’utilisateur est utilisé, ou dans une comparaison dynamique), ce résultat est converti en `bool` ou exécuté via `operator true` ou `operator false` pour obtenir une `bool`.</span><span class="sxs-lookup"><span data-stu-id="49035-106">When an element-wise comparison returns a non-bool result (for instance, when a non-bool user-defined `operator ==` or `operator !=` is used, or in a dynamic comparison), then that result will be either converted to `bool` or run through `operator true` or `operator false` to get a `bool`.</span></span> <span data-ttu-id="49035-107">La comparaison de tuples finit toujours par retourner un `bool`.</span><span class="sxs-lookup"><span data-stu-id="49035-107">The tuple comparison always ends up returning a `bool`.</span></span>

<span data-ttu-id="49035-108">À partir C# de 7,2, ce code génère une erreur (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`), sauf s’il existe une `operator==`définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="49035-108">As of C# 7.2, such code produces an error (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`), unless there is a user-defined `operator==`.</span></span>

## <a name="details"></a><span data-ttu-id="49035-109">Détails</span><span class="sxs-lookup"><span data-stu-id="49035-109">Details</span></span>

<span data-ttu-id="49035-110">Lors de la liaison de l’opérateur `==` (ou `!=`), les règles existantes sont : (1) cas dynamique, (2) la résolution de surcharge et (3) échouent.</span><span class="sxs-lookup"><span data-stu-id="49035-110">When binding the `==` (or `!=`) operator, the existing rules are: (1) dynamic case, (2) overload resolution, and (3) fail.</span></span>
<span data-ttu-id="49035-111">Cette proposition ajoute un cas de tuple entre (1) et (2) : si les deux opérandes d’un opérateur de comparaison sont des tuples (ayant des types de tuple ou des littéraux de Tuple) et une cardinalité correspondante, la comparaison est effectuée par élément.</span><span class="sxs-lookup"><span data-stu-id="49035-111">This proposal adds a tuple case between (1) and (2): if both operands of a comparison operator are tuples (have tuple types or are tuple literals) and have matching cardinality, then the comparison is performed element-wise.</span></span> <span data-ttu-id="49035-112">Cette égalité de tuples est également levée sur des tuples Nullable.</span><span class="sxs-lookup"><span data-stu-id="49035-112">This tuple equality is also lifted onto nullable tuples.</span></span>

<span data-ttu-id="49035-113">Les deux opérandes (et, dans le cas des littéraux de tuple, leurs éléments) sont évalués dans l’ordre de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="49035-113">Both operands (and, in the case of tuple literals, their elements) are evaluated in order from left to right.</span></span> <span data-ttu-id="49035-114">Chaque paire d’éléments est ensuite utilisée comme opérande pour lier l’opérateur `==` (ou `!=`), de manière récursive.</span><span class="sxs-lookup"><span data-stu-id="49035-114">Each pair of elements is then used as operands to bind the operator `==` (or `!=`), recursively.</span></span> <span data-ttu-id="49035-115">Tous les éléments avec le type au moment de la compilation `dynamic` provoquent une erreur.</span><span class="sxs-lookup"><span data-stu-id="49035-115">Any elements with compile-time type `dynamic` cause an error.</span></span> <span data-ttu-id="49035-116">Les résultats de ces comparaisons au niveau des éléments sont utilisés comme opérandes dans une chaîne d’opérateurs conditionnels AND (ou OR).</span><span class="sxs-lookup"><span data-stu-id="49035-116">The results of those element-wise comparisons are used as operands in a chain of conditional AND (or OR) operators.</span></span>

<span data-ttu-id="49035-117">Par exemple, dans le contexte d' `(int, (int, int)) t1, t2;`, `t1 == (1, (2, 3))` évaluerait comme `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp2.Item2.Item2 == temp2.Item2.Item2`.</span><span class="sxs-lookup"><span data-stu-id="49035-117">For instance, in the context of `(int, (int, int)) t1, t2;`, `t1 == (1, (2, 3))` would evaluate as `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp2.Item2.Item2 == temp2.Item2.Item2`.</span></span>

<span data-ttu-id="49035-118">Lorsqu’un littéral de tuple est utilisé en tant qu’opérande (de chaque côté), il reçoit un type de tuple converti formé par les conversions d’éléments qui sont introduites lors de la liaison de l’opérateur `==` (ou `!=`) au niveau de l’élément.</span><span class="sxs-lookup"><span data-stu-id="49035-118">When a tuple literal is used as operand (on either side), it receives a converted tuple type formed by the element-wise conversions which are introduced when binding the operator `==` (or `!=`) element-wise.</span></span> 

<span data-ttu-id="49035-119">Par exemple, dans `(1L, 2, "hello") == (1, 2L, null)`, le type converti pour les littéraux de tuple est `(long, long, string)` et le deuxième littéral n’a pas de type naturel.</span><span class="sxs-lookup"><span data-stu-id="49035-119">For instance, in `(1L, 2, "hello") == (1, 2L, null)`, the converted type for both tuple literals is `(long, long, string)` and the second literal has no natural type.</span></span>


### <a name="deconstruction-and-conversions-to-tuple"></a><span data-ttu-id="49035-120">Déconstruction et conversions en Tuple</span><span class="sxs-lookup"><span data-stu-id="49035-120">Deconstruction and conversions to tuple</span></span>
<span data-ttu-id="49035-121">Dans `(a, b) == x`, le fait que `x` pouvez décomposer en deux éléments ne joue pas un rôle.</span><span class="sxs-lookup"><span data-stu-id="49035-121">In `(a, b) == x`, the fact that `x` can deconstruct into two elements does not play a role.</span></span> <span data-ttu-id="49035-122">Cela peut se présenter dans une prochaine proposition, bien qu’elle soulève des questions sur `x == y` (est-ce une comparaison simple ou une comparaison d’éléments, et si vous utilisez la cardinalité ?).</span><span class="sxs-lookup"><span data-stu-id="49035-122">That could conceivably be in a future proposal, although it would raise questions about `x == y` (is this a simple comparison or an element-wise comparison, and if so using what cardinality?).</span></span>
<span data-ttu-id="49035-123">De même, les conversions en tuple ne jouent aucun rôle.</span><span class="sxs-lookup"><span data-stu-id="49035-123">Similarly, conversions to tuple play no role.</span></span>

### <a name="tuple-element-names"></a><span data-ttu-id="49035-124">Noms d’éléments de Tuple</span><span class="sxs-lookup"><span data-stu-id="49035-124">Tuple element names</span></span>

<span data-ttu-id="49035-125">Lors de la conversion d’un littéral de tuple, nous avertissons quand un nom d’élément de tuple explicite a été fourni dans le littéral, mais il ne correspond pas au nom d’élément de tuple cible.</span><span class="sxs-lookup"><span data-stu-id="49035-125">When converting a tuple literal, we warn when an explicit tuple element name was provided in the literal, but it doesn't match the target tuple element name.</span></span>
<span data-ttu-id="49035-126">Nous utilisons la même règle dans la comparaison des tuples, afin de supposer `(int a, int b) t` nous avertissons sur `d` dans `t == (c, d: 0)`.</span><span class="sxs-lookup"><span data-stu-id="49035-126">We use the same rule in tuple comparison, so that assuming `(int a, int b) t` we warn on `d` in `t == (c, d: 0)`.</span></span>

### <a name="non-bool-element-wise-comparison-results"></a><span data-ttu-id="49035-127">Résultats de la comparaison non-bool au niveau des éléments</span><span class="sxs-lookup"><span data-stu-id="49035-127">Non-bool element-wise comparison results</span></span>

<span data-ttu-id="49035-128">Si une comparaison au niveau des éléments est dynamique dans une égalité de tuples, nous utilisons un appel dynamique de l’opérateur `false` et annulons cela pour obtenir une `bool` et poursuivre avec d’autres comparaisons au niveau des éléments.</span><span class="sxs-lookup"><span data-stu-id="49035-128">If an element-wise comparison is dynamic in a tuple equality, we use a dynamic invocation of the operator `false` and negate that to get a `bool` and continue with further element-wise comparisons.</span></span> 

<span data-ttu-id="49035-129">Si une comparaison au niveau des éléments retourne un autre type non booléen dans une égalité de tuples, il y a deux cas :</span><span class="sxs-lookup"><span data-stu-id="49035-129">If an element-wise comparison returns some other non-bool type in a tuple equality, there are two cases:</span></span>
- <span data-ttu-id="49035-130">Si le type non bool convertit en `bool`, nous appliquons cette conversion,</span><span class="sxs-lookup"><span data-stu-id="49035-130">if the non-bool type converts to `bool`, we apply that conversion,</span></span>
- <span data-ttu-id="49035-131">s’il n’existe aucune conversion de ce type, mais que le type a un opérateur `false`, nous l’utiliserons et nie le résultat.</span><span class="sxs-lookup"><span data-stu-id="49035-131">if there is no such conversion, but the type has an operator `false`, we'll use that and negate the result.</span></span>

<span data-ttu-id="49035-132">Dans une inégalité de tuple, les mêmes règles s’appliquent, sauf que nous allons utiliser l’opérateur `true` (sans négation) au lieu de l’opérateur `false`.</span><span class="sxs-lookup"><span data-stu-id="49035-132">In a tuple inequality, the same rules apply except that we'll use the operator `true` (without negation) instead of the operator `false`.</span></span>

<span data-ttu-id="49035-133">Ces règles sont similaires aux règles impliquées dans l’utilisation d’un type non booléen dans une instruction `if` et d’autres contextes existants.</span><span class="sxs-lookup"><span data-stu-id="49035-133">Those rules are similar to the rules involved for using a non-bool type in an `if` statement and some other existing contexts.</span></span>

## <a name="evaluation-order-and-special-cases"></a><span data-ttu-id="49035-134">Ordre d’évaluation et cas spéciaux</span><span class="sxs-lookup"><span data-stu-id="49035-134">Evaluation order and special cases</span></span>
<span data-ttu-id="49035-135">La valeur de gauche est évaluée en premier, puis la valeur de droite, puis les comparaisons au niveau des éléments de gauche à droite (y compris les conversions et avec la sortie précoce en fonction des règles existantes pour les opérateurs conditionnels et/ou).</span><span class="sxs-lookup"><span data-stu-id="49035-135">The left-hand-side value is evaluated first, then the right-hand-side value, then the element-wise comparisons from left to right (including conversions, and with early exit based on existing rules for conditional AND/OR operators).</span></span>

<span data-ttu-id="49035-136">Par exemple, s’il existe une conversion du type `A` en type `B` et une méthode `(A, A) GetTuple()`, l’évaluation de `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` signifie :</span><span class="sxs-lookup"><span data-stu-id="49035-136">For instance, if there is a conversion from type `A` to type `B` and a method `(A, A) GetTuple()`, evaluating `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` means:</span></span>
- `new A(1)`
- `new B(2)`
- `new B(3)`
- `new B(4)`
- `GetTuple()`
- <span data-ttu-id="49035-137">Ensuite, les conversions et les comparaisons de type élément et la logique conditionnelle sont évaluées (convertissez `new A(1)` en type `B`, puis comparez-les à `new B(4)`, etc.).</span><span class="sxs-lookup"><span data-stu-id="49035-137">then the element-wise conversions and comparisons and conditional logic is evaluated (convert `new A(1)` to type `B`, then compare it with `new B(4)`, and so on).</span></span>

### <a name="comparing-null-to-null"></a><span data-ttu-id="49035-138">Comparaison de `null` à `null`</span><span class="sxs-lookup"><span data-stu-id="49035-138">Comparing `null` to `null`</span></span>

<span data-ttu-id="49035-139">Il s’agit d’un cas spécial de comparaisons régulières, qui effectue des comparaisons de tuples.</span><span class="sxs-lookup"><span data-stu-id="49035-139">This is a special case from regular comparisons, that carries over to tuple comparisons.</span></span> <span data-ttu-id="49035-140">La comparaison `null == null` est autorisée, et les littéraux de `null` n’obtiennent aucun type.</span><span class="sxs-lookup"><span data-stu-id="49035-140">The `null == null` comparison is allowed, and the `null` literals do not get any type.</span></span>
<span data-ttu-id="49035-141">Dans l’égalité des tuples, cela signifie que `(0, null) == (0, null)` est également autorisé et que les littéraux de `null` et de tuple n’obtiennent pas non plus de type.</span><span class="sxs-lookup"><span data-stu-id="49035-141">In tuple equality, this means, `(0, null) == (0, null)` is also allowed and the `null` and tuple literals don't get a type either.</span></span>

### <a name="comparing-a-nullable-struct-to-null-without-operator"></a><span data-ttu-id="49035-142">Comparaison d’un struct Nullable à `null` sans `operator==`</span><span class="sxs-lookup"><span data-stu-id="49035-142">Comparing a nullable struct to `null` without `operator==`</span></span>

<span data-ttu-id="49035-143">Il s’agit d’un autre cas spécial issu de comparaisons régulières, qui effectue des comparaisons de tuples.</span><span class="sxs-lookup"><span data-stu-id="49035-143">This is another special case from regular comparisons, that carries over to tuple comparisons.</span></span>
<span data-ttu-id="49035-144">Si vous avez un `struct S` sans `operator==`, la comparaison `(S?)x == null` est autorisée et est interprétée comme `((S?).x).HasValue`.</span><span class="sxs-lookup"><span data-stu-id="49035-144">If you have a `struct S` without `operator==`, the `(S?)x == null` comparison is allowed, and it is interpreted as `((S?).x).HasValue`.</span></span>
<span data-ttu-id="49035-145">Dans l’égalité des tuples, la même règle est appliquée, donc `(0, (S?)x) == (0, null)` est autorisé.</span><span class="sxs-lookup"><span data-stu-id="49035-145">In tuple equality, the same rule is applied, so `(0, (S?)x) == (0, null)` is allowed.</span></span>

## <a name="compatibility"></a><span data-ttu-id="49035-146">Compatibilité</span><span class="sxs-lookup"><span data-stu-id="49035-146">Compatibility</span></span>

<span data-ttu-id="49035-147">Si quelqu’un a écrit ses propres `ValueTuple` types avec une implémentation de l’opérateur de comparaison, il aurait été précédemment récupéré par la résolution de surcharge.</span><span class="sxs-lookup"><span data-stu-id="49035-147">If someone wrote their own `ValueTuple` types with  an implementation of the comparison operator, it would have previously been picked up by overload resolution.</span></span> <span data-ttu-id="49035-148">Toutefois, étant donné que le nouveau cas de tuple vient avant la résolution de surcharge, nous traiterons ce cas avec la comparaison de tuples au lieu de compter sur la comparaison définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="49035-148">But since the new tuple case comes before overload resolution, we would handle this case with tuple comparison instead of relying on the user-defined comparison.</span></span>

----

<span data-ttu-id="49035-149">Se rapporte aux [opérateurs relationnels et de test de type liés](../../spec/expressions.md#relational-and-type-testing-operators) à [#190](https://github.com/dotnet/csharplang/issues/190)</span><span class="sxs-lookup"><span data-stu-id="49035-149">Relates to [relational and type testing operators](../../spec/expressions.md#relational-and-type-testing-operators) Relates to [#190](https://github.com/dotnet/csharplang/issues/190)</span></span>
